###############################################################################
#
# IAR ANSI C/C++ Compiler V7.80.4.12462/W32 for ARM       17/May/2019  13:32:04
# Copyright 1999-2017 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\GNSS\Software\rJ104_rc2\source\GNSS_GW\common\gnss_gw_common.c
#    Command line =  
#        C:\GNSS\Software\rJ104_rc2\source\GNSS_GW\common\gnss_gw_common.c -D
#        __TARGET_ARCH_7_M -D S1C31W74 -D GNSS_GW_SIDE_B -lCN
#        C:\GNSS\Software\rJ104_rc2\source\GNSS_GW\board\S5U1C31W74T1\IAR\DebugFlashBside\List
#        -lA
#        C:\GNSS\Software\rJ104_rc2\source\GNSS_GW\board\S5U1C31W74T1\IAR\DebugFlashBside\List
#        --diag_suppress Pe177,Pe111,Pa082 -o
#        C:\GNSS\Software\rJ104_rc2\source\GNSS_GW\board\S5U1C31W74T1\IAR\DebugFlashBside\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M0+ -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.5\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\GNSS\Software\rJ104_rc2\source\GNSS_GW\board\S5U1C31W74T1\IAR\ -I
#        C:\GNSS\Software\rJ104_rc2\source\GNSS_GW\board\S5U1C31W74T1\IAR\..\..\..\
#        -I "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.5\arm\CMSIS\Include\" -I "C:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 7.5\arm\inc\Epson\" -I
#        C:\GNSS\Software\rJ104_rc2\source\GNSS_GW\board\S5U1C31W74T1\IAR\..\..\..\..\..\CMSIS\Device\S1C31W74\Include\
#        -I
#        C:\GNSS\Software\rJ104_rc2\source\GNSS_GW\board\S5U1C31W74T1\IAR\..\..\..\..\..\CMSIS\Driver\Include\
#        -I
#        C:\GNSS\Software\rJ104_rc2\source\GNSS_GW\board\S5U1C31W74T1\IAR\..\..\..\..\..\sePeriphLibrary\
#        -I
#        C:\GNSS\Software\rJ104_rc2\source\GNSS_GW\board\S5U1C31W74T1\IAR\..\..\..\..\..\board\S5U1C31W74T1\
#        -I
#        C:\GNSS\Software\rJ104_rc2\source\GNSS_GW\board\S5U1C31W74T1\IAR\..\..\..\..\..\USBStack\INC\
#        -I
#        C:\GNSS\Software\rJ104_rc2\source\GNSS_GW\board\S5U1C31W74T1\IAR\..\..\..\include\
#        -Ol
#    Locale       =  Japanese_Japan.932
#    List file    =  
#        C:\GNSS\Software\rJ104_rc2\source\GNSS_GW\board\S5U1C31W74T1\IAR\DebugFlashBside\List\gnss_gw_common.lst
#    Object file  =  
#        C:\GNSS\Software\rJ104_rc2\source\GNSS_GW\board\S5U1C31W74T1\IAR\DebugFlashBside\Obj\gnss_gw_common.o
#
###############################################################################

C:\GNSS\Software\rJ104_rc2\source\GNSS_GW\common\gnss_gw_common.c
      1          /**
      2            ******************************************************************************
      3            * @file    gnss_gw_common.c
      4            * @author  コア
      5            * @version V1.0
      6            * @date    2017.10.2
      7            * @brief   共通定義
      8            ******************************************************************************
      9            $Id: gnss_gw_common.c 57 2018-03-30 05:54:51Z shitaoka $
     10            * @attention
     11            *
     12            ******************************************************************************
     13            */
     14          
     15          #include <string.h>
     16          #include <stdio.h>
     17          #include <stdlib.h>
     18          #include "board.h"
     19          #include "gnss_gw_common.h"
     20          
     21          
     22          #pragma section = "COM_PRG_BLOCK"
     23          
     24          
     25          #define	UTC_CONV_JST		9			// 9時間
     26          
     27          
     28          // 月と日の関係テーブル

   \                                 In section .rodata, align 4
     29          static const uint8_t month_day_tbl[13][2] = {
   \                     month_day_tbl:
   \   00000000   0x1F 0x1F          DC8 31, 31, 31, 31, 28, 29, 31, 31, 30, 30, 31, 31, 30, 30, 31, 31, 31
   \              0x1F 0x1F    
   \              0x1C 0x1D    
   \              0x1F 0x1F    
   \              0x1E 0x1E    
   \              0x1F 0x1F    
   \              0x1E 0x1E    
   \              0x1F 0x1F    
   \              0x1F         
   \   00000011   0x1F 0x1E          DC8 31, 30, 30, 31, 31, 30, 30, 31, 31, 0, 0
   \              0x1E 0x1F    
   \              0x1F 0x1E    
   \              0x1E 0x1F    
   \              0x1F 0x00    
   \              0x00         
     30          	{31,	31},			//  0月(前年の12月)
     31          	{31,	31},			//  1月
     32          	{28,	29},			//  2月
     33          	{31,	31},			//  3月
     34          	{30,	30},			//  4月
     35          	{31,	31},			//  5月
     36          	{30,	30},			//  6月
     37          	{31,	31},			//  7月
     38          	{31,	31},			//  8月
     39          	{30,	30},			//  9月
     40          	{31,	31},			// 10月
     41          	{30,	30},			// 11月
     42          	{31,	31}				// 12月
     43          };
     44          
     45          
     46          

   \                                 In section .bss, align 4
     47          static clock_info_t	utc;		// UTC時刻
   \                     utc:
   \   00000000                      DS8 8

   \                                 In section .bss, align 4
     48          static clock_info_t	jst;		// JST時刻
   \                     jst:
   \   00000000                      DS8 8
     49          
     50          
     51          
     52          
     53          /********************************************************************/
     54          /*!
     55           * \name	num_to_bcd
     56           * \brief	数字をASCIIコード(BCD)に変換する処理
     57           * \param	ascii       : 格納先
     58           *          num         : 変換する数字(0 〜 99)
     59           * \return  
     60           * \note	0 〜 99を指定すること
     61           *          上記以外を指定すると変換しない
     62          */
     63          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
     64          void num_to_bcd(uint8_t *ascii, int8_t num)
     65          {
   \                     num_to_bcd: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
     66          	if ( num <= 99 ) {
   \   00000006   0xB26D             SXTB     R5,R5
   \   00000008   0x2D64             CMP      R5,#+100
   \   0000000A   0xDA0D             BGE      ??num_to_bcd_0
     67          		ascii[0] = (num/10) + '0';
   \   0000000C   0xB26D             SXTB     R5,R5
   \   0000000E   0x0028             MOVS     R0,R5
   \   00000010   0x210A             MOVS     R1,#+10
   \   00000012   0x.... 0x....      BL       __aeabi_idiv
   \   00000016   0x3030             ADDS     R0,R0,#+48
   \   00000018   0x7020             STRB     R0,[R4, #+0]
     68          		ascii[1] = (num%10) + '0';
   \   0000001A   0xB26D             SXTB     R5,R5
   \   0000001C   0x0028             MOVS     R0,R5
   \   0000001E   0x210A             MOVS     R1,#+10
   \   00000020   0x.... 0x....      BL       __aeabi_idivmod
   \   00000024   0x3130             ADDS     R1,R1,#+48
   \   00000026   0x7061             STRB     R1,[R4, #+1]
     69          	}
     70          }
   \                     ??num_to_bcd_0: (+1)
   \   00000028   0xBD30             POP      {R4,R5,PC}       ;; return
     71          
     72          /********************************************************************/
     73          /*!
     74           * \name	bcd_to_num
     75           * \brief	ASCIIコード(BCD)を数字に変換する処理
     76           * \param	ascii       : 格納先
     77           *          num         : 変換後の数字(0 〜 99)
     78           * \return  
     79           * \note	ASCIIコード(BCD)であることが条件
     80           */
     81          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
     82          void bcd_to_num(uint8_t *ascii, int8_t *num)
     83          {
     84          	*num = ascii[0] - '0';
   \                     bcd_to_num: (+1)
   \   00000000   0x7802             LDRB     R2,[R0, #+0]
   \   00000002   0x3A30             SUBS     R2,R2,#+48
   \   00000004   0x700A             STRB     R2,[R1, #+0]
     85          	*num *= 10;
   \   00000006   0x780A             LDRB     R2,[R1, #+0]
   \   00000008   0x230A             MOVS     R3,#+10
   \   0000000A   0x435A             MULS     R2,R3,R2
   \   0000000C   0x700A             STRB     R2,[R1, #+0]
     86          	*num += ascii[1] - '0';
   \   0000000E   0x780A             LDRB     R2,[R1, #+0]
   \   00000010   0x7840             LDRB     R0,[R0, #+1]
   \   00000012   0x3830             SUBS     R0,R0,#+48
   \   00000014   0x1810             ADDS     R0,R2,R0
   \   00000016   0x7008             STRB     R0,[R1, #+0]
     87          }
   \   00000018   0x4770             BX       LR               ;; return
     88          
     89          
     90          
     91          
     92          /********************************************************************/
     93          /*!
     94           * \name	itoa_local
     95           * \brief	数字を文字列に変換する処理
     96           * \param	num         : 数字
     97           *          buffer      : 文字列
     98           *          len         : 文字数
     99           * \return  0
    100           * \note	
    101           */
    102          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    103          int32_t	itoa_local(int32_t num, uint8_t *buffer, int32_t *len)
    104          {
   \                     itoa_local: (+1)
   \   00000000   0xB5F4             PUSH     {R2,R4-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    105          	int32_t		ret=-1;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x43C0             MVNS     R0,R0            ;; #-1
    106          	int32_t		point=0;
   \   0000000A   0x2600             MOVS     R6,#+0
    107          	int32_t		num_buf = num;
   \   0000000C   0x0027             MOVS     R7,R4
    108          	int32_t		flag=0;
   \   0000000E   0x2000             MOVS     R0,#+0
    109          
    110          	if (num_buf < 0) {
   \   00000010   0x2F00             CMP      R7,#+0
   \   00000012   0xD506             BPL      ??itoa_local_0
    111          		buffer[point++] = '-'; 
   \   00000014   0x212D             MOVS     R1,#+45
   \   00000016   0x55A9             STRB     R1,[R5, R6]
   \   00000018   0x1C76             ADDS     R6,R6,#+1
    112          		num_buf = num_buf ^ 0xffffffff;
   \   0000001A   0x0039             MOVS     R1,R7
   \   0000001C   0x2700             MOVS     R7,#+0
   \   0000001E   0x43FF             MVNS     R7,R7            ;; #-1
   \   00000020   0x404F             EORS     R7,R7,R1
    113          	}
    114          
    115          	if (num >= 1000000000) {
   \                     ??itoa_local_0: (+1)
   \   00000022   0x....             LDR      R1,??DataTable2  ;; 0x3b9aca00
   \   00000024   0x428C             CMP      R4,R1
   \   00000026   0xDB0C             BLT      ??itoa_local_1
    116          		buffer[point++] = (num_buf/1000000000) + '0';
   \   00000028   0x0038             MOVS     R0,R7
   \   0000002A   0x....             LDR      R1,??DataTable2  ;; 0x3b9aca00
   \   0000002C   0x.... 0x....      BL       __aeabi_idiv
   \   00000030   0x3030             ADDS     R0,R0,#+48
   \   00000032   0x55A8             STRB     R0,[R5, R6]
   \   00000034   0x1C76             ADDS     R6,R6,#+1
    117          		num_buf = (num_buf % 1000000000);
   \   00000036   0x0038             MOVS     R0,R7
   \   00000038   0x....             LDR      R1,??DataTable2  ;; 0x3b9aca00
   \   0000003A   0x.... 0x....      BL       __aeabi_idivmod
   \   0000003E   0x000F             MOVS     R7,R1
    118          		flag=1;
   \   00000040   0x2001             MOVS     R0,#+1
    119          	}
    120          	if ( (num >= 100000000) || (flag == 1) ) {
   \                     ??itoa_local_1: (+1)
   \   00000042   0x....             LDR      R1,??DataTable2_1  ;; 0x5f5e100
   \   00000044   0x428C             CMP      R4,R1
   \   00000046   0xDA01             BGE      ??itoa_local_2
   \   00000048   0x2801             CMP      R0,#+1
   \   0000004A   0xD10C             BNE      ??itoa_local_3
    121          		buffer[point++] = (num_buf/100000000) + '0';
   \                     ??itoa_local_2: (+1)
   \   0000004C   0x0038             MOVS     R0,R7
   \   0000004E   0x....             LDR      R1,??DataTable2_1  ;; 0x5f5e100
   \   00000050   0x.... 0x....      BL       __aeabi_idiv
   \   00000054   0x3030             ADDS     R0,R0,#+48
   \   00000056   0x55A8             STRB     R0,[R5, R6]
   \   00000058   0x1C76             ADDS     R6,R6,#+1
    122          		num_buf = (num_buf % 100000000);
   \   0000005A   0x0038             MOVS     R0,R7
   \   0000005C   0x....             LDR      R1,??DataTable2_1  ;; 0x5f5e100
   \   0000005E   0x.... 0x....      BL       __aeabi_idivmod
   \   00000062   0x000F             MOVS     R7,R1
    123          		flag=1;
   \   00000064   0x2001             MOVS     R0,#+1
    124          	}
    125          	if ( (num >= 10000000) || (flag == 1) ) {
   \                     ??itoa_local_3: (+1)
   \   00000066   0x....             LDR      R1,??DataTable2_2  ;; 0x989680
   \   00000068   0x428C             CMP      R4,R1
   \   0000006A   0xDA01             BGE      ??itoa_local_4
   \   0000006C   0x2801             CMP      R0,#+1
   \   0000006E   0xD10C             BNE      ??itoa_local_5
    126          		buffer[point++] = (num_buf/10000000) + '0';
   \                     ??itoa_local_4: (+1)
   \   00000070   0x0038             MOVS     R0,R7
   \   00000072   0x....             LDR      R1,??DataTable2_2  ;; 0x989680
   \   00000074   0x.... 0x....      BL       __aeabi_idiv
   \   00000078   0x3030             ADDS     R0,R0,#+48
   \   0000007A   0x55A8             STRB     R0,[R5, R6]
   \   0000007C   0x1C76             ADDS     R6,R6,#+1
    127          		num_buf = (num_buf % 10000000);
   \   0000007E   0x0038             MOVS     R0,R7
   \   00000080   0x....             LDR      R1,??DataTable2_2  ;; 0x989680
   \   00000082   0x.... 0x....      BL       __aeabi_idivmod
   \   00000086   0x000F             MOVS     R7,R1
    128          		flag=1;
   \   00000088   0x2001             MOVS     R0,#+1
    129          	}
    130          	if ( (num >= 1000000) || (flag == 1) ) {
   \                     ??itoa_local_5: (+1)
   \   0000008A   0x....             LDR      R1,??DataTable2_3  ;; 0xf4240
   \   0000008C   0x428C             CMP      R4,R1
   \   0000008E   0xDA01             BGE      ??itoa_local_6
   \   00000090   0x2801             CMP      R0,#+1
   \   00000092   0xD10C             BNE      ??itoa_local_7
    131          		buffer[point++] = (num_buf/1000000) + '0';
   \                     ??itoa_local_6: (+1)
   \   00000094   0x0038             MOVS     R0,R7
   \   00000096   0x....             LDR      R1,??DataTable2_3  ;; 0xf4240
   \   00000098   0x.... 0x....      BL       __aeabi_idiv
   \   0000009C   0x3030             ADDS     R0,R0,#+48
   \   0000009E   0x55A8             STRB     R0,[R5, R6]
   \   000000A0   0x1C76             ADDS     R6,R6,#+1
    132          		num_buf = (num_buf % 1000000);
   \   000000A2   0x0038             MOVS     R0,R7
   \   000000A4   0x....             LDR      R1,??DataTable2_3  ;; 0xf4240
   \   000000A6   0x.... 0x....      BL       __aeabi_idivmod
   \   000000AA   0x000F             MOVS     R7,R1
    133          		flag=1;
   \   000000AC   0x2001             MOVS     R0,#+1
    134          	}
    135          	if ( (num >= 100000) || (flag == 1) ) {
   \                     ??itoa_local_7: (+1)
   \   000000AE   0x....             LDR      R1,??DataTable2_4  ;; 0x186a0
   \   000000B0   0x428C             CMP      R4,R1
   \   000000B2   0xDA01             BGE      ??itoa_local_8
   \   000000B4   0x2801             CMP      R0,#+1
   \   000000B6   0xD10C             BNE      ??itoa_local_9
    136          		buffer[point++] = (num_buf/100000) + '0';
   \                     ??itoa_local_8: (+1)
   \   000000B8   0x0038             MOVS     R0,R7
   \   000000BA   0x....             LDR      R1,??DataTable2_4  ;; 0x186a0
   \   000000BC   0x.... 0x....      BL       __aeabi_idiv
   \   000000C0   0x3030             ADDS     R0,R0,#+48
   \   000000C2   0x55A8             STRB     R0,[R5, R6]
   \   000000C4   0x1C76             ADDS     R6,R6,#+1
    137          		num_buf = (num_buf % 100000);
   \   000000C6   0x0038             MOVS     R0,R7
   \   000000C8   0x....             LDR      R1,??DataTable2_4  ;; 0x186a0
   \   000000CA   0x.... 0x....      BL       __aeabi_idivmod
   \   000000CE   0x000F             MOVS     R7,R1
    138          		flag=1;
   \   000000D0   0x2001             MOVS     R0,#+1
    139          	}
    140          	if ( (num >= 10000) || (flag == 1) ) {
   \                     ??itoa_local_9: (+1)
   \   000000D2   0x....             LDR      R1,??DataTable2_5  ;; 0x2710
   \   000000D4   0x428C             CMP      R4,R1
   \   000000D6   0xDA01             BGE      ??itoa_local_10
   \   000000D8   0x2801             CMP      R0,#+1
   \   000000DA   0xD10C             BNE      ??itoa_local_11
    141          		buffer[point++] = (num_buf/10000) + '0';
   \                     ??itoa_local_10: (+1)
   \   000000DC   0x0038             MOVS     R0,R7
   \   000000DE   0x....             LDR      R1,??DataTable2_5  ;; 0x2710
   \   000000E0   0x.... 0x....      BL       __aeabi_idiv
   \   000000E4   0x3030             ADDS     R0,R0,#+48
   \   000000E6   0x55A8             STRB     R0,[R5, R6]
   \   000000E8   0x1C76             ADDS     R6,R6,#+1
    142          		num_buf = (num_buf % 10000);
   \   000000EA   0x0038             MOVS     R0,R7
   \   000000EC   0x....             LDR      R1,??DataTable2_5  ;; 0x2710
   \   000000EE   0x.... 0x....      BL       __aeabi_idivmod
   \   000000F2   0x000F             MOVS     R7,R1
    143          		flag=1;
   \   000000F4   0x2001             MOVS     R0,#+1
    144          	}
    145          	if ( (num_buf >= 1000) || (flag == 1) ) {
   \                     ??itoa_local_11: (+1)
   \   000000F6   0x21FA             MOVS     R1,#+250
   \   000000F8   0x0089             LSLS     R1,R1,#+2        ;; #+1000
   \   000000FA   0x428F             CMP      R7,R1
   \   000000FC   0xDA01             BGE      ??itoa_local_12
   \   000000FE   0x2801             CMP      R0,#+1
   \   00000100   0xD10E             BNE      ??itoa_local_13
    146          		buffer[point++] = (num_buf/1000) + '0';
   \                     ??itoa_local_12: (+1)
   \   00000102   0x0038             MOVS     R0,R7
   \   00000104   0x21FA             MOVS     R1,#+250
   \   00000106   0x0089             LSLS     R1,R1,#+2        ;; #+1000
   \   00000108   0x.... 0x....      BL       __aeabi_idiv
   \   0000010C   0x3030             ADDS     R0,R0,#+48
   \   0000010E   0x55A8             STRB     R0,[R5, R6]
   \   00000110   0x1C76             ADDS     R6,R6,#+1
    147          		num_buf = (num_buf % 1000);
   \   00000112   0x0038             MOVS     R0,R7
   \   00000114   0x21FA             MOVS     R1,#+250
   \   00000116   0x0089             LSLS     R1,R1,#+2        ;; #+1000
   \   00000118   0x.... 0x....      BL       __aeabi_idivmod
   \   0000011C   0x000F             MOVS     R7,R1
    148          		flag=1;
   \   0000011E   0x2001             MOVS     R0,#+1
    149          	}
    150          	if ( (num_buf >= 100) || (flag == 1) ) {
   \                     ??itoa_local_13: (+1)
   \   00000120   0x2F64             CMP      R7,#+100
   \   00000122   0xDA01             BGE      ??itoa_local_14
   \   00000124   0x2801             CMP      R0,#+1
   \   00000126   0xD10C             BNE      ??itoa_local_15
    151          		buffer[point++] = (num_buf/100) + '0';
   \                     ??itoa_local_14: (+1)
   \   00000128   0x0038             MOVS     R0,R7
   \   0000012A   0x2164             MOVS     R1,#+100
   \   0000012C   0x.... 0x....      BL       __aeabi_idiv
   \   00000130   0x3030             ADDS     R0,R0,#+48
   \   00000132   0x55A8             STRB     R0,[R5, R6]
   \   00000134   0x1C76             ADDS     R6,R6,#+1
    152          		num_buf = (num_buf % 100);
   \   00000136   0x0038             MOVS     R0,R7
   \   00000138   0x2164             MOVS     R1,#+100
   \   0000013A   0x.... 0x....      BL       __aeabi_idivmod
   \   0000013E   0x000F             MOVS     R7,R1
    153          		flag=1;
   \   00000140   0x2001             MOVS     R0,#+1
    154          	}
    155          	if ( (num_buf >= 10) || (flag == 1) ) {
   \                     ??itoa_local_15: (+1)
   \   00000142   0x2F0A             CMP      R7,#+10
   \   00000144   0xDA01             BGE      ??itoa_local_16
   \   00000146   0x2801             CMP      R0,#+1
   \   00000148   0xD10C             BNE      ??itoa_local_17
    156          		buffer[point++] = (num_buf/10) + '0';
   \                     ??itoa_local_16: (+1)
   \   0000014A   0x0038             MOVS     R0,R7
   \   0000014C   0x210A             MOVS     R1,#+10
   \   0000014E   0x.... 0x....      BL       __aeabi_idiv
   \   00000152   0x3030             ADDS     R0,R0,#+48
   \   00000154   0x55A8             STRB     R0,[R5, R6]
   \   00000156   0x1C76             ADDS     R6,R6,#+1
    157          		num_buf = (num_buf % 10);
   \   00000158   0x0038             MOVS     R0,R7
   \   0000015A   0x210A             MOVS     R1,#+10
   \   0000015C   0x.... 0x....      BL       __aeabi_idivmod
   \   00000160   0x000F             MOVS     R7,R1
    158          		flag=1;
   \   00000162   0x2001             MOVS     R0,#+1
    159          	}
    160          	buffer[point++] = num_buf + '0';
   \                     ??itoa_local_17: (+1)
   \   00000164   0x3730             ADDS     R7,R7,#+48
   \   00000166   0x55AF             STRB     R7,[R5, R6]
   \   00000168   0x1C76             ADDS     R6,R6,#+1
    161          
    162          	*len = point;
   \   0000016A   0x9800             LDR      R0,[SP, #+0]
   \   0000016C   0x6006             STR      R6,[R0, #+0]
    163          
    164          	return 0;
   \   0000016E   0x2000             MOVS     R0,#+0
   \   00000170   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    165          }
    166          
    167          
    168          /********************************************************************/
    169          /*!
    170           * \name	atoi_local
    171           * \brief	文字列(正の値)を数字に変換する処理
    172           * \param	buffer      : 文字列
    173           *          len         : 文字数
    174           *          num         : 数字
    175           * \return  0
    176           * \note	
    177           */
    178          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    179          int32_t	atoi_local(uint8_t *buffer, int32_t len, int32_t *num)
    180          {
   \                     atoi_local: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
    181          	int32_t	i;
    182          	int32_t	val=0;
   \   00000002   0x2400             MOVS     R4,#+0
    183          	
    184          	for (i=0; i<len; i++) {
   \   00000004   0x2300             MOVS     R3,#+0
   \   00000006   0xE005             B        ??atoi_local_0
    185          		val *= 10;
   \                     ??atoi_local_1: (+1)
   \   00000008   0x250A             MOVS     R5,#+10
   \   0000000A   0x436C             MULS     R4,R5,R4
    186          		val += (buffer[i] - '0');
   \   0000000C   0x5CC5             LDRB     R5,[R0, R3]
   \   0000000E   0x3D30             SUBS     R5,R5,#+48
   \   00000010   0x1964             ADDS     R4,R4,R5
    187          	}
   \   00000012   0x1C5B             ADDS     R3,R3,#+1
   \                     ??atoi_local_0: (+1)
   \   00000014   0x428B             CMP      R3,R1
   \   00000016   0xDBF7             BLT      ??atoi_local_1
    188          
    189          	*num = val;
   \   00000018   0x6014             STR      R4,[R2, #+0]
    190          
    191          	return 0;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0xBD30             POP      {R4,R5,PC}       ;; return
    192          }
    193          
    194          
    195          
    196          /********************************************************************/
    197          /*!
    198           * \name	gm_time
    199           * \brief	協定世界時（UTC）へ変換
    200           * \param	clock       : JST時刻
    201           * \return  UTC時刻
    202           * \note	JST時間に-9時間を行う
    203           */
    204          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    205          clock_info_t *gm_time(clock_info_t *clock)
    206          {
   \                     gm_time: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0001             MOVS     R1,R0
    207          	uint8_t		leap=0;
   \   00000004   0x2400             MOVS     R4,#+0
    208          
    209          	utc = *clock;
   \   00000006   0x....             LDR      R0,??DataTable2_6
   \   00000008   0x2206             MOVS     R2,#+6
   \   0000000A   0x.... 0x....      BL       __aeabi_memcpy
    210          	if ( (utc.year % 4) == 0) leap=1;
   \   0000000E   0x....             LDR      R0,??DataTable2_6
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x5640             LDRSB    R0,[R0, R1]
   \   00000014   0x2104             MOVS     R1,#+4
   \   00000016   0x.... 0x....      BL       __aeabi_idivmod
   \   0000001A   0x2900             CMP      R1,#+0
   \   0000001C   0xD100             BNE      ??gm_time_0
   \   0000001E   0x2401             MOVS     R4,#+1
    211          
    212          	utc.hour -= UTC_CONV_JST;
   \                     ??gm_time_0: (+1)
   \   00000020   0x....             LDR      R0,??DataTable2_6
   \   00000022   0x78C0             LDRB     R0,[R0, #+3]
   \   00000024   0x3809             SUBS     R0,R0,#+9
   \   00000026   0x....             LDR      R1,??DataTable2_6
   \   00000028   0x70C8             STRB     R0,[R1, #+3]
    213          	if (utc.hour < 0) {
   \   0000002A   0x....             LDR      R0,??DataTable2_6
   \   0000002C   0x2103             MOVS     R1,#+3
   \   0000002E   0x5640             LDRSB    R0,[R0, R1]
   \   00000030   0x2800             CMP      R0,#+0
   \   00000032   0xD535             BPL      ??gm_time_1
    214          		utc.hour += 24;
   \   00000034   0x....             LDR      R0,??DataTable2_6
   \   00000036   0x78C0             LDRB     R0,[R0, #+3]
   \   00000038   0x3018             ADDS     R0,R0,#+24
   \   0000003A   0x....             LDR      R1,??DataTable2_6
   \   0000003C   0x70C8             STRB     R0,[R1, #+3]
    215          
    216          		utc.day--;
   \   0000003E   0x....             LDR      R0,??DataTable2_6
   \   00000040   0x7880             LDRB     R0,[R0, #+2]
   \   00000042   0x1E40             SUBS     R0,R0,#+1
   \   00000044   0x....             LDR      R1,??DataTable2_6
   \   00000046   0x7088             STRB     R0,[R1, #+2]
    217          		if (utc.day <= 0) {
   \   00000048   0x....             LDR      R0,??DataTable2_6
   \   0000004A   0x2102             MOVS     R1,#+2
   \   0000004C   0x5640             LDRSB    R0,[R0, R1]
   \   0000004E   0x2801             CMP      R0,#+1
   \   00000050   0xDA26             BGE      ??gm_time_1
    218          			utc.day = month_day_tbl[utc.month-1][leap];
   \   00000052   0x....             LDR      R0,??DataTable2_7
   \   00000054   0x....             LDR      R1,??DataTable2_6
   \   00000056   0x2201             MOVS     R2,#+1
   \   00000058   0x5689             LDRSB    R1,[R1, R2]
   \   0000005A   0x2202             MOVS     R2,#+2
   \   0000005C   0x4351             MULS     R1,R2,R1
   \   0000005E   0x1840             ADDS     R0,R0,R1
   \   00000060   0xB2E4             UXTB     R4,R4
   \   00000062   0x1900             ADDS     R0,R0,R4
   \   00000064   0x1E80             SUBS     R0,R0,#+2
   \   00000066   0x7800             LDRB     R0,[R0, #+0]
   \   00000068   0x....             LDR      R1,??DataTable2_6
   \   0000006A   0x7088             STRB     R0,[R1, #+2]
    219          			utc.month--;
   \   0000006C   0x....             LDR      R0,??DataTable2_6
   \   0000006E   0x7840             LDRB     R0,[R0, #+1]
   \   00000070   0x1E40             SUBS     R0,R0,#+1
   \   00000072   0x....             LDR      R1,??DataTable2_6
   \   00000074   0x7048             STRB     R0,[R1, #+1]
    220          			if (utc.month <= 0) {
   \   00000076   0x....             LDR      R0,??DataTable2_6
   \   00000078   0x2101             MOVS     R1,#+1
   \   0000007A   0x5640             LDRSB    R0,[R0, R1]
   \   0000007C   0x2801             CMP      R0,#+1
   \   0000007E   0xDA0F             BGE      ??gm_time_1
    221          				utc.month = 12;
   \   00000080   0x200C             MOVS     R0,#+12
   \   00000082   0x....             LDR      R1,??DataTable2_6
   \   00000084   0x7048             STRB     R0,[R1, #+1]
    222          				utc.year--;
   \   00000086   0x....             LDR      R0,??DataTable2_6
   \   00000088   0x7800             LDRB     R0,[R0, #+0]
   \   0000008A   0x1E40             SUBS     R0,R0,#+1
   \   0000008C   0x....             LDR      R1,??DataTable2_6
   \   0000008E   0x7008             STRB     R0,[R1, #+0]
    223          				if (utc.year < 0) {
   \   00000090   0x....             LDR      R0,??DataTable2_6
   \   00000092   0x2100             MOVS     R1,#+0
   \   00000094   0x5640             LDRSB    R0,[R0, R1]
   \   00000096   0x2800             CMP      R0,#+0
   \   00000098   0xD502             BPL      ??gm_time_1
    224          					utc.year = 99;
   \   0000009A   0x2063             MOVS     R0,#+99
   \   0000009C   0x....             LDR      R1,??DataTable2_6
   \   0000009E   0x7008             STRB     R0,[R1, #+0]
    225          				}
    226          			}
    227          		}
    228          	}
    229          	
    230          	return &utc;
   \                     ??gm_time_1: (+1)
   \   000000A0   0x....             LDR      R0,??DataTable2_6
   \   000000A2   0xBD10             POP      {R4,PC}          ;; return
    231          }
    232          
    233          
    234          /********************************************************************/
    235          /*!
    236           * \name	local_time
    237           * \brief	ローカル標準時(JST)へ変換
    238           * \param	clock       : UTC時刻
    239           * \return  JST時刻
    240           * \note	UTC時間に+9時間を行う
    241           */
    242          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    243          clock_info_t *local_time(clock_info_t *clock)
    244          {
   \                     local_time: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0001             MOVS     R1,R0
    245          	uint8_t		leap=0;
   \   00000004   0x2400             MOVS     R4,#+0
    246          
    247          	jst = *clock;
   \   00000006   0x....             LDR      R0,??DataTable2_8
   \   00000008   0x2206             MOVS     R2,#+6
   \   0000000A   0x.... 0x....      BL       __aeabi_memcpy
    248          	if ( (jst.year % 4) == 0) leap=1;
   \   0000000E   0x....             LDR      R0,??DataTable2_8
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x5640             LDRSB    R0,[R0, R1]
   \   00000014   0x2104             MOVS     R1,#+4
   \   00000016   0x.... 0x....      BL       __aeabi_idivmod
   \   0000001A   0x2900             CMP      R1,#+0
   \   0000001C   0xD100             BNE      ??local_time_0
   \   0000001E   0x2401             MOVS     R4,#+1
    249          
    250          	jst.hour += UTC_CONV_JST;
   \                     ??local_time_0: (+1)
   \   00000020   0x....             LDR      R0,??DataTable2_8
   \   00000022   0x78C0             LDRB     R0,[R0, #+3]
   \   00000024   0x3009             ADDS     R0,R0,#+9
   \   00000026   0x....             LDR      R1,??DataTable2_8
   \   00000028   0x70C8             STRB     R0,[R1, #+3]
    251          	if (jst.hour > 23) {
   \   0000002A   0x....             LDR      R0,??DataTable2_8
   \   0000002C   0x2103             MOVS     R1,#+3
   \   0000002E   0x5640             LDRSB    R0,[R0, R1]
   \   00000030   0x2818             CMP      R0,#+24
   \   00000032   0xDB36             BLT      ??local_time_1
    252          		jst.hour -= 24;
   \   00000034   0x....             LDR      R0,??DataTable2_8
   \   00000036   0x78C0             LDRB     R0,[R0, #+3]
   \   00000038   0x3818             SUBS     R0,R0,#+24
   \   0000003A   0x....             LDR      R1,??DataTable2_8
   \   0000003C   0x70C8             STRB     R0,[R1, #+3]
    253          		jst.day++;
   \   0000003E   0x....             LDR      R0,??DataTable2_8
   \   00000040   0x7880             LDRB     R0,[R0, #+2]
   \   00000042   0x1C40             ADDS     R0,R0,#+1
   \   00000044   0x....             LDR      R1,??DataTable2_8
   \   00000046   0x7088             STRB     R0,[R1, #+2]
    254          		if (month_day_tbl[jst.month][leap] < jst.day) {
   \   00000048   0x....             LDR      R0,??DataTable2_7
   \   0000004A   0x....             LDR      R1,??DataTable2_8
   \   0000004C   0x2201             MOVS     R2,#+1
   \   0000004E   0x5689             LDRSB    R1,[R1, R2]
   \   00000050   0x2202             MOVS     R2,#+2
   \   00000052   0x4351             MULS     R1,R2,R1
   \   00000054   0x1840             ADDS     R0,R0,R1
   \   00000056   0xB2E4             UXTB     R4,R4
   \   00000058   0x5D00             LDRB     R0,[R0, R4]
   \   0000005A   0x....             LDR      R1,??DataTable2_8
   \   0000005C   0x2202             MOVS     R2,#+2
   \   0000005E   0x5689             LDRSB    R1,[R1, R2]
   \   00000060   0xB200             SXTH     R0,R0
   \   00000062   0xB209             SXTH     R1,R1
   \   00000064   0x4288             CMP      R0,R1
   \   00000066   0xDA1C             BGE      ??local_time_1
    255          			jst.day = 1;
   \   00000068   0x2001             MOVS     R0,#+1
   \   0000006A   0x....             LDR      R1,??DataTable2_8
   \   0000006C   0x7088             STRB     R0,[R1, #+2]
    256          			jst.month++;
   \   0000006E   0x....             LDR      R0,??DataTable2_8
   \   00000070   0x7840             LDRB     R0,[R0, #+1]
   \   00000072   0x1C40             ADDS     R0,R0,#+1
   \   00000074   0x....             LDR      R1,??DataTable2_8
   \   00000076   0x7048             STRB     R0,[R1, #+1]
    257          			if (jst.month > 12) {
   \   00000078   0x....             LDR      R0,??DataTable2_8
   \   0000007A   0x2101             MOVS     R1,#+1
   \   0000007C   0x5640             LDRSB    R0,[R0, R1]
   \   0000007E   0x280D             CMP      R0,#+13
   \   00000080   0xDB0F             BLT      ??local_time_1
    258          				jst.month = 1;
   \   00000082   0x2001             MOVS     R0,#+1
   \   00000084   0x....             LDR      R1,??DataTable2_8
   \   00000086   0x7048             STRB     R0,[R1, #+1]
    259          				jst.year++;
   \   00000088   0x....             LDR      R0,??DataTable2_8
   \   0000008A   0x7800             LDRB     R0,[R0, #+0]
   \   0000008C   0x1C40             ADDS     R0,R0,#+1
   \   0000008E   0x....             LDR      R1,??DataTable2_8
   \   00000090   0x7008             STRB     R0,[R1, #+0]
    260          				if (jst.year >= 100) {
   \   00000092   0x....             LDR      R0,??DataTable2_8
   \   00000094   0x2100             MOVS     R1,#+0
   \   00000096   0x5640             LDRSB    R0,[R0, R1]
   \   00000098   0x2864             CMP      R0,#+100
   \   0000009A   0xDB02             BLT      ??local_time_1
    261          					jst.year = 0;
   \   0000009C   0x2000             MOVS     R0,#+0
   \   0000009E   0x....             LDR      R1,??DataTable2_8
   \   000000A0   0x7008             STRB     R0,[R1, #+0]
    262          				}
    263          			}
    264          		}
    265          	}
    266          	
    267          	return &jst;
   \                     ??local_time_1: (+1)
   \   000000A2   0x....             LDR      R0,??DataTable2_8
   \   000000A4   0xBD10             POP      {R4,PC}          ;; return
    268          }
    269          
    270          
    271          
    272          /********************************************************************/
    273          /*!
    274           * \name	local_atoi
    275           * \brief	文字列で表現された数値をint32_t型の数値に変換する
    276           * \param	str       : 文字列で表現された数値
    277           *          length    : 文字数
    278           * \return  int32_t型に変換した数値
    279           * \note	変換不能文字は-1を返す。
    280           *          負の値はサポートしない
    281           */
    282          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    283          int32_t local_atoi(uint8_t *str, int32_t length)
    284          {
   \                     local_atoi: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0002             MOVS     R2,R0
    285          	int32_t		num=0;
   \   00000004   0x2000             MOVS     R0,#+0
    286          	int32_t		loop;
    287          
    288          	if (length != 0) {
   \   00000006   0x2900             CMP      R1,#+0
   \   00000008   0xD010             BEQ      ??local_atoi_0
    289          		for(loop=0; loop<length; loop++) {
   \   0000000A   0x2300             MOVS     R3,#+0
   \   0000000C   0xE005             B        ??local_atoi_1
    290          			if ( ('0' <= str[loop]) && (str[loop] <= '9') ) {
    291          				num *= 10;
   \                     ??local_atoi_2: (+1)
   \   0000000E   0x240A             MOVS     R4,#+10
   \   00000010   0x4360             MULS     R0,R4,R0
    292          				num += str[loop] - '0';
   \   00000012   0x5CD4             LDRB     R4,[R2, R3]
   \   00000014   0x3C30             SUBS     R4,R4,#+48
   \   00000016   0x1900             ADDS     R0,R0,R4
    293          			}
   \   00000018   0x1C5B             ADDS     R3,R3,#+1
   \                     ??local_atoi_1: (+1)
   \   0000001A   0x428B             CMP      R3,R1
   \   0000001C   0xDA08             BGE      ??local_atoi_3
   \   0000001E   0x5CD4             LDRB     R4,[R2, R3]
   \   00000020   0x3C30             SUBS     R4,R4,#+48
   \   00000022   0x2C0A             CMP      R4,#+10
   \   00000024   0xD3F3             BCC      ??local_atoi_2
    294          			else {
    295          				num = -1;
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0x43C0             MVNS     R0,R0            ;; #-1
    296          				break;
   \   0000002A   0xE001             B        ??local_atoi_3
    297          			}
    298          		}
    299          	}
    300          	else {
    301          		num = -1;
   \                     ??local_atoi_0: (+1)
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0x43C0             MVNS     R0,R0            ;; #-1
    302          	}
    303          	
    304          	return num;
   \                     ??local_atoi_3: (+1)
   \   00000030   0xBD10             POP      {R4,PC}          ;; return
    305          }
    306          
    307          /********************************************************************/
    308          /*!
    309           * \name	local_atoi16
    310           * \brief	文字列で表現された数値をint32_t型の数値(16進数）に変換する
    311           * \param	str       : 文字列で表現された数値
    312           *          length    : 文字数
    313           * \return  int32_t型に変換した数値
    314           * \note	変換不能文字は-1を返す。
    315           *          負の値はサポートしない
    316           */
    317          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    318          uint32_t local_atou16(uint8_t *str, uint32_t length)
    319          {
   \                     local_atou16: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0002             MOVS     R2,R0
    320          	uint32_t		num=0;
   \   00000004   0x2000             MOVS     R0,#+0
    321          	uint32_t		loop;
    322          
    323          	if (length != 0) {
   \   00000006   0x2900             CMP      R1,#+0
   \   00000008   0xD01A             BEQ      ??local_atou16_0
    324          		for(loop=0; loop<length; loop++) {
   \   0000000A   0x2300             MOVS     R3,#+0
   \   0000000C   0xE005             B        ??local_atou16_1
    325          			if ( ('0' <= str[loop]) && (str[loop] <= '9'))
    326                                  {
    327          				num *= 16;
   \                     ??local_atou16_2: (+1)
   \   0000000E   0x2410             MOVS     R4,#+16
   \   00000010   0x4360             MULS     R0,R4,R0
    328          				num += str[loop] - '0';
   \   00000012   0x5CD4             LDRB     R4,[R2, R3]
   \   00000014   0x3C30             SUBS     R4,R4,#+48
   \   00000016   0x1900             ADDS     R0,R0,R4
    329                                  }  
   \                     ??local_atou16_3: (+1)
   \   00000018   0x1C5B             ADDS     R3,R3,#+1
   \                     ??local_atou16_1: (+1)
   \   0000001A   0x428B             CMP      R3,R1
   \   0000001C   0xD212             BCS      ??local_atou16_4
   \   0000001E   0x5CD4             LDRB     R4,[R2, R3]
   \   00000020   0x3C30             SUBS     R4,R4,#+48
   \   00000022   0x2C0A             CMP      R4,#+10
   \   00000024   0xD3F3             BCC      ??local_atou16_2
    330                                  else if(('a' <= str[loop]) && (str[loop] <= 'f') )
   \   00000026   0x5CD4             LDRB     R4,[R2, R3]
   \   00000028   0x3C61             SUBS     R4,R4,#+97
   \   0000002A   0x2C06             CMP      R4,#+6
   \   0000002C   0xD205             BCS      ??local_atou16_5
    331                                  {
    332          				num *= 16;
   \   0000002E   0x2410             MOVS     R4,#+16
   \   00000030   0x4360             MULS     R0,R4,R0
    333          				num += str[loop] -'a'+ 10;
   \   00000032   0x5CD4             LDRB     R4,[R2, R3]
   \   00000034   0x3C57             SUBS     R4,R4,#+87
   \   00000036   0x1900             ADDS     R0,R0,R4
   \   00000038   0xE7EE             B        ??local_atou16_3
    334          			}
    335          			else {
    336          				num = -1;
   \                     ??local_atou16_5: (+1)
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0x43C0             MVNS     R0,R0            ;; #-1
    337          				break;
   \   0000003E   0xE001             B        ??local_atou16_4
    338          			}
    339          		}
    340          	}
    341          	else {
    342          		num = -1;
   \                     ??local_atou16_0: (+1)
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0x43C0             MVNS     R0,R0            ;; #-1
    343          	}
    344          	
    345          	return num;
   \                     ??local_atou16_4: (+1)
   \   00000044   0xBD10             POP      {R4,PC}          ;; return
    346          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2:
   \   00000000   0x3B9ACA00         DC32     0x3b9aca00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_1:
   \   00000000   0x05F5E100         DC32     0x5f5e100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_2:
   \   00000000   0x00989680         DC32     0x989680

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_3:
   \   00000000   0x000F4240         DC32     0xf4240

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_4:
   \   00000000   0x000186A0         DC32     0x186a0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_5:
   \   00000000   0x00002710         DC32     0x2710

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_6:
   \   00000000   0x........         DC32     utc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_7:
   \   00000000   0x........         DC32     month_day_tbl

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_8:
   \   00000000   0x........         DC32     jst
    347          
    348          
    349          
    350          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      12   atoi_local
       0   bcd_to_num
       8   gm_time
         8   -> __aeabi_memcpy
         8 __aeabi_idivmod
      24   itoa_local
        24 __aeabi_idiv
        24 __aeabi_idivmod
       8   local_atoi
       8   local_atou16
       8   local_time
         8   -> __aeabi_memcpy
         8 __aeabi_idivmod
      12   num_to_bcd
        12 __aeabi_idiv
        12 __aeabi_idivmod


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable2
       4  ??DataTable2_1
       4  ??DataTable2_2
       4  ??DataTable2_3
       4  ??DataTable2_4
       4  ??DataTable2_5
       4  ??DataTable2_6
       4  ??DataTable2_7
       4  ??DataTable2_8
      30  atoi_local
      26  bcd_to_num
     164  gm_time
     370  itoa_local
       8  jst
      50  local_atoi
      70  local_atou16
     166  local_time
      28  month_day_tbl
      42  num_to_bcd
       8  utc

 
  16 bytes in section .bss
  28 bytes in section .rodata
 954 bytes in section .text
 
 954 bytes of CODE  memory
  28 bytes of CONST memory
  16 bytes of DATA  memory

Errors: none
Warnings: none
