###############################################################################
#
# IAR ANSI C/C++ Compiler V7.80.4.12462/W32 for ARM       21/May/2019  17:01:22
# Copyright 1999-2017 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  C:\GNSS\Software\rJ105\source\GNSS_GW\apl\man_flash.c
#    Command line =  
#        C:\GNSS\Software\rJ105\source\GNSS_GW\apl\man_flash.c -D
#        __TARGET_ARCH_7_M -D S1C31W74 -D GNSS_GW_SIDE_B -lCN
#        C:\GNSS\Software\rJ105\source\GNSS_GW\board\S5U1C31W74T1\IAR\DebugFlashBside\List
#        -lA
#        C:\GNSS\Software\rJ105\source\GNSS_GW\board\S5U1C31W74T1\IAR\DebugFlashBside\List
#        --diag_suppress Pe177,Pe111,Pa082 -o
#        C:\GNSS\Software\rJ105\source\GNSS_GW\board\S5U1C31W74T1\IAR\DebugFlashBside\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M0+ -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.5\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\GNSS\Software\rJ105\source\GNSS_GW\board\S5U1C31W74T1\IAR\ -I
#        C:\GNSS\Software\rJ105\source\GNSS_GW\board\S5U1C31W74T1\IAR\..\..\..\
#        -I "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.5\arm\CMSIS\Include\" -I "C:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 7.5\arm\inc\Epson\" -I
#        C:\GNSS\Software\rJ105\source\GNSS_GW\board\S5U1C31W74T1\IAR\..\..\..\..\..\CMSIS\Device\S1C31W74\Include\
#        -I
#        C:\GNSS\Software\rJ105\source\GNSS_GW\board\S5U1C31W74T1\IAR\..\..\..\..\..\CMSIS\Driver\Include\
#        -I
#        C:\GNSS\Software\rJ105\source\GNSS_GW\board\S5U1C31W74T1\IAR\..\..\..\..\..\sePeriphLibrary\
#        -I
#        C:\GNSS\Software\rJ105\source\GNSS_GW\board\S5U1C31W74T1\IAR\..\..\..\..\..\board\S5U1C31W74T1\
#        -I
#        C:\GNSS\Software\rJ105\source\GNSS_GW\board\S5U1C31W74T1\IAR\..\..\..\..\..\USBStack\INC\
#        -I
#        C:\GNSS\Software\rJ105\source\GNSS_GW\board\S5U1C31W74T1\IAR\..\..\..\include\
#        -Ol
#    Locale       =  Japanese_Japan.932
#    List file    =  
#        C:\GNSS\Software\rJ105\source\GNSS_GW\board\S5U1C31W74T1\IAR\DebugFlashBside\List\man_flash.lst
#    Object file  =  
#        C:\GNSS\Software\rJ105\source\GNSS_GW\board\S5U1C31W74T1\IAR\DebugFlashBside\Obj\man_flash.o
#
###############################################################################

C:\GNSS\Software\rJ105\source\GNSS_GW\apl\man_flash.c
      1          
      2          /**
      3            ******************************************************************************
      4            * @file    man_flash.c
      5            * @author  コア
      6            * @version V1.0
      7            * @date    2018.3.19
      8            * @brief   外部FLASHを管理する
      9            ******************************************************************************
     10            * @attention
     11            *
     12            *****************************************************************************
     13          */
     14          
     15          #include <string.h>
     16          #include <stdio.h>
     17          #include <stdlib.h>
     18          
     19          #include "board.h"
     20          #include "man_flash.h"
     21          #include "man_memory.h"
     22          #include "man_timer.h"
     23          
     24          #include "gnss_gw_common.h"
     25          #include "ctrl_W25Q.h"
     26          #include "se_spia.h"
     27          #include "man_usb.h"
     28          
     29          
     30          #pragma section = "APL_PRG_BLOCK"
     31          
     32          
     33          
     34          // 要求
     35          #define	MAN_FLASH_REQ_CMD_NON			0		// 要求待ち
     36          #define	MAN_FLASH_REQ_CMD_ERASE_ALL		1		// ERASE ALL
     37          #define	MAN_FLASH_REQ_CMD_ERASE_BLOCK	2		// ERASE BLOCK(64kB)
     38          
     39          // FLASH管理シーケンス
     40          typedef enum {
     41          	MAN_FLASH_SEQ_READY,					// 00 : 要求待ち
     42          
     43          	MAN_FLASH_SEQ_ERASE_ALL_REQ,			// 01 : erase all要求
     44          	MAN_FLASH_SEQ_ERASE_ALL_WAIT,			// 02 : erase all完了待ち
     45          	MAN_FLASH_SEQ_ERASE_BLOCK_REQ,			// 03 : erase block初期化
     46          	MAN_FLASH_SEQ_ERASE_BLOCK_WAIT,			// 04 : erase block完了待ち
     47          } man_flash_seq_def;
     48          
     49          
     50          
     51          /************************************************************************/
     52          /* declaration of structure                                             */
     53          /************************************************************************/
     54          
     55          // 要求
     56          typedef struct _man_flash_req_info_t{
     57          	int32_t						req_cmd;
     58          	int32_t						addr;		// 先頭アドレス
     59          	int32_t						num;		// 
     60          	int32_t						id;
     61          	func_man_flash				callback;
     62          
     63          	int32_t						counter;
     64          } man_flash_req_info_t;
     65          
     66          
     67          // FLASH管理ワーク
     68          typedef struct _man_flash_work_t {
     69          	man_flash_seq_def			sequense;			// シーケンス
     70          	man_flash_req_info_t		request;			// 要求
     71          	uint32_t					start_time;
     72          } man_flash_work_t;
     73          
     74          
     75          /************************************************************************/
     76          /* definition of variables                                              */
     77          /************************************************************************/
     78          

   \                                 In section .bss, align 4
     79          man_flash_work_t			man_flash_work;
   \                     man_flash_work:
   \   00000000                      DS8 32
     80          
     81          
     82          /********************************************************************/
     83          /*	callback関数                                                    */
     84          /********************************************************************/
     85          
     86          /********************************************************************/
     87          /*	static関数                                                      */
     88          /********************************************************************/
     89          
     90          /********************************************************************/
     91          /*!
     92           * \name	man_flash_return_callback
     93           * \brief	callback応答を返す処理
     94           * \param	status : 通知するステータス
     95           * \return  なし
     96           * \note	
     97           */
     98          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
     99          static void man_flash_return_callback( int32_t status )
    100          {
   \                     man_flash_return_callback: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    101          	// callback関数で終了通知
    102          	if (man_flash_work.request.callback != NULL) {
   \   00000002   0x....             LDR      R1,??DataTable4
   \   00000004   0x6949             LDR      R1,[R1, #+20]
   \   00000006   0x2900             CMP      R1,#+0
   \   00000008   0xD008             BEQ      ??man_flash_return_callback_0
    103          		man_flash_work.request.callback(man_flash_work.request.id, status);
   \   0000000A   0x0001             MOVS     R1,R0
   \   0000000C   0x....             LDR      R0,??DataTable4
   \   0000000E   0x6900             LDR      R0,[R0, #+16]
   \   00000010   0x....             LDR      R2,??DataTable4
   \   00000012   0x6952             LDR      R2,[R2, #+20]
   \   00000014   0x4790             BLX      R2
    104          		man_flash_work.request.callback = NULL;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x....             LDR      R1,??DataTable4
   \   0000001A   0x6148             STR      R0,[R1, #+20]
    105          	}
    106          	man_flash_work.sequense = MAN_FLASH_SEQ_READY;
   \                     ??man_flash_return_callback_0: (+1)
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0x....             LDR      R1,??DataTable4
   \   00000020   0x7008             STRB     R0,[R1, #+0]
    107          	man_flash_work.request.req_cmd = MAN_FLASH_REQ_CMD_NON;
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0x....             LDR      R1,??DataTable4
   \   00000026   0x6048             STR      R0,[R1, #+4]
    108          }
   \   00000028   0xBD01             POP      {R0,PC}          ;; return
    109          
    110          
    111          /********************************************************************/
    112          /*!
    113           * \name	man_flash_init
    114           * \brief	FLASH管理の初期化処理(１回のみ実行)
    115           * \param	なし
    116           * \return  なし
    117           * \note	起動時に、呼ばれること
    118           */
    119          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    120          void man_flash_init(void)
    121          {
   \                     man_flash_init: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    122          	// GPIO初期化
    123          	ctrl_W25Q_init();
   \   00000002   0x.... 0x....      BL       ctrl_W25Q_init
    124          }
   \   00000006   0xBD01             POP      {R0,PC}          ;; return
    125          
    126          
    127          /********************************************************************/
    128          /*!
    129           * \name	man_flash_main
    130           * \brief	FLASHのメイン処理
    131           * \param	なし
    132           * \return  なし
    133           * \note	毎回、呼ばれること
    134           */
    135          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    136          void man_flash_main( void )
    137          {
   \                     man_flash_main: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    138          	int32_t		ret;
    139          	uint32_t	delay;
    140          
    141          
    142          	// ******************************
    143          	//    要求処理
    144          	// ******************************
    145          	switch (man_flash_work.request.req_cmd) {
   \   00000002   0x....             LDR      R0,??DataTable4
   \   00000004   0x6840             LDR      R0,[R0, #+4]
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD003             BEQ      ??man_flash_main_0
   \   0000000A   0x2802             CMP      R0,#+2
   \   0000000C   0xD00A             BEQ      ??man_flash_main_1
   \   0000000E   0xD301             BCC      ??man_flash_main_2
   \   00000010   0xE012             B        ??man_flash_main_3
    146          	case MAN_FLASH_REQ_CMD_NON:
    147          		break;
   \                     ??man_flash_main_0: (+1)
   \   00000012   0xE011             B        ??man_flash_main_3
    148          	case MAN_FLASH_REQ_CMD_ERASE_ALL:
    149          		if (man_flash_work.sequense == MAN_FLASH_SEQ_READY) {
   \                     ??man_flash_main_2: (+1)
   \   00000014   0x....             LDR      R0,??DataTable4
   \   00000016   0x7800             LDRB     R0,[R0, #+0]
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD102             BNE      ??man_flash_main_4
    150          			man_flash_work.sequense = MAN_FLASH_SEQ_ERASE_ALL_REQ;
   \   0000001C   0x2001             MOVS     R0,#+1
   \   0000001E   0x....             LDR      R1,??DataTable4
   \   00000020   0x7008             STRB     R0,[R1, #+0]
    151          		}
    152          		break;
   \                     ??man_flash_main_4: (+1)
   \   00000022   0xE009             B        ??man_flash_main_3
    153          	case MAN_FLASH_REQ_CMD_ERASE_BLOCK:
    154          		if (man_flash_work.sequense == MAN_FLASH_SEQ_READY) {
   \                     ??man_flash_main_1: (+1)
   \   00000024   0x....             LDR      R0,??DataTable4
   \   00000026   0x7800             LDRB     R0,[R0, #+0]
   \   00000028   0x2800             CMP      R0,#+0
   \   0000002A   0xD105             BNE      ??man_flash_main_5
    155          			man_flash_work.request.counter = 0;
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0x....             LDR      R1,??DataTable4
   \   00000030   0x6188             STR      R0,[R1, #+24]
    156          			man_flash_work.sequense = MAN_FLASH_SEQ_ERASE_BLOCK_REQ;
   \   00000032   0x2003             MOVS     R0,#+3
   \   00000034   0x....             LDR      R1,??DataTable4
   \   00000036   0x7008             STRB     R0,[R1, #+0]
    157          		}
    158          		break;
    159          	}
    160          
    161          
    162          	// ******************************
    163          	//    シーケンス処理
    164          	// ******************************
    165          	switch (man_flash_work.sequense) {
   \                     ??man_flash_main_5: (+1)
   \                     ??man_flash_main_3: (+1)
   \   00000038   0x....             LDR      R0,??DataTable4
   \   0000003A   0x7800             LDRB     R0,[R0, #+0]
   \   0000003C   0x2800             CMP      R0,#+0
   \   0000003E   0xD006             BEQ      ??man_flash_main_6
   \   00000040   0x2802             CMP      R0,#+2
   \   00000042   0xD01A             BEQ      ??man_flash_main_7
   \   00000044   0xD304             BCC      ??man_flash_main_8
   \   00000046   0x2804             CMP      R0,#+4
   \   00000048   0xD04B             BEQ      ??man_flash_main_9
   \   0000004A   0xD32D             BCC      ??man_flash_main_10
   \   0000004C   0xE06E             B        ??man_flash_main_11
    166          	case MAN_FLASH_SEQ_READY:
    167          		break;
   \                     ??man_flash_main_6: (+1)
   \   0000004E   0xE06D             B        ??man_flash_main_11
    168          	case MAN_FLASH_SEQ_ERASE_ALL_REQ:
    169          		ret = clrl_W25Q_WriteEnable();
   \                     ??man_flash_main_8: (+1)
   \   00000050   0x.... 0x....      BL       clrl_W25Q_WriteEnable
    170          		if (ret >= 0) {
   \   00000054   0x2800             CMP      R0,#+0
   \   00000056   0xD401             BMI      ??man_flash_main_12
    171          			ret = ctrl_W25Q_erase_all_req();
   \   00000058   0x.... 0x....      BL       ctrl_W25Q_erase_all_req
    172          		}
    173          		if (ret >= 0) {
   \                     ??man_flash_main_12: (+1)
   \   0000005C   0x2800             CMP      R0,#+0
   \   0000005E   0xD407             BMI      ??man_flash_main_13
    174          			man_flash_work.sequense = MAN_FLASH_SEQ_ERASE_ALL_WAIT;
   \   00000060   0x2002             MOVS     R0,#+2
   \   00000062   0x....             LDR      R1,??DataTable4
   \   00000064   0x7008             STRB     R0,[R1, #+0]
    175          			man_flash_work.start_time = man_timer_get_1ms_count();
   \   00000066   0x.... 0x....      BL       man_timer_get_1ms_count
   \   0000006A   0x....             LDR      R1,??DataTable4
   \   0000006C   0x61C8             STR      R0,[R1, #+28]
   \   0000006E   0xE003             B        ??man_flash_main_14
    176          		}
    177          		else {
    178          			// 失敗を通知する
    179          			man_flash_return_callback(MAN_FLASH_STATUS_NG);
   \                     ??man_flash_main_13: (+1)
   \   00000070   0x2000             MOVS     R0,#+0
   \   00000072   0x43C0             MVNS     R0,R0            ;; #-1
   \   00000074   0x.... 0x....      BL       man_flash_return_callback
    180          		}
    181          		break;
   \                     ??man_flash_main_14: (+1)
   \   00000078   0xE058             B        ??man_flash_main_11
    182          	case MAN_FLASH_SEQ_ERASE_ALL_WAIT:
    183          		// ERASE完了チェック
    184          		if (ctrl_W25Q_IsBusy() != 0) {
   \                     ??man_flash_main_7: (+1)
   \   0000007A   0x.... 0x....      BL       ctrl_W25Q_IsBusy
   \   0000007E   0x2800             CMP      R0,#+0
   \   00000080   0xD003             BEQ      ??man_flash_main_15
    185          			// 完了を通知する
    186          			man_flash_return_callback(MAN_FLASH_STATUS_OK);
   \   00000082   0x2000             MOVS     R0,#+0
   \   00000084   0x.... 0x....      BL       man_flash_return_callback
   \   00000088   0xE00D             B        ??man_flash_main_16
    187          		}
    188          		else {
    189          			// 60秒経過しても完了しない場合は異常とする
    190          			delay = man_timer_get_elapsed_time(man_flash_work.start_time, man_timer_get_1ms_count());
   \                     ??man_flash_main_15: (+1)
   \   0000008A   0x.... 0x....      BL       man_timer_get_1ms_count
   \   0000008E   0x0001             MOVS     R1,R0
   \   00000090   0x....             LDR      R0,??DataTable4
   \   00000092   0x69C0             LDR      R0,[R0, #+28]
   \   00000094   0x.... 0x....      BL       man_timer_get_elapsed_time
    191          			if (delay > 60*1000) {
   \   00000098   0x....             LDR      R1,??DataTable4_1  ;; 0xea61
   \   0000009A   0x4288             CMP      R0,R1
   \   0000009C   0xD303             BCC      ??man_flash_main_16
    192          				// 失敗を通知する
    193          				man_flash_return_callback(MAN_FLASH_STATUS_NG);
   \   0000009E   0x2000             MOVS     R0,#+0
   \   000000A0   0x43C0             MVNS     R0,R0            ;; #-1
   \   000000A2   0x.... 0x....      BL       man_flash_return_callback
    194          			}
    195          		}
    196          		break;
   \                     ??man_flash_main_16: (+1)
   \   000000A6   0xE041             B        ??man_flash_main_11
    197          		
    198          	case MAN_FLASH_SEQ_ERASE_BLOCK_REQ:
    199          		// 書込み許可コマンド送信
    200          		ret = clrl_W25Q_WriteEnable();
   \                     ??man_flash_main_10: (+1)
   \   000000A8   0x.... 0x....      BL       clrl_W25Q_WriteEnable
    201          		if (ret >= 0) {
   \   000000AC   0x2800             CMP      R0,#+0
   \   000000AE   0xD409             BMI      ??man_flash_main_17
    202          			// 64kB block消去コマンド送信
    203          			ret = ctrl_W25Q_erase_64k_block_req(man_flash_work.request.addr + man_flash_work.request.counter * MAN_FLASH_BLOCK_SIZE);
   \   000000B0   0x....             LDR      R0,??DataTable4
   \   000000B2   0x6880             LDR      R0,[R0, #+8]
   \   000000B4   0x....             LDR      R1,??DataTable4
   \   000000B6   0x6989             LDR      R1,[R1, #+24]
   \   000000B8   0x2280             MOVS     R2,#+128
   \   000000BA   0x0252             LSLS     R2,R2,#+9        ;; #+65536
   \   000000BC   0x4351             MULS     R1,R2,R1
   \   000000BE   0x1840             ADDS     R0,R0,R1
   \   000000C0   0x.... 0x....      BL       ctrl_W25Q_erase_64k_block_req
    204          		}
    205          		if (ret >= 0) {
   \                     ??man_flash_main_17: (+1)
   \   000000C4   0x2800             CMP      R0,#+0
   \   000000C6   0xD407             BMI      ??man_flash_main_18
    206          			man_flash_work.sequense = MAN_FLASH_SEQ_ERASE_BLOCK_WAIT;
   \   000000C8   0x2004             MOVS     R0,#+4
   \   000000CA   0x....             LDR      R1,??DataTable4
   \   000000CC   0x7008             STRB     R0,[R1, #+0]
    207          			man_flash_work.start_time = man_timer_get_1ms_count();
   \   000000CE   0x.... 0x....      BL       man_timer_get_1ms_count
   \   000000D2   0x....             LDR      R1,??DataTable4
   \   000000D4   0x61C8             STR      R0,[R1, #+28]
   \   000000D6   0xE003             B        ??man_flash_main_19
    208          		}
    209          		else {
    210          			// 失敗を通知する
    211          			man_flash_return_callback(MAN_FLASH_STATUS_NG);
   \                     ??man_flash_main_18: (+1)
   \   000000D8   0x2000             MOVS     R0,#+0
   \   000000DA   0x43C0             MVNS     R0,R0            ;; #-1
   \   000000DC   0x.... 0x....      BL       man_flash_return_callback
    212          		}
    213          		break;
   \                     ??man_flash_main_19: (+1)
   \   000000E0   0xE024             B        ??man_flash_main_11
    214          
    215          	case MAN_FLASH_SEQ_ERASE_BLOCK_WAIT:
    216          		// ERASE完了チェック
    217          		if (ctrl_W25Q_IsBusy() != 0) {
   \                     ??man_flash_main_9: (+1)
   \   000000E2   0x.... 0x....      BL       ctrl_W25Q_IsBusy
   \   000000E6   0x2800             CMP      R0,#+0
   \   000000E8   0xD012             BEQ      ??man_flash_main_20
    218          			man_flash_work.request.counter++;
   \   000000EA   0x....             LDR      R0,??DataTable4
   \   000000EC   0x6980             LDR      R0,[R0, #+24]
   \   000000EE   0x1C40             ADDS     R0,R0,#+1
   \   000000F0   0x....             LDR      R1,??DataTable4
   \   000000F2   0x6188             STR      R0,[R1, #+24]
    219          			if (man_flash_work.request.num <= man_flash_work.request.counter) {
   \   000000F4   0x....             LDR      R0,??DataTable4
   \   000000F6   0x6980             LDR      R0,[R0, #+24]
   \   000000F8   0x....             LDR      R1,??DataTable4
   \   000000FA   0x68C9             LDR      R1,[R1, #+12]
   \   000000FC   0x4288             CMP      R0,R1
   \   000000FE   0xDB03             BLT      ??man_flash_main_21
    220          				// 完了を通知する
    221          				man_flash_return_callback(MAN_FLASH_STATUS_OK);
   \   00000100   0x2000             MOVS     R0,#+0
   \   00000102   0x.... 0x....      BL       man_flash_return_callback
   \   00000106   0xE011             B        ??man_flash_main_22
    222          			}
    223          			else {
    224          				// 次のBLOCKの消去を開始する
    225          				man_flash_work.sequense = MAN_FLASH_SEQ_ERASE_BLOCK_REQ;
   \                     ??man_flash_main_21: (+1)
   \   00000108   0x2003             MOVS     R0,#+3
   \   0000010A   0x....             LDR      R1,??DataTable4
   \   0000010C   0x7008             STRB     R0,[R1, #+0]
   \   0000010E   0xE00D             B        ??man_flash_main_22
    226          			}
    227          		}
    228          		else {
    229          			// 60秒経過しても完了しない場合は異常とする
    230          			delay = man_timer_get_elapsed_time(man_flash_work.start_time, man_timer_get_1ms_count());
   \                     ??man_flash_main_20: (+1)
   \   00000110   0x.... 0x....      BL       man_timer_get_1ms_count
   \   00000114   0x0001             MOVS     R1,R0
   \   00000116   0x....             LDR      R0,??DataTable4
   \   00000118   0x69C0             LDR      R0,[R0, #+28]
   \   0000011A   0x.... 0x....      BL       man_timer_get_elapsed_time
    231          			if (delay > 60*1000) {
   \   0000011E   0x....             LDR      R1,??DataTable4_1  ;; 0xea61
   \   00000120   0x4288             CMP      R0,R1
   \   00000122   0xD303             BCC      ??man_flash_main_22
    232          				// 失敗を通知する
    233          				man_flash_return_callback(MAN_FLASH_STATUS_NG);
   \   00000124   0x2000             MOVS     R0,#+0
   \   00000126   0x43C0             MVNS     R0,R0            ;; #-1
   \   00000128   0x.... 0x....      BL       man_flash_return_callback
    234          			}
    235          		}
    236          	}
    237          
    238          }
   \                     ??man_flash_main_22: (+1)
   \                     ??man_flash_main_11: (+1)
   \   0000012C   0xBD01             POP      {R0,PC}          ;; return
    239          
    240          
    241          
    242          /********************************************************************/
    243          /*!
    244           * \name	man_flash_erase_all
    245           * \brief	FLASH管理の全消去処理
    246           * \param	id       : ユニーク番号
    247           *          callback : 完了を通知するcallback関数
    248           * \return   0: 成功
    249           *          -1:失敗
    250           * \note	各ファイル書き込み時に、呼ばれる
    251           */
    252          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    253          int32_t  man_flash_erase_all(int32_t id, func_man_flash callback)
    254          {
   \                     man_flash_erase_all: (+1)
   \   00000000   0xB410             PUSH     {R4}
   \   00000002   0x0002             MOVS     R2,R0
    255          	int32_t	ret=0;
   \   00000004   0x2000             MOVS     R0,#+0
    256          
    257          
    258          	// 要求を保存する
    259          	man_flash_work.request.req_cmd = MAN_FLASH_REQ_CMD_ERASE_ALL;
   \   00000006   0x2301             MOVS     R3,#+1
   \   00000008   0x....             LDR      R4,??DataTable4
   \   0000000A   0x6063             STR      R3,[R4, #+4]
    260          	man_flash_work.request.id = id;
   \   0000000C   0x....             LDR      R3,??DataTable4
   \   0000000E   0x611A             STR      R2,[R3, #+16]
    261          	man_flash_work.request.callback = callback;
   \   00000010   0x....             LDR      R2,??DataTable4
   \   00000012   0x6151             STR      R1,[R2, #+20]
    262          
    263          	return ret;
   \   00000014   0xBC10             POP      {R4}
   \   00000016   0x4770             BX       LR               ;; return
    264          }
    265          
    266          
    267          /********************************************************************/
    268          /*!
    269           * \name	man_flash_erase_block
    270           * \brief	FLASHのBLOCK(64kB)消去処理
    271           * \param	addr     : 消去する先頭アドレス
    272           *          num      : 消去するBLOCK数
    273           *          id       : ユニーク番号
    274           *          callback : 完了を通知するcallback関数
    275           * \return   0: 成功
    276           *          -1:失敗
    277           * \note	
    278           */
    279          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    280          int32_t  man_flash_erase_block(int32_t addr, int32_t num, int32_t id, func_man_flash callback)
    281          {
   \                     man_flash_erase_block: (+1)
   \   00000000   0xB5F4             PUSH     {R2,R4-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x001E             MOVS     R6,R3
    282          	int32_t	ret=-1;
   \   00000008   0x2700             MOVS     R7,#+0
   \   0000000A   0x43FF             MVNS     R7,R7            ;; #-1
    283          
    284          	// BLOCKの先頭アドレス && BLOCK数を指定
    285          	if ( ((addr % MAN_FLASH_BLOCK_SIZE) == 0) && (num >= 1) ) {
   \   0000000C   0x0020             MOVS     R0,R4
   \   0000000E   0x2180             MOVS     R1,#+128
   \   00000010   0x0249             LSLS     R1,R1,#+9        ;; #+65536
   \   00000012   0x.... 0x....      BL       __aeabi_idivmod
   \   00000016   0x2900             CMP      R1,#+0
   \   00000018   0xD10E             BNE      ??man_flash_erase_block_0
   \   0000001A   0x2D01             CMP      R5,#+1
   \   0000001C   0xDB0C             BLT      ??man_flash_erase_block_0
    286          		// 要求を保存する
    287          		man_flash_work.request.req_cmd = MAN_FLASH_REQ_CMD_ERASE_BLOCK;
   \   0000001E   0x2002             MOVS     R0,#+2
   \   00000020   0x....             LDR      R1,??DataTable4
   \   00000022   0x6048             STR      R0,[R1, #+4]
    288          		man_flash_work.request.addr = addr;
   \   00000024   0x....             LDR      R0,??DataTable4
   \   00000026   0x6084             STR      R4,[R0, #+8]
    289          		man_flash_work.request.num = num;
   \   00000028   0x....             LDR      R0,??DataTable4
   \   0000002A   0x60C5             STR      R5,[R0, #+12]
    290          		man_flash_work.request.id = id;
   \   0000002C   0x9800             LDR      R0,[SP, #+0]
   \   0000002E   0x....             LDR      R1,??DataTable4
   \   00000030   0x6108             STR      R0,[R1, #+16]
    291          		man_flash_work.request.callback = callback;
   \   00000032   0x....             LDR      R0,??DataTable4
   \   00000034   0x6146             STR      R6,[R0, #+20]
    292          		ret = 0;
   \   00000036   0x2700             MOVS     R7,#+0
    293          	}
    294          
    295          	return ret;
   \                     ??man_flash_erase_block_0: (+1)
   \   00000038   0x0038             MOVS     R0,R7
   \   0000003A   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    296          }
    297          
    298          
    299          /********************************************************************/
    300          /*!
    301           * \name	man_flash_erase_page
    302           * \brief	FLASHのPAGE(128B)消去処理
    303           * \param	addr     : 消去する先頭アドレス
    304           * \return   0: 成功
    305           *          -1:失敗
    306           * \note	
    307           */
    308          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    309          int32_t  man_flash_erase_page(int32_t addr)
    310          {
   \                     man_flash_erase_page: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0006             MOVS     R6,R0
    311          	int32_t		ret=-1;
   \   00000004   0x2400             MOVS     R4,#+0
   \   00000006   0x43E4             MVNS     R4,R4            ;; #-1
    312          	uint32_t	Timer = 10000;		// 正常時は1300程度
   \   00000008   0x....             LDR      R5,??DataTable4_2  ;; 0x2710
    313          
    314          
    315          	// PAGEの先頭アドレスを指定
    316          	if ( (addr % MAN_FLASH_PAGE_SIZE) == 0 ) {
   \   0000000A   0x0030             MOVS     R0,R6
   \   0000000C   0x2180             MOVS     R1,#+128
   \   0000000E   0x0049             LSLS     R1,R1,#+1        ;; #+256
   \   00000010   0x.... 0x....      BL       __aeabi_idivmod
   \   00000014   0x2900             CMP      R1,#+0
   \   00000016   0xD113             BNE      ??man_flash_erase_page_0
    317          
    318          		// 書込み許可コマンド送信
    319          		ret = clrl_W25Q_WriteEnable();
   \   00000018   0x.... 0x....      BL       clrl_W25Q_WriteEnable
   \   0000001C   0x0004             MOVS     R4,R0
    320          		if (ret >= 0) {
   \   0000001E   0x2C00             CMP      R4,#+0
   \   00000020   0xD403             BMI      ??man_flash_erase_page_1
    321          			// sector消去コマンド送信
    322          			ret = ctrl_W25Q_erase_sector_req(addr);
   \   00000022   0x0030             MOVS     R0,R6
   \   00000024   0x.... 0x....      BL       ctrl_W25Q_erase_sector_req
   \   00000028   0x0004             MOVS     R4,R0
    323          		}
    324          
    325          		if (ret >= 0) {
   \                     ??man_flash_erase_page_1: (+1)
   \   0000002A   0x2C00             CMP      R4,#+0
   \   0000002C   0xD408             BMI      ??man_flash_erase_page_0
    326          			// 完了待ち
    327          			while (ctrl_W25Q_IsBusy() == 0) {
   \                     ??man_flash_erase_page_2: (+1)
   \   0000002E   0x.... 0x....      BL       ctrl_W25Q_IsBusy
   \   00000032   0x2800             CMP      R0,#+0
   \   00000034   0xD104             BNE      ??man_flash_erase_page_0
    328          				if (--Timer == 0) {
   \   00000036   0x1E6D             SUBS     R5,R5,#+1
   \   00000038   0x2D00             CMP      R5,#+0
   \   0000003A   0xD1F8             BNE      ??man_flash_erase_page_2
    329          					ret = -1;
   \   0000003C   0x2400             MOVS     R4,#+0
   \   0000003E   0x43E4             MVNS     R4,R4            ;; #-1
    330          					break;
    331          				}
    332          			}
    333          		}
    334          	}
    335          
    336          	return ret;
   \                     ??man_flash_erase_page_0: (+1)
   \   00000040   0x0020             MOVS     R0,R4
   \   00000042   0xBD70             POP      {R4-R6,PC}       ;; return
    337          }
    338          
    339          
    340          /********************************************************************/
    341          /*!
    342           * \name	man_flash_write_page
    343           * \brief	FLASH PAGE(256Byte)の書き込み処理
    344           * \param	addr   : flash 書き込みアドレス
    345           *          data   : flash 書き込みデータ
    346           *          length : データ長
    347           * \return  0: 成功  -1:失敗
    348           * \note	各ファイル書き込み時に、呼ばれる
    349           */
    350          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    351          int32_t  man_flash_write_page(uint32_t addr , uint8_t *data, int32_t length)
    352          {
   \                     man_flash_write_page: (+1)
   \   00000000   0xB5F1             PUSH     {R0,R4-R7,LR}
   \   00000002   0x000F             MOVS     R7,R1
   \   00000004   0x0016             MOVS     R6,R2
    353          	int32_t		ret=-1;
   \   00000006   0x2400             MOVS     R4,#+0
   \   00000008   0x43E4             MVNS     R4,R4            ;; #-1
    354          	int32_t		sts;
    355          	uint8_t		*flash_buff = man_memory_alloc();
   \   0000000A   0x.... 0x....      BL       man_memory_alloc
   \   0000000E   0x0005             MOVS     R5,R0
    356          
    357          	// 256バイトの書き込み
    358          	sts = ctrl_W25Q_write_page(addr, data, MAN_FLASH_PAGE_SIZE);
   \   00000010   0x2280             MOVS     R2,#+128
   \   00000012   0x0052             LSLS     R2,R2,#+1        ;; #+256
   \   00000014   0x0039             MOVS     R1,R7
   \   00000016   0x9800             LDR      R0,[SP, #+0]
   \   00000018   0x.... 0x....      BL       ctrl_W25Q_write_page
    359          	if (sts >= 0) {
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD40E             BMI      ??man_flash_write_page_0
    360          		// 256バイトの読み込み
    361          		sts = ctrl_W25Q_read(addr, flash_buff, length);
   \   00000020   0x0032             MOVS     R2,R6
   \   00000022   0x0029             MOVS     R1,R5
   \   00000024   0x9800             LDR      R0,[SP, #+0]
   \   00000026   0x.... 0x....      BL       ctrl_W25Q_read
    362          		if (sts >= 0) {
   \   0000002A   0x2800             CMP      R0,#+0
   \   0000002C   0xD407             BMI      ??man_flash_write_page_0
    363          			if (memcmp((void const *)data, flash_buff, length) == 0) {
   \   0000002E   0x0032             MOVS     R2,R6
   \   00000030   0x0029             MOVS     R1,R5
   \   00000032   0x0038             MOVS     R0,R7
   \   00000034   0x.... 0x....      BL       memcmp
   \   00000038   0x2800             CMP      R0,#+0
   \   0000003A   0xD100             BNE      ??man_flash_write_page_0
    364          				ret = 0;
   \   0000003C   0x2400             MOVS     R4,#+0
    365          			}
    366          		}
    367          	}
    368          	
    369          	return ret;
   \                     ??man_flash_write_page_0: (+1)
   \   0000003E   0x0020             MOVS     R0,R4
   \   00000040   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    370          }
    371          
    372          
    373          /********************************************************************/
    374          /*!
    375           * \name	man_flash_read
    376           * \brief	FLASH管理の読み出し処理
    377           * \param	flash_top  :: 読み出し先頭アドレス
    378           *          data       :: 読み出したデータ格納エリア
    379           *          length     :: 読み出しサイズ
    380           * \return  0: 読み込みOK , -1: FLASH無効　または　読み込み失敗
    381           * \note	各ファイル読み込み時に、呼ばれる
    382           */
    383          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    384          int32_t man_flash_read(int32_t flash_top, uint8_t *data, int32_t length)
    385          {
   \                     man_flash_read: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    386          	int32_t		ret = -1;
   \   00000002   0x2300             MOVS     R3,#+0
   \   00000004   0x43DB             MVNS     R3,R3            ;; #-1
    387          
    388          	ret = ctrl_W25Q_read(flash_top, data, length);
   \   00000006   0x.... 0x....      BL       ctrl_W25Q_read
   \   0000000A   0x0003             MOVS     R3,R0
    389          
    390          	return ret;
   \   0000000C   0x0018             MOVS     R0,R3
   \   0000000E   0xBD02             POP      {R1,PC}          ;; return
    391          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \   00000000   0x........         DC32     man_flash_work

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_1:
   \   00000000   0x0000EA61         DC32     0xea61

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_2:
   \   00000000   0x00002710         DC32     0x2710
    392          
    393          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       4   man_flash_erase_all
      24   man_flash_erase_block
        24 __aeabi_idivmod
      16   man_flash_erase_page
        16   -> clrl_W25Q_WriteEnable
        16   -> ctrl_W25Q_IsBusy
        16   -> ctrl_W25Q_erase_sector_req
        16 __aeabi_idivmod
       8   man_flash_init
         8   -> ctrl_W25Q_init
       8   man_flash_main
         8   -> clrl_W25Q_WriteEnable
         8   -> ctrl_W25Q_IsBusy
         8   -> ctrl_W25Q_erase_64k_block_req
         8   -> ctrl_W25Q_erase_all_req
         8   -> man_flash_return_callback
         8   -> man_timer_get_1ms_count
         8   -> man_timer_get_elapsed_time
       8   man_flash_read
         8   -> ctrl_W25Q_read
       8   man_flash_return_callback
         8   -- Indirect call
      24   man_flash_write_page
        24   -> ctrl_W25Q_read
        24   -> ctrl_W25Q_write_page
        24   -> man_memory_alloc
        24   -> memcmp


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable4
       4  ??DataTable4_1
       4  ??DataTable4_2
      24  man_flash_erase_all
      60  man_flash_erase_block
      68  man_flash_erase_page
       8  man_flash_init
     302  man_flash_main
      16  man_flash_read
      42  man_flash_return_callback
      32  man_flash_work
      66  man_flash_write_page

 
  32 bytes in section .bss
 598 bytes in section .text
 
 598 bytes of CODE memory
  32 bytes of DATA memory

Errors: none
Warnings: none
