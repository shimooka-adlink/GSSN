###############################################################################
#
# IAR ANSI C/C++ Compiler V7.80.4.12462/W32 for ARM       17/May/2019  13:31:39
# Copyright 1999-2017 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\GNSS\Software\rJ104_rc2\source\GNSS_GW\hal\ctrl_MPL3115A2.c
#    Command line =  
#        C:\GNSS\Software\rJ104_rc2\source\GNSS_GW\hal\ctrl_MPL3115A2.c -D
#        __TARGET_ARCH_7_M -D S1C31W74 -D GNSS_GW_SIDE_A -lCN
#        C:\GNSS\Software\rJ104_rc2\source\GNSS_GW\board\S5U1C31W74T1\IAR\DebugFlash\List
#        -lA
#        C:\GNSS\Software\rJ104_rc2\source\GNSS_GW\board\S5U1C31W74T1\IAR\DebugFlash\List
#        --diag_suppress Pe177,Pe111,Pa082 -o
#        C:\GNSS\Software\rJ104_rc2\source\GNSS_GW\board\S5U1C31W74T1\IAR\DebugFlash\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M0+ -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.5\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\GNSS\Software\rJ104_rc2\source\GNSS_GW\board\S5U1C31W74T1\IAR\ -I
#        C:\GNSS\Software\rJ104_rc2\source\GNSS_GW\board\S5U1C31W74T1\IAR\..\..\..\
#        -I "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.5\arm\CMSIS\Include\" -I "C:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 7.5\arm\inc\Epson\" -I
#        C:\GNSS\Software\rJ104_rc2\source\GNSS_GW\board\S5U1C31W74T1\IAR\..\..\..\..\..\CMSIS\Device\S1C31W74\Include\
#        -I
#        C:\GNSS\Software\rJ104_rc2\source\GNSS_GW\board\S5U1C31W74T1\IAR\..\..\..\..\..\CMSIS\Driver\Include\
#        -I
#        C:\GNSS\Software\rJ104_rc2\source\GNSS_GW\board\S5U1C31W74T1\IAR\..\..\..\..\..\sePeriphLibrary\
#        -I
#        C:\GNSS\Software\rJ104_rc2\source\GNSS_GW\board\S5U1C31W74T1\IAR\..\..\..\..\..\board\S5U1C31W74T1\
#        -I
#        C:\GNSS\Software\rJ104_rc2\source\GNSS_GW\board\S5U1C31W74T1\IAR\..\..\..\..\..\USBStack\INC\
#        -I
#        C:\GNSS\Software\rJ104_rc2\source\GNSS_GW\board\S5U1C31W74T1\IAR\..\..\..\include\
#        -Ol
#    Locale       =  Japanese_Japan.932
#    List file    =  
#        C:\GNSS\Software\rJ104_rc2\source\GNSS_GW\board\S5U1C31W74T1\IAR\DebugFlash\List\ctrl_MPL3115A2.lst
#    Object file  =  
#        C:\GNSS\Software\rJ104_rc2\source\GNSS_GW\board\S5U1C31W74T1\IAR\DebugFlash\Obj\ctrl_MPL3115A2.o
#
###############################################################################

C:\GNSS\Software\rJ104_rc2\source\GNSS_GW\hal\ctrl_MPL3115A2.c
      1          
      2          /**
      3            ******************************************************************************
      4            * @file    ctrl_MPL3115A2.c
      5            * @author  コア
      6            * @version V1.0
      7            * @date    05-August-2016
      8            * @brief   このファイルはI2C CH1を使用してデバイス(MPL3115A2)を制御するソフトウェアです。
      9            ******************************************************************************
     10            $Id: ctrl_MPL3115A2.c 185 2018-05-28 09:07:31Z y-suyama $
     11            * @attention
     12            *
     13            *****************************************************************************
     14          */ 
     15          
     16          
     17          #include <string.h>
     18          #include <stdio.h>
     19          #include <stdlib.h>
     20          #include "board.h"
     21          #include "drv_i2c_0.h"
     22          #include "man_data.h"
     23          #include "man_error.h"
     24          
     25          #pragma section = "CTRL_PRG_BLOCK"
     26          

   \                                 In section .data, align 1
     27          static uint8_t slave_addr = 0x60;
   \                     slave_addr:
   \   00000000   0x60               DC8 96
     28          
     29          #define	CTRL_MPL3115A2_RETRY	(1+0)		// リトライ回数  0回
     30          
     31          
     32          /********************************************************************/
     33          /*	static関数                                                      */
     34          /********************************************************************/
     35          
     36          
     37          /********************************************************************/
     38          /*!
     39           * \name	MPL3115A2_pt_data_cfg
     40           * \brief	センサデータレジスタ設定処理
     41           * \return   0: 成功
     42           *          -1:失敗
     43           * \note	CTRL REG1(気圧データ)
     44           *			  DREM  = 1  : 新しい圧力/高度または温度データにデータ準備完了イベントフラグを生成
     45           *			  PDEFE = 1  : 新しい気圧/高度データのイベントフラグを立てる
     46           *			  TDEFE = 1  : 新しい温度データでイベントフラグを立てる
     47           */
     48          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
     49          static int32_t MPL3115A2_pt_data_cfg(void)
     50          {
   \                     MPL3115A2_pt_data_cfg: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
     51          	int32_t	status=0;
   \   00000004   0x2000             MOVS     R0,#+0
     52          	uint8_t cmd[] = {0x13, 0x07};
   \   00000006   0x4669             MOV      R1,SP
   \   00000008   0x....             LDR      R2,??DataTable7
   \   0000000A   0x8813             LDRH     R3,[R2, #0]
   \   0000000C   0x800B             STRH     R3,[R1, #0]
     53          	int32_t	i;
     54          	
     55          	for (i=0; i<CTRL_MPL3115A2_RETRY; i++) {
   \   0000000E   0x2400             MOVS     R4,#+0
   \   00000010   0xE000             B        ??MPL3115A2_pt_data_cfg_0
   \                     ??MPL3115A2_pt_data_cfg_1: (+1)
   \   00000012   0x1C64             ADDS     R4,R4,#+1
   \                     ??MPL3115A2_pt_data_cfg_0: (+1)
   \   00000014   0x2C01             CMP      R4,#+1
   \   00000016   0xDA0C             BGE      ??MPL3115A2_pt_data_cfg_2
     56          		seSysSleepMS(2);
   \   00000018   0x2002             MOVS     R0,#+2
   \   0000001A   0x.... 0x....      BL       seSysSleepMS
     57          		status = i2c0_SendData(slave_addr, &cmd[0], 2, seDISABLE);
   \   0000001E   0x2300             MOVS     R3,#+0
   \   00000020   0x2202             MOVS     R2,#+2
   \   00000022   0x4669             MOV      R1,SP
   \   00000024   0x....             LDR      R0,??DataTable8
   \   00000026   0x7800             LDRB     R0,[R0, #+0]
   \   00000028   0xB280             UXTH     R0,R0
   \   0000002A   0x.... 0x....      BL       i2c0_SendData
     58          		if (status == 0) break;
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD1EF             BNE      ??MPL3115A2_pt_data_cfg_1
     59          	}
     60          	return status;
   \                     ??MPL3115A2_pt_data_cfg_2: (+1)
   \   00000032   0xBD16             POP      {R1,R2,R4,PC}    ;; return
     61          }
     62          
     63          
     64          /********************************************************************/
     65          /*!
     66           * \name	MPL3115A2_read_data_status
     67           * \brief	ステータスレジスタ取得処理
     68           * \return  0: 取得中
     69           *          1: 取得完了
     70           * \note	CTRL REG1(気圧データ)
     71           *			  PTOW(bit7) : 以前の圧力/高度または温度データは、新しい圧力/高度によって上書きされました
     72           *			  PTDR(bit3) : 新しいデータセットが準備完了
     73           */
     74          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
     75          static int32_t MPL3115A2_read_data_status(void)
     76          {
   \                     MPL3115A2_read_data_status: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
     77          	uint8_t buf[10] = {0};
   \   00000004   0xA801             ADD      R0,SP,#+4
   \   00000006   0x210C             MOVS     R1,#+12
   \   00000008   0x.... 0x....      BL       __aeabi_memclr4
     78          	int32_t	status;
     79          	int32_t	ret=0;
   \   0000000C   0x2500             MOVS     R5,#+0
     80          	uint8_t cmd[] = {0x00};			// ステータスレジスタ
   \   0000000E   0x4668             MOV      R0,SP
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x7001             STRB     R1,[R0, #0]
     81          	int32_t	i;
     82          
     83          
     84          	for (i=0; i<CTRL_MPL3115A2_RETRY; i++) {
   \   00000014   0x2400             MOVS     R4,#+0
   \   00000016   0xE000             B        ??MPL3115A2_read_data_status_0
   \                     ??MPL3115A2_read_data_status_1: (+1)
   \   00000018   0x1C64             ADDS     R4,R4,#+1
   \                     ??MPL3115A2_read_data_status_0: (+1)
   \   0000001A   0x2C01             CMP      R4,#+1
   \   0000001C   0xDA1B             BGE      ??MPL3115A2_read_data_status_2
     85          		// ステータスレジスタ取得
     86          		seSysSleepMS(2);
   \   0000001E   0x2002             MOVS     R0,#+2
   \   00000020   0x.... 0x....      BL       seSysSleepMS
     87          		status = i2c0_SendData(slave_addr, &cmd[0], 1, seENABLE);
   \   00000024   0x2301             MOVS     R3,#+1
   \   00000026   0x2201             MOVS     R2,#+1
   \   00000028   0x4669             MOV      R1,SP
   \   0000002A   0x....             LDR      R0,??DataTable8
   \   0000002C   0x7800             LDRB     R0,[R0, #+0]
   \   0000002E   0xB280             UXTH     R0,R0
   \   00000030   0x.... 0x....      BL       i2c0_SendData
     88          		if (status >= 0) {
   \   00000034   0x2800             CMP      R0,#+0
   \   00000036   0xD4EF             BMI      ??MPL3115A2_read_data_status_1
     89          			status = i2c0_ReceiveData(slave_addr, &buf[0], 1, seDISABLE);
   \   00000038   0x2300             MOVS     R3,#+0
   \   0000003A   0x2201             MOVS     R2,#+1
   \   0000003C   0xA901             ADD      R1,SP,#+4
   \   0000003E   0x....             LDR      R0,??DataTable8
   \   00000040   0x7800             LDRB     R0,[R0, #+0]
   \   00000042   0xB280             UXTH     R0,R0
   \   00000044   0x.... 0x....      BL       i2c0_ReceiveData
     90          			if (status >= 0) {
   \   00000048   0x2800             CMP      R0,#+0
   \   0000004A   0xD4E5             BMI      ??MPL3115A2_read_data_status_1
     91          				// PTDR判定
     92          				if (buf[0] & 0x08) {
   \   0000004C   0x4668             MOV      R0,SP
   \   0000004E   0x7900             LDRB     R0,[R0, #+4]
   \   00000050   0x0700             LSLS     R0,R0,#+28
   \   00000052   0xD500             BPL      ??MPL3115A2_read_data_status_3
     93          					ret=1;				// 準備完了
   \   00000054   0x2501             MOVS     R5,#+1
     94          				}
     95          				break;
     96          			}
     97          		}
     98          	}
     99          
    100          	return ret;
   \                     ??MPL3115A2_read_data_status_3: (+1)
   \                     ??MPL3115A2_read_data_status_2: (+1)
   \   00000056   0x0028             MOVS     R0,R5
   \   00000058   0xB005             ADD      SP,SP,#+20
   \   0000005A   0xBD30             POP      {R4,R5,PC}       ;; return
    101          }
    102          
    103          
    104          /********************************************************************/
    105          /*!
    106           * \name	switch_standby
    107           * \brief	スタンバイモードに切り替える
    108           * \return   0: 成功
    109           *          -1:失敗
    110           * \note	CTRL REG1(気圧データ)
    111           *			  ALT  = 0  : 気圧計モード
    112           *			  RAW  = 0  : 
    113           *			  RST  = 0  : 
    114           *			  OST  = 0  : 
    115           *			  SBYB = 0  : スタンバイモード
    116           */
    117          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    118          static int32_t switch_standby(void)
    119          {
   \                     switch_standby: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
    120          	int32_t	status;
    121          //	uint8_t cmd[] = {0x26, 0x38};						// データサンプル間の最小時間 512 ms
    122          	uint8_t cmd[] = {0x26, 0x30};						// データサンプル間の最小時間 258 ms
   \   00000004   0x4669             MOV      R1,SP
   \   00000006   0x....             LDR      R2,??DataTable8_1
   \   00000008   0x8813             LDRH     R3,[R2, #0]
   \   0000000A   0x800B             STRH     R3,[R1, #0]
    123          	int32_t	i;
    124          
    125          	for (i=0; i<CTRL_MPL3115A2_RETRY; i++) {
   \   0000000C   0x2400             MOVS     R4,#+0
   \   0000000E   0xE000             B        ??switch_standby_0
   \                     ??switch_standby_1: (+1)
   \   00000010   0x1C64             ADDS     R4,R4,#+1
   \                     ??switch_standby_0: (+1)
   \   00000012   0x2C01             CMP      R4,#+1
   \   00000014   0xDA0C             BGE      ??switch_standby_2
    126          		seSysSleepMS(2);
   \   00000016   0x2002             MOVS     R0,#+2
   \   00000018   0x.... 0x....      BL       seSysSleepMS
    127          		status = i2c0_SendData(slave_addr, &cmd[0], 2, seDISABLE);
   \   0000001C   0x2300             MOVS     R3,#+0
   \   0000001E   0x2202             MOVS     R2,#+2
   \   00000020   0x4669             MOV      R1,SP
   \   00000022   0x....             LDR      R0,??DataTable8
   \   00000024   0x7800             LDRB     R0,[R0, #+0]
   \   00000026   0xB280             UXTH     R0,R0
   \   00000028   0x.... 0x....      BL       i2c0_SendData
    128          		if (status >= 0) break;
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xD4EF             BMI      ??switch_standby_1
    129          	}
    130          
    131          	return status;
   \                     ??switch_standby_2: (+1)
   \   00000030   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    132          }
    133          
    134          /********************************************************************/
    135          /*!
    136           * \name	switch_temp_press
    137           * \brief	気温、気圧計に切り替える
    138           * \return   0: 成功
    139           *          -1:失敗
    140           * \note	CTRL REG1(気圧データ)
    141           *			  ALT  = 0  : 気圧計モード
    142           *			  RAW  = 0  : 
    143           *			  RST  = 0  : 
    144           *			  OST  = 0  : 
    145           *			  SBYB = 1  : アクティブモード
    146           */
    147          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    148          static int32_t switch_temp_press(void)
    149          {
   \                     switch_temp_press: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
    150          	int32_t	status;
    151          //	uint8_t cmd[] = {0x26, 0x39};			// データサンプル間の最小時間 512 ms
    152          	uint8_t cmd[] = {0x26, 0x31};			// データサンプル間の最小時間 258 ms
   \   00000004   0x4669             MOV      R1,SP
   \   00000006   0x....             LDR      R2,??DataTable9
   \   00000008   0x8813             LDRH     R3,[R2, #0]
   \   0000000A   0x800B             STRH     R3,[R1, #0]
    153          
    154          	int32_t	i;
    155          
    156          	for (i=0; i<CTRL_MPL3115A2_RETRY; i++) {
   \   0000000C   0x2400             MOVS     R4,#+0
   \   0000000E   0xE000             B        ??switch_temp_press_0
   \                     ??switch_temp_press_1: (+1)
   \   00000010   0x1C64             ADDS     R4,R4,#+1
   \                     ??switch_temp_press_0: (+1)
   \   00000012   0x2C01             CMP      R4,#+1
   \   00000014   0xDA0C             BGE      ??switch_temp_press_2
    157          		seSysSleepMS(2);
   \   00000016   0x2002             MOVS     R0,#+2
   \   00000018   0x.... 0x....      BL       seSysSleepMS
    158          		status = i2c0_SendData(slave_addr, &cmd[0], 2, seDISABLE);
   \   0000001C   0x2300             MOVS     R3,#+0
   \   0000001E   0x2202             MOVS     R2,#+2
   \   00000020   0x4669             MOV      R1,SP
   \   00000022   0x....             LDR      R0,??DataTable8
   \   00000024   0x7800             LDRB     R0,[R0, #+0]
   \   00000026   0xB280             UXTH     R0,R0
   \   00000028   0x.... 0x....      BL       i2c0_SendData
    159          		if (status >= 0) break;
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xD4EF             BMI      ??switch_temp_press_1
    160          	}
    161          
    162          	return status;
   \                     ??switch_temp_press_2: (+1)
   \   00000030   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    163          }
    164          
    165          
    166          /********************************************************************/
    167          /*!
    168           * \name	switch_altitude
    169           * \brief	高度計に切り替える
    170           * \return   0: 成功
    171           *          -1:失敗
    172           * \note	CTRL REG1(高度データ)
    173           *			  ALT  = 1  : 高度計モード
    174           *			  RAW  = 0  : 
    175           *			  RST  = 0  : 
    176           *			  OST  = 0  : 
    177           *			  SBYB = 1  : アクティブモード
    178           */
    179          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    180          static int32_t switch_altitude(void)
    181          {
   \                     switch_altitude: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
    182          	int32_t	status;
    183          //	uint8_t cmd[] = {0x26, 0xB9};		// データサンプル間の最小時間 512 ms
    184          	uint8_t cmd[] = {0x26, 0xB1};		// データサンプル間の最小時間 258 ms
   \   00000004   0x4669             MOV      R1,SP
   \   00000006   0x....             LDR      R2,??DataTable9_1
   \   00000008   0x8813             LDRH     R3,[R2, #0]
   \   0000000A   0x800B             STRH     R3,[R1, #0]
    185          	int32_t	i;
    186          
    187          	for (i=0; i<CTRL_MPL3115A2_RETRY; i++) {
   \   0000000C   0x2400             MOVS     R4,#+0
   \   0000000E   0xE000             B        ??switch_altitude_0
   \                     ??switch_altitude_1: (+1)
   \   00000010   0x1C64             ADDS     R4,R4,#+1
   \                     ??switch_altitude_0: (+1)
   \   00000012   0x2C01             CMP      R4,#+1
   \   00000014   0xDA0C             BGE      ??switch_altitude_2
    188          		seSysSleepMS(2);
   \   00000016   0x2002             MOVS     R0,#+2
   \   00000018   0x.... 0x....      BL       seSysSleepMS
    189          		status = i2c0_SendData(slave_addr, &cmd[0], 2, seDISABLE);
   \   0000001C   0x2300             MOVS     R3,#+0
   \   0000001E   0x2202             MOVS     R2,#+2
   \   00000020   0x4669             MOV      R1,SP
   \   00000022   0x....             LDR      R0,??DataTable9_2
   \   00000024   0x7800             LDRB     R0,[R0, #+0]
   \   00000026   0xB280             UXTH     R0,R0
   \   00000028   0x.... 0x....      BL       i2c0_SendData
    190          		if (status >= 0) break;
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xD4EF             BMI      ??switch_altitude_1
    191          	}
    192          
    193          	return status;
   \                     ??switch_altitude_2: (+1)
   \   00000030   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    194          }
    195          
    196          
    197          /********************************************************************/
    198          /*!
    199           * \name	set_press_offset
    200           * \brief	気圧の補正を行う
    201           *            範囲は-512 ? +508Pa、4Pa / LSBです
    202           * \param	offset : 気温のオフセット値(1カウントは4Pa)
    203           * \return   0: 成功
    204           *          -1:失敗
    205           * \note	
    206           */
    207          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    208          static int32_t set_press_offset(int8_t offset)
    209          {
   \                     set_press_offset: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0001             MOVS     R1,R0
    210          	int32_t	status;
    211          	uint8_t cmd[] = {0x2B, 0x00};
   \   00000004   0x466A             MOV      R2,SP
   \   00000006   0x....             LDR      R3,??DataTable9_3
   \   00000008   0x881C             LDRH     R4,[R3, #0]
   \   0000000A   0x8014             STRH     R4,[R2, #0]
    212          	int32_t	i;
    213          
    214          	cmd[1] = offset;
   \   0000000C   0x466A             MOV      R2,SP
   \   0000000E   0x7051             STRB     R1,[R2, #+1]
    215          	for (i=0; i<CTRL_MPL3115A2_RETRY; i++) {
   \   00000010   0x2400             MOVS     R4,#+0
   \   00000012   0xE000             B        ??set_press_offset_0
   \                     ??set_press_offset_1: (+1)
   \   00000014   0x1C64             ADDS     R4,R4,#+1
   \                     ??set_press_offset_0: (+1)
   \   00000016   0x2C01             CMP      R4,#+1
   \   00000018   0xDA0C             BGE      ??set_press_offset_2
    216          		seSysSleepMS(2);
   \   0000001A   0x2002             MOVS     R0,#+2
   \   0000001C   0x.... 0x....      BL       seSysSleepMS
    217          		status = i2c0_SendData(slave_addr, &cmd[0], 2, seDISABLE);
   \   00000020   0x2300             MOVS     R3,#+0
   \   00000022   0x2202             MOVS     R2,#+2
   \   00000024   0x4669             MOV      R1,SP
   \   00000026   0x....             LDR      R0,??DataTable9_2
   \   00000028   0x7800             LDRB     R0,[R0, #+0]
   \   0000002A   0xB280             UXTH     R0,R0
   \   0000002C   0x.... 0x....      BL       i2c0_SendData
    218          		if (status >= 0) break;
   \   00000030   0x2800             CMP      R0,#+0
   \   00000032   0xD4EF             BMI      ??set_press_offset_1
    219          	}
    220          
    221          	return status;
   \                     ??set_press_offset_2: (+1)
   \   00000034   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    222          }
    223          
    224          
    225          /********************************************************************/
    226          /*!
    227           * \name	set_temp_offset
    228           * \brief	温度の補正を行う
    229           *            範囲は -8 ? +7.9375℃, 0.0625℃/ LSBです。
    230           * \param	offset : 気温のオフセット値(1カウントは0.0625℃)
    231           * \return   0: 成功
    232           *          -1:失敗
    233           * \note	
    234           */
    235          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    236          static int32_t set_temp_offset(int8_t offset)
    237          {
   \                     set_temp_offset: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0001             MOVS     R1,R0
    238          	int32_t	status;
    239          	uint8_t cmd[] = {0x2C, 0x00};
   \   00000004   0x466A             MOV      R2,SP
   \   00000006   0x....             LDR      R3,??DataTable9_4
   \   00000008   0x881C             LDRH     R4,[R3, #0]
   \   0000000A   0x8014             STRH     R4,[R2, #0]
    240          	int32_t	i;
    241          
    242          	cmd[1] = offset;
   \   0000000C   0x466A             MOV      R2,SP
   \   0000000E   0x7051             STRB     R1,[R2, #+1]
    243          	for (i=0; i<CTRL_MPL3115A2_RETRY; i++) {
   \   00000010   0x2400             MOVS     R4,#+0
   \   00000012   0xE000             B        ??set_temp_offset_0
   \                     ??set_temp_offset_1: (+1)
   \   00000014   0x1C64             ADDS     R4,R4,#+1
   \                     ??set_temp_offset_0: (+1)
   \   00000016   0x2C01             CMP      R4,#+1
   \   00000018   0xDA0C             BGE      ??set_temp_offset_2
    244          		seSysSleepMS(2);
   \   0000001A   0x2002             MOVS     R0,#+2
   \   0000001C   0x.... 0x....      BL       seSysSleepMS
    245          		status = i2c0_SendData(slave_addr, &cmd[0], 2, seDISABLE);
   \   00000020   0x2300             MOVS     R3,#+0
   \   00000022   0x2202             MOVS     R2,#+2
   \   00000024   0x4669             MOV      R1,SP
   \   00000026   0x....             LDR      R0,??DataTable9_2
   \   00000028   0x7800             LDRB     R0,[R0, #+0]
   \   0000002A   0xB280             UXTH     R0,R0
   \   0000002C   0x.... 0x....      BL       i2c0_SendData
    246          		if (status >= 0) break;
   \   00000030   0x2800             CMP      R0,#+0
   \   00000032   0xD4EF             BMI      ??set_temp_offset_1
    247          	}
    248          
    249          	return status;
   \                     ??set_temp_offset_2: (+1)
   \   00000034   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    250          }
    251          
    252          
    253          /********************************************************************/
    254          /*!
    255           * \name	set_altitude_offset
    256           * \brief	高度の補正を行う
    257           *            範囲は -128?+ 127メートルです。1メートル/ LSBです。
    258           * \param	offset :高度のオフセット値(1カウントは1メートル)
    259           * \return   0: 成功
    260           *          -1:失敗
    261           * \note	
    262           */
    263          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    264          static int32_t set_altitude_offset(int8_t offset)
    265          {
   \                     set_altitude_offset: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0001             MOVS     R1,R0
    266          	int32_t	status;
    267          	uint8_t cmd[] = {0x2D, 0x00};
   \   00000004   0x466A             MOV      R2,SP
   \   00000006   0x....             LDR      R3,??DataTable9_5
   \   00000008   0x881C             LDRH     R4,[R3, #0]
   \   0000000A   0x8014             STRH     R4,[R2, #0]
    268          	int32_t	i;
    269          
    270          	cmd[1] = offset;
   \   0000000C   0x466A             MOV      R2,SP
   \   0000000E   0x7051             STRB     R1,[R2, #+1]
    271          	for (i=0; i<CTRL_MPL3115A2_RETRY; i++) {
   \   00000010   0x2400             MOVS     R4,#+0
   \   00000012   0xE000             B        ??set_altitude_offset_0
   \                     ??set_altitude_offset_1: (+1)
   \   00000014   0x1C64             ADDS     R4,R4,#+1
   \                     ??set_altitude_offset_0: (+1)
   \   00000016   0x2C01             CMP      R4,#+1
   \   00000018   0xDA0C             BGE      ??set_altitude_offset_2
    272          		seSysSleepMS(2);
   \   0000001A   0x2002             MOVS     R0,#+2
   \   0000001C   0x.... 0x....      BL       seSysSleepMS
    273          		status = i2c0_SendData(slave_addr, &cmd[0], 2, seDISABLE);
   \   00000020   0x2300             MOVS     R3,#+0
   \   00000022   0x2202             MOVS     R2,#+2
   \   00000024   0x4669             MOV      R1,SP
   \   00000026   0x....             LDR      R0,??DataTable9_2
   \   00000028   0x7800             LDRB     R0,[R0, #+0]
   \   0000002A   0xB280             UXTH     R0,R0
   \   0000002C   0x.... 0x....      BL       i2c0_SendData
    274          		if (status >= 0) break;
   \   00000030   0x2800             CMP      R0,#+0
   \   00000032   0xD4EF             BMI      ??set_altitude_offset_1
    275          	}
    276          
    277          	return status;
   \                     ??set_altitude_offset_2: (+1)
   \   00000034   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    278          }
    279          
    280          /********************************************************************/
    281          /*	extern関数                                                      */
    282          /********************************************************************/
    283          
    284          /********************************************************************/
    285          /*!
    286           * \name	ctrc_MPL3115A2_start
    287           * \brief	MPL3115A2の開始処理
    288           * \return   0: 成功
    289           *          -1:失敗
    290           * \note	なし
    291           */
    292          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    293          int32_t ctrc_MPL3115A2_start(void)
    294          {
   \                     ctrc_MPL3115A2_start: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    295          	int32_t	status;
    296          
    297          
    298          	// 気温、気圧計に切り替える
    299          	status = switch_temp_press();
   \   00000002   0x.... 0x....      BL       switch_temp_press
    300          
    301          
    302          	// 取得開始
    303          	if (status >= 0) {
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD401             BMI      ??ctrc_MPL3115A2_start_0
    304          		status = MPL3115A2_pt_data_cfg();
   \   0000000A   0x.... 0x....      BL       MPL3115A2_pt_data_cfg
    305          	}
    306          
    307          
    308          	return status;
   \                     ??ctrc_MPL3115A2_start_0: (+1)
   \   0000000E   0xBD02             POP      {R1,PC}          ;; return
    309          }
    310          
    311          
    312          /********************************************************************/
    313          /*!
    314           * \name	get_temp_press
    315           * \brief	気温・気圧データを取得する
    316           * \param	temperature : 気温(-** 〜 **[℃])格納エリア
    317           * 			pressure    : 気圧(******[hPa])格納エリア
    318           * \return   0: 成功
    319           *          -1: 失敗
    320           * \note	データサンプル間の最小時間 258 msです。
    321           */
    322          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    323          int32_t ctrc_MPL3115A2_get_press(int32_t *temperature, int32_t *pressure)
    324          {
   \                     ctrc_MPL3115A2_get_press: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
   \   00000004   0x0007             MOVS     R7,R0
   \   00000006   0x000E             MOVS     R6,R1
    325          	int32_t		ret=0;
   \   00000008   0x2500             MOVS     R5,#+0
    326          	int32_t		status;
    327          	uint8_t 	buf[10] = {0};
   \   0000000A   0xA801             ADD      R0,SP,#+4
   \   0000000C   0x210C             MOVS     R1,#+12
   \   0000000E   0x.... 0x....      BL       __aeabi_memclr4
    328          	uint8_t 	cmd1[] = {0x04};			// 温度データレジスタ
   \   00000012   0xA800             ADD      R0,SP,#+0
   \   00000014   0x1C40             ADDS     R0,R0,#+1
   \   00000016   0x....             LDR      R1,??DataTable9_6
   \   00000018   0x780A             LDRB     R2,[R1, #0]
   \   0000001A   0x7002             STRB     R2,[R0, #0]
    329          	uint8_t 	cmd2[] = {0x01};			// 気圧[Pa]および高度[m]データレジスタ
   \   0000001C   0x4668             MOV      R0,SP
   \   0000001E   0x....             LDR      R1,??DataTable9_7
   \   00000020   0x780A             LDRB     R2,[R1, #0]
   \   00000022   0x7002             STRB     R2,[R0, #0]
    330          	int32_t		temperature_raw=0;
   \   00000024   0x2000             MOVS     R0,#+0
    331          	double		temperature_tmp=0;
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0x2100             MOVS     R1,#+0
    332          	uint32_t	pressure_raw=0;
   \   0000002A   0x2000             MOVS     R0,#+0
    333          	double		pressure_tmp=0;
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0x2100             MOVS     R1,#+0
    334          	int32_t		i;
    335          //	uint32_t	rcv_data;
    336          
    337          	// 新しいデータセットの準備完了確認
    338          	status = MPL3115A2_read_data_status();
   \   00000030   0x.... 0x....      BL       MPL3115A2_read_data_status
    339          
    340          	// 準備完了の場合
    341          	if (status == 1) {
   \   00000034   0x2801             CMP      R0,#+1
   \   00000036   0xD16E             BNE      ??ctrc_MPL3115A2_get_press_0
    342          
    343          		// 気温データ取得
    344          		ret = -1;
   \   00000038   0x2500             MOVS     R5,#+0
   \   0000003A   0x43ED             MVNS     R5,R5            ;; #-1
    345          		for (i=0; i<CTRL_MPL3115A2_RETRY; i++) {
   \   0000003C   0x2400             MOVS     R4,#+0
   \   0000003E   0xE000             B        ??ctrc_MPL3115A2_get_press_1
   \                     ??ctrc_MPL3115A2_get_press_2: (+1)
   \   00000040   0x1C64             ADDS     R4,R4,#+1
   \                     ??ctrc_MPL3115A2_get_press_1: (+1)
   \   00000042   0x2C01             CMP      R4,#+1
   \   00000044   0xDA2A             BGE      ??ctrc_MPL3115A2_get_press_3
    346          			seSysSleepMS(2);
   \   00000046   0x2002             MOVS     R0,#+2
   \   00000048   0x.... 0x....      BL       seSysSleepMS
    347          			status = i2c0_SendData(slave_addr, &cmd1[0], 1, seENABLE);
   \   0000004C   0x2301             MOVS     R3,#+1
   \   0000004E   0x2201             MOVS     R2,#+1
   \   00000050   0xA900             ADD      R1,SP,#+0
   \   00000052   0x1C49             ADDS     R1,R1,#+1
   \   00000054   0x....             LDR      R0,??DataTable9_2
   \   00000056   0x7800             LDRB     R0,[R0, #+0]
   \   00000058   0xB280             UXTH     R0,R0
   \   0000005A   0x.... 0x....      BL       i2c0_SendData
    348          			if (status >= 0) {
   \   0000005E   0x2800             CMP      R0,#+0
   \   00000060   0xD4EE             BMI      ??ctrc_MPL3115A2_get_press_2
    349          				seSysSleepMS(1);
   \   00000062   0x2001             MOVS     R0,#+1
   \   00000064   0x.... 0x....      BL       seSysSleepMS
    350          				status = i2c0_ReceiveData(slave_addr, &buf[0], 2, seDISABLE);
   \   00000068   0x2300             MOVS     R3,#+0
   \   0000006A   0x2202             MOVS     R2,#+2
   \   0000006C   0xA901             ADD      R1,SP,#+4
   \   0000006E   0x....             LDR      R0,??DataTable9_2
   \   00000070   0x7800             LDRB     R0,[R0, #+0]
   \   00000072   0xB280             UXTH     R0,R0
   \   00000074   0x.... 0x....      BL       i2c0_ReceiveData
    351          				if (status >= 0) {
   \   00000078   0x2800             CMP      R0,#+0
   \   0000007A   0xD4E1             BMI      ??ctrc_MPL3115A2_get_press_2
    352          					// 8bit.4bit : ********.****0000
    353          					//             buf[0]   buf[1]
    354          					temperature_raw = buf[0];
   \   0000007C   0x4668             MOV      R0,SP
   \   0000007E   0x7900             LDRB     R0,[R0, #+4]
    355          					// 四捨五入
    356          					if ((buf[1] & 0x80) != 0) {
   \   00000080   0xA901             ADD      R1,SP,#+4
   \   00000082   0x7849             LDRB     R1,[R1, #+1]
   \   00000084   0x0609             LSLS     R1,R1,#+24
   \   00000086   0xD500             BPL      ??ctrc_MPL3115A2_get_press_4
    357          						temperature_raw++;
   \   00000088   0x1C40             ADDS     R0,R0,#+1
    358          					}
    359          					if ( (buf[0] & 0x80) != 0 ) {
   \                     ??ctrc_MPL3115A2_get_press_4: (+1)
   \   0000008A   0x4669             MOV      R1,SP
   \   0000008C   0x7909             LDRB     R1,[R1, #+4]
   \   0000008E   0x0609             LSLS     R1,R1,#+24
   \   00000090   0xD502             BPL      ??ctrc_MPL3115A2_get_press_5
    360          						temperature_raw -= 256;
   \   00000092   0x21FF             MOVS     R1,#+255
   \   00000094   0x43C9             MVNS     R1,R1            ;; #-256
   \   00000096   0x1840             ADDS     R0,R0,R1
    361          					}
    362          
    363          					// 範囲外はログに残す
    364          //					if ( (temperature_raw < MAN_DATA_TEMP_MIN) || (MAN_DATA_TEMP_MAX < temperature_raw) ) {
    365          //						rcv_data = (buf[0] << 16) + (buf[1] << 8) + buf[2];
    366          //						man_error_setting(MAN_ERROR_CTRL_MPL, temperature_raw, rcv_data);
    367          //					}
    368          					*temperature = temperature_raw;
   \                     ??ctrc_MPL3115A2_get_press_5: (+1)
   \   00000098   0x6038             STR      R0,[R7, #+0]
    369          					ret = 0;
   \   0000009A   0x2500             MOVS     R5,#+0
    370          					break;
    371          				}
    372          			}
    373          		}
    374          
    375          		// 気圧データ取得
    376          		if (ret >= 0) {
   \                     ??ctrc_MPL3115A2_get_press_3: (+1)
   \   0000009C   0x2D00             CMP      R5,#+0
   \   0000009E   0xD43C             BMI      ??ctrc_MPL3115A2_get_press_6
    377          			ret = -1;
   \   000000A0   0x2500             MOVS     R5,#+0
   \   000000A2   0x43ED             MVNS     R5,R5            ;; #-1
    378          			for (i=0; i<CTRL_MPL3115A2_RETRY; i++) {
   \   000000A4   0x2400             MOVS     R4,#+0
   \   000000A6   0xE000             B        ??ctrc_MPL3115A2_get_press_7
   \                     ??ctrc_MPL3115A2_get_press_8: (+1)
   \   000000A8   0x1C64             ADDS     R4,R4,#+1
   \                     ??ctrc_MPL3115A2_get_press_7: (+1)
   \   000000AA   0x2C01             CMP      R4,#+1
   \   000000AC   0xDA35             BGE      ??ctrc_MPL3115A2_get_press_6
    379          				seSysSleepMS(2);
   \   000000AE   0x2002             MOVS     R0,#+2
   \   000000B0   0x.... 0x....      BL       seSysSleepMS
    380          				status = i2c0_SendData(slave_addr, &cmd2[0], 1, seENABLE);
   \   000000B4   0x2301             MOVS     R3,#+1
   \   000000B6   0x2201             MOVS     R2,#+1
   \   000000B8   0x4669             MOV      R1,SP
   \   000000BA   0x....             LDR      R0,??DataTable9_2
   \   000000BC   0x7800             LDRB     R0,[R0, #+0]
   \   000000BE   0xB280             UXTH     R0,R0
   \   000000C0   0x.... 0x....      BL       i2c0_SendData
    381          				if (status >= 0) {
   \   000000C4   0x2800             CMP      R0,#+0
   \   000000C6   0xD4EF             BMI      ??ctrc_MPL3115A2_get_press_8
    382          					seSysSleepMS(1);
   \   000000C8   0x2001             MOVS     R0,#+1
   \   000000CA   0x.... 0x....      BL       seSysSleepMS
    383          					status = i2c0_ReceiveData(slave_addr, &buf[0], 3, seDISABLE);
   \   000000CE   0x2300             MOVS     R3,#+0
   \   000000D0   0x2203             MOVS     R2,#+3
   \   000000D2   0xA901             ADD      R1,SP,#+4
   \   000000D4   0x....             LDR      R0,??DataTable9_2
   \   000000D6   0x7800             LDRB     R0,[R0, #+0]
   \   000000D8   0xB280             UXTH     R0,R0
   \   000000DA   0x.... 0x....      BL       i2c0_ReceiveData
    384          					if (status >= 0) {
   \   000000DE   0x2800             CMP      R0,#+0
   \   000000E0   0xD4E2             BMI      ??ctrc_MPL3115A2_get_press_8
    385          						// 18bit.2bit : ******** ******** **.**0000
    386          						//              buf[0]   buf[1]   buf[2]
    387          						pressure_raw = buf[0];
   \   000000E2   0x4668             MOV      R0,SP
   \   000000E4   0x7900             LDRB     R0,[R0, #+4]
    388          						pressure_raw <<= 8;
   \   000000E6   0x0200             LSLS     R0,R0,#+8
    389          						pressure_raw |= buf[1];
   \   000000E8   0x0001             MOVS     R1,R0
   \   000000EA   0xA801             ADD      R0,SP,#+4
   \   000000EC   0x7840             LDRB     R0,[R0, #+1]
   \   000000EE   0x4308             ORRS     R0,R0,R1
    390          						pressure_raw <<= 8;
   \   000000F0   0x0200             LSLS     R0,R0,#+8
    391          						pressure_raw |= buf[2];
   \   000000F2   0x0001             MOVS     R1,R0
   \   000000F4   0xA801             ADD      R0,SP,#+4
   \   000000F6   0x7880             LDRB     R0,[R0, #+2]
   \   000000F8   0x4308             ORRS     R0,R0,R1
    392          						pressure_raw >>= 6;
   \   000000FA   0x0980             LSRS     R0,R0,#+6
    393          						// 四捨五入
    394          						if ( (buf[2] & 0x20) != 0) {
   \   000000FC   0xA901             ADD      R1,SP,#+4
   \   000000FE   0x7889             LDRB     R1,[R1, #+2]
   \   00000100   0x0689             LSLS     R1,R1,#+26
   \   00000102   0xD500             BPL      ??ctrc_MPL3115A2_get_press_9
    395          							pressure_raw++;
   \   00000104   0x1C40             ADDS     R0,R0,#+1
    396          						}
    397          
    398          						// 範囲外はログに残す
    399          //						pressure_raw = pressure_raw/100;	// Pa->hPa
    400          //						if ( (pressure_raw < MAN_DATA_PRSS_MIN) || (MAN_DATA_PRSS_MAX < pressure_raw) ) {
    401          //							rcv_data = (buf[0] << 16) + (buf[1] << 8) + buf[2];
    402          //							man_error_setting(MAN_ERROR_CTRL_MPL, pressure_raw, rcv_data);
    403          //						}
    404          						
    405          						*pressure = pressure_raw;	// Pa;
   \                     ??ctrc_MPL3115A2_get_press_9: (+1)
   \   00000106   0x6030             STR      R0,[R6, #+0]
    406          
    407          						seSysSleepMS(2);
   \   00000108   0x2002             MOVS     R0,#+2
   \   0000010A   0x.... 0x....      BL       seSysSleepMS
    408          						// 高度計に切り替える
    409          						status = switch_altitude();
   \   0000010E   0x.... 0x....      BL       switch_altitude
    410          						ret = 0;
   \   00000112   0x2500             MOVS     R5,#+0
    411          						break;
   \   00000114   0xE001             B        ??ctrc_MPL3115A2_get_press_6
    412          					}
    413          				}
    414          			}
    415          		}
    416          	}
    417          
    418          	// 準備中の場合
    419          	else {
    420                    ret = -1;
   \                     ??ctrc_MPL3115A2_get_press_0: (+1)
   \   00000116   0x2500             MOVS     R5,#+0
   \   00000118   0x43ED             MVNS     R5,R5            ;; #-1
    421          	}
    422          
    423          	return ret;
   \                     ??ctrc_MPL3115A2_get_press_6: (+1)
   \   0000011A   0x0028             MOVS     R0,R5
   \   0000011C   0xB005             ADD      SP,SP,#+20
   \   0000011E   0xBDF0             POP      {R4-R7,PC}       ;; return
    424          }
    425          
    426          
    427          
    428          /********************************************************************/
    429          /*!
    430           * \name	get_altitude
    431           * \brief	高度データを取得する
    432           * \param	altitude : 高度(-*** 〜 *****[m])格納エリア
    433           * \return   0: 成功
    434           *          -1:失敗
    435           *           1: 準備中
    436           * \note	データサンプル間の最小時間 258 msです。
    437           */
    438          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    439          int32_t ctrc_MPL3115A2_get_altitude(int32_t *altitude)
    440          {
   \                     ctrc_MPL3115A2_get_altitude: (+1)
   \   00000000   0xB57F             PUSH     {R0-R6,LR}
   \   00000002   0x0006             MOVS     R6,R0
    441          	int32_t		ret=0;
   \   00000004   0x2400             MOVS     R4,#+0
    442          	int32_t		status;
    443          	uint8_t 	buf[10] = {0};
   \   00000006   0xA801             ADD      R0,SP,#+4
   \   00000008   0x210C             MOVS     R1,#+12
   \   0000000A   0x.... 0x....      BL       __aeabi_memclr4
    444          	uint8_t 	cmd1[] = {0x04};			// 温度データレジスタ
   \   0000000E   0xA800             ADD      R0,SP,#+0
   \   00000010   0x1C40             ADDS     R0,R0,#+1
   \   00000012   0x....             LDR      R1,??DataTable9_8
   \   00000014   0x780A             LDRB     R2,[R1, #0]
   \   00000016   0x7002             STRB     R2,[R0, #0]
    445          	uint8_t 	cmd2[] = {0x01};			// 気圧[Pa]および高度[m]データレジスタ
   \   00000018   0x4668             MOV      R0,SP
   \   0000001A   0x....             LDR      R1,??DataTable9_9
   \   0000001C   0x780A             LDRB     R2,[R1, #0]
   \   0000001E   0x7002             STRB     R2,[R0, #0]
    446          	int32_t		altimeter_raw=0;
   \   00000020   0x2000             MOVS     R0,#+0
    447          	int32_t		i;
    448          	int32_t		temperature_raw=0;
   \   00000022   0x2000             MOVS     R0,#+0
    449          //	uint32_t	rcv_data;
    450          
    451          	// 新しいデータセットの準備完了確認
    452          	status = MPL3115A2_read_data_status();
   \   00000024   0x.... 0x....      BL       MPL3115A2_read_data_status
    453          
    454          	// 準備完了の場合
    455          	if (status == 1) {
   \   00000028   0x2801             CMP      R0,#+1
   \   0000002A   0xD13C             BNE      ??ctrc_MPL3115A2_get_altitude_0
    456          		// 高度データ取得
    457          		if (ret >= 0) {
   \   0000002C   0x2C00             CMP      R4,#+0
   \   0000002E   0xD43C             BMI      ??ctrc_MPL3115A2_get_altitude_1
    458          			ret = -1;
   \   00000030   0x2400             MOVS     R4,#+0
   \   00000032   0x43E4             MVNS     R4,R4            ;; #-1
    459          			for (i=0; i<CTRL_MPL3115A2_RETRY; i++) {
   \   00000034   0x2500             MOVS     R5,#+0
   \   00000036   0xE000             B        ??ctrc_MPL3115A2_get_altitude_2
   \                     ??ctrc_MPL3115A2_get_altitude_3: (+1)
   \   00000038   0x1C6D             ADDS     R5,R5,#+1
   \                     ??ctrc_MPL3115A2_get_altitude_2: (+1)
   \   0000003A   0x2D01             CMP      R5,#+1
   \   0000003C   0xDA35             BGE      ??ctrc_MPL3115A2_get_altitude_1
    460          				// 高度データ取得
    461          				seSysSleepMS(2);
   \   0000003E   0x2002             MOVS     R0,#+2
   \   00000040   0x.... 0x....      BL       seSysSleepMS
    462          				status = i2c0_SendData(slave_addr, &cmd2[0], 1, seENABLE);
   \   00000044   0x2301             MOVS     R3,#+1
   \   00000046   0x2201             MOVS     R2,#+1
   \   00000048   0x4669             MOV      R1,SP
   \   0000004A   0x....             LDR      R0,??DataTable9_2
   \   0000004C   0x7800             LDRB     R0,[R0, #+0]
   \   0000004E   0xB280             UXTH     R0,R0
   \   00000050   0x.... 0x....      BL       i2c0_SendData
    463          				if (status >= 0) {
   \   00000054   0x2800             CMP      R0,#+0
   \   00000056   0xD4EF             BMI      ??ctrc_MPL3115A2_get_altitude_3
    464          					seSysSleepMS(1);
   \   00000058   0x2001             MOVS     R0,#+1
   \   0000005A   0x.... 0x....      BL       seSysSleepMS
    465          					status = i2c0_ReceiveData(slave_addr, &buf[0], 3, seDISABLE);
   \   0000005E   0x2300             MOVS     R3,#+0
   \   00000060   0x2203             MOVS     R2,#+3
   \   00000062   0xA901             ADD      R1,SP,#+4
   \   00000064   0x....             LDR      R0,??DataTable9_2
   \   00000066   0x7800             LDRB     R0,[R0, #+0]
   \   00000068   0xB280             UXTH     R0,R0
   \   0000006A   0x.... 0x....      BL       i2c0_ReceiveData
    466          					if (status >= 0) {
   \   0000006E   0x2800             CMP      R0,#+0
   \   00000070   0xD4E2             BMI      ??ctrc_MPL3115A2_get_altitude_3
    467          
    468          						// 16bit.4bit : ******** ******** .****0000
    469          						//              buf[0]   buf[1]    buf[2]
    470          						altimeter_raw = buf[0];
   \   00000072   0x4668             MOV      R0,SP
   \   00000074   0x7900             LDRB     R0,[R0, #+4]
    471          						altimeter_raw <<= 8;
   \   00000076   0x0200             LSLS     R0,R0,#+8
    472          						altimeter_raw |= buf[1];
   \   00000078   0x0001             MOVS     R1,R0
   \   0000007A   0xA801             ADD      R0,SP,#+4
   \   0000007C   0x7840             LDRB     R0,[R0, #+1]
   \   0000007E   0x4308             ORRS     R0,R0,R1
    473          						// 四捨五入
    474          						if ( (buf[2] & 0x80) != 0) {
   \   00000080   0xA901             ADD      R1,SP,#+4
   \   00000082   0x7889             LDRB     R1,[R1, #+2]
   \   00000084   0x0609             LSLS     R1,R1,#+24
   \   00000086   0xD500             BPL      ??ctrc_MPL3115A2_get_altitude_4
    475          								altimeter_raw++;
   \   00000088   0x1C40             ADDS     R0,R0,#+1
    476          						}
    477          						if ( (buf[0] & 0x80) != 0) {
   \                     ??ctrc_MPL3115A2_get_altitude_4: (+1)
   \   0000008A   0x4669             MOV      R1,SP
   \   0000008C   0x7909             LDRB     R1,[R1, #+4]
   \   0000008E   0x0609             LSLS     R1,R1,#+24
   \   00000090   0xD501             BPL      ??ctrc_MPL3115A2_get_altitude_5
    478          							altimeter_raw -= 65536;
   \   00000092   0x....             LDR      R1,??DataTable9_10  ;; 0xffff0000
   \   00000094   0x1840             ADDS     R0,R0,R1
    479          						}
    480          						*altitude = altimeter_raw;
   \                     ??ctrc_MPL3115A2_get_altitude_5: (+1)
   \   00000096   0x6030             STR      R0,[R6, #+0]
    481          
    482          						// 範囲外はログに残す
    483          //						if ( (altimeter_raw < MAN_DATA_HIGH_MIN) || (MAN_DATA_HIGH_MAX < altimeter_raw) ) {
    484          //							rcv_data = (buf[0] << 16) + (buf[1] << 8) + buf[2];
    485          //							man_error_setting(MAN_ERROR_CTRL_MPL, altimeter_raw, rcv_data);
    486          //						}
    487          
    488          						seSysSleepMS(2);
   \   00000098   0x2002             MOVS     R0,#+2
   \   0000009A   0x.... 0x....      BL       seSysSleepMS
    489          						// 気温、気圧計に切り替える
    490          						status = switch_temp_press();
   \   0000009E   0x.... 0x....      BL       switch_temp_press
    491          						ret = 0;
   \   000000A2   0x2400             MOVS     R4,#+0
    492          						break;
   \   000000A4   0xE001             B        ??ctrc_MPL3115A2_get_altitude_1
    493          					}
    494          				}
    495          			}
    496          		}
    497          	}
    498          
    499          	// 準備中の場合
    500          	else {
    501                    ret = -1;
   \                     ??ctrc_MPL3115A2_get_altitude_0: (+1)
   \   000000A6   0x2400             MOVS     R4,#+0
   \   000000A8   0x43E4             MVNS     R4,R4            ;; #-1
    502          	}
    503          
    504          	return ret;
   \                     ??ctrc_MPL3115A2_get_altitude_1: (+1)
   \   000000AA   0x0020             MOVS     R0,R4
   \   000000AC   0xB004             ADD      SP,SP,#+16
   \   000000AE   0xBD70             POP      {R4-R6,PC}       ;; return
    505          }
    506          
    507          
    508          
    509          /********************************************************************/
    510          /*!
    511           * \name	ctrc_MPL3115A2_set_standby
    512           * \brief	スタンバイモードに移行する
    513           * \param	
    514           * \return   0: 成功
    515           *          -1:失敗
    516           * \note	
    517           */
    518          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    519          int32_t ctrc_MPL3115A2_set_standby( void )
    520          {
   \                     ctrc_MPL3115A2_set_standby: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    521          	int32_t	ret;
    522          
    523          	ret = switch_standby();
   \   00000002   0x.... 0x....      BL       switch_standby
    524          	return ret;
   \   00000006   0xBD02             POP      {R1,PC}          ;; return
    525          }
    526          
    527          /********************************************************************/
    528          /*!
    529           * \name	ctrc_MPL3115A2_set_active
    530           * \brief	アクティブモードに移行する
    531           * \param	
    532           * \return   0: 成功
    533           *          -1:失敗
    534           * \note	
    535           */
    536          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    537          int32_t ctrc_MPL3115A2_set_active( void )
    538          {
   \                     ctrc_MPL3115A2_set_active: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    539          	int32_t	ret;
    540          
    541          	ret = switch_temp_press();
   \   00000002   0x.... 0x....      BL       switch_temp_press
    542          	return ret;
   \   00000006   0xBD02             POP      {R1,PC}          ;; return
    543          }
    544          
    545          
    546          
    547          /********************************************************************/
    548          /*!
    549           * \name	ctrc_MPL3115A2_offset_press
    550           * \brief	気圧の補正を行う
    551           *            範囲は-512 ? +508Pa、4Pa / LSBです
    552           * \param	offset : 気温のオフセット値(1カウントは4Pa)
    553           * \return   0: 成功
    554           *          -1:失敗
    555           * \note	100Pa = 1hPa
    556           */
    557          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    558          int32_t ctrc_MPL3115A2_offset_press( int8_t offset )
    559          {
   \                     ctrc_MPL3115A2_offset_press: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    560          	int32_t	ret;
    561          
    562          	ret = set_press_offset(offset);
   \   00000002   0xB240             SXTB     R0,R0
   \   00000004   0x.... 0x....      BL       set_press_offset
    563          	return ret;
   \   00000008   0xBD02             POP      {R1,PC}          ;; return
    564          }
    565          
    566          /********************************************************************/
    567          /*!
    568           * \name	ctrc_MPL3115A2_offset_temp
    569           * \brief	温度の補正を行う
    570           *            範囲は -8 ? +7.9375℃, 0.0625℃/ LSBです。
    571           * \param	offset : 気温のオフセット値(1カウントは0.0625℃)
    572           * \return   0: 成功
    573           *          -1:失敗
    574           * \note	
    575           */
    576          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    577          int32_t ctrc_MPL3115A2_offset_temp( int8_t offset )
    578          {
   \                     ctrc_MPL3115A2_offset_temp: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    579          	int32_t	ret;
    580          
    581          	ret = set_temp_offset(offset);
   \   00000002   0xB240             SXTB     R0,R0
   \   00000004   0x.... 0x....      BL       set_temp_offset
    582          	return ret;
   \   00000008   0xBD02             POP      {R1,PC}          ;; return
    583          }
    584          
    585          /********************************************************************/
    586          /*!
    587           * \name	ctrc_MPL3115A2_offset_altitude
    588           * \brief	高度の補正を行う
    589           *            範囲は -128?+ 127メートルです。1メートル/ LSBです。
    590           * \param	offset :高度のオフセット値(1カウントは1メートル)
    591           * \return   0: 成功
    592           *          -1:失敗
    593           * \note	
    594           */
    595          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    596          int32_t ctrc_MPL3115A2_offset_altitude( int8_t offset )
    597          {
   \                     ctrc_MPL3115A2_offset_altitude: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    598          	int32_t	ret;
    599          
    600          	ret = set_altitude_offset(offset);
   \   00000002   0xB240             SXTB     R0,R0
   \   00000004   0x.... 0x....      BL       set_altitude_offset
    601          	return ret;
   \   00000008   0xBD02             POP      {R1,PC}          ;; return
    602          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \   00000000   0x........         DC32     slave_addr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_1:
   \   00000000   0x........         DC32     ?_3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \   00000000   0x........         DC32     ?_4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_1:
   \   00000000   0x........         DC32     ?_5

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_2:
   \   00000000   0x........         DC32     slave_addr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_3:
   \   00000000   0x........         DC32     ?_6

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_4:
   \   00000000   0x........         DC32     ?_7

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_5:
   \   00000000   0x........         DC32     ?_8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_6:
   \   00000000   0x........         DC32     ?_10

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_7:
   \   00000000   0x........         DC32     ?_11

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_8:
   \   00000000   0x........         DC32     ?_13

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_9:
   \   00000000   0x........         DC32     ?_14

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_10:
   \   00000000   0xFFFF0000         DC32     0xffff0000

   \                                 In section .rodata, align 2
   \                     ?_0:
   \   00000000   0x13 0x07          DC8 19, 7

   \                                 In section .rodata, align 4
   \   00000000   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    

   \                                 In section .rodata, align 1
   \   00000000   0x00               DC8 0

   \                                 In section .rodata, align 2
   \                     ?_3:
   \   00000000   0x26 0x30          DC8 38, 48

   \                                 In section .rodata, align 2
   \                     ?_4:
   \   00000000   0x26 0x31          DC8 38, 49

   \                                 In section .rodata, align 2
   \                     ?_5:
   \   00000000   0x26 0xB1          DC8 38, 177

   \                                 In section .rodata, align 2
   \                     ?_6:
   \   00000000   0x2B 0x00          DC8 43, 0

   \                                 In section .rodata, align 2
   \                     ?_7:
   \   00000000   0x2C 0x00          DC8 44, 0

   \                                 In section .rodata, align 2
   \                     ?_8:
   \   00000000   0x2D 0x00          DC8 45, 0

   \                                 In section .rodata, align 4
   \   00000000   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    

   \                                 In section .rodata, align 1
   \                     ?_10:
   \   00000000   0x04               DC8 4

   \                                 In section .rodata, align 1
   \                     ?_11:
   \   00000000   0x01               DC8 1

   \                                 In section .rodata, align 4
   \   00000000   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    

   \                                 In section .rodata, align 1
   \                     ?_13:
   \   00000000   0x04               DC8 4

   \                                 In section .rodata, align 1
   \                     ?_14:
   \   00000000   0x01               DC8 1
    603          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   MPL3115A2_pt_data_cfg
        16   -> i2c0_SendData
        16   -> seSysSleepMS
      32   MPL3115A2_read_data_status
        32   -> __aeabi_memclr4
        32   -> i2c0_ReceiveData
        32   -> i2c0_SendData
        32   -> seSysSleepMS
      32   ctrc_MPL3115A2_get_altitude
        32   -> MPL3115A2_read_data_status
        32   -> __aeabi_memclr4
        32   -> i2c0_ReceiveData
        32   -> i2c0_SendData
        32   -> seSysSleepMS
        32   -> switch_temp_press
      40   ctrc_MPL3115A2_get_press
        40   -> MPL3115A2_read_data_status
        40   -> __aeabi_memclr4
        40   -> i2c0_ReceiveData
        40   -> i2c0_SendData
        40   -> seSysSleepMS
        40   -> switch_altitude
       8   ctrc_MPL3115A2_offset_altitude
         8   -> set_altitude_offset
       8   ctrc_MPL3115A2_offset_press
         8   -> set_press_offset
       8   ctrc_MPL3115A2_offset_temp
         8   -> set_temp_offset
       8   ctrc_MPL3115A2_set_active
         8   -> switch_temp_press
       8   ctrc_MPL3115A2_set_standby
         8   -> switch_standby
       8   ctrc_MPL3115A2_start
         8   -> MPL3115A2_pt_data_cfg
         8   -> switch_temp_press
      16   set_altitude_offset
        16   -> i2c0_SendData
        16   -> seSysSleepMS
      16   set_press_offset
        16   -> i2c0_SendData
        16   -> seSysSleepMS
      16   set_temp_offset
        16   -> i2c0_SendData
        16   -> seSysSleepMS
      16   switch_altitude
        16   -> i2c0_SendData
        16   -> seSysSleepMS
      16   switch_standby
        16   -> i2c0_SendData
        16   -> seSysSleepMS
      16   switch_temp_press
        16   -> i2c0_SendData
        16   -> seSysSleepMS


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable7
       4  ??DataTable8
       4  ??DataTable8_1
       4  ??DataTable9
       4  ??DataTable9_1
       4  ??DataTable9_10
       4  ??DataTable9_2
       4  ??DataTable9_3
       4  ??DataTable9_4
       4  ??DataTable9_5
       4  ??DataTable9_6
       4  ??DataTable9_7
       4  ??DataTable9_8
       4  ??DataTable9_9
       2  ?_0
      12  ?_1
       1  ?_10
       1  ?_11
      12  ?_12
       1  ?_13
       1  ?_14
       1  ?_2
       2  ?_3
       2  ?_4
       2  ?_5
       2  ?_6
       2  ?_7
       2  ?_8
      12  ?_9
      52  MPL3115A2_pt_data_cfg
      92  MPL3115A2_read_data_status
     176  ctrc_MPL3115A2_get_altitude
     288  ctrc_MPL3115A2_get_press
      10  ctrc_MPL3115A2_offset_altitude
      10  ctrc_MPL3115A2_offset_press
      10  ctrc_MPL3115A2_offset_temp
       8  ctrc_MPL3115A2_set_active
       8  ctrc_MPL3115A2_set_standby
      16  ctrc_MPL3115A2_start
      54  set_altitude_offset
      54  set_press_offset
      54  set_temp_offset
       1  slave_addr
      50  switch_altitude
      50  switch_standby
      50  switch_temp_press

 
     1 byte  in section .data
    55 bytes in section .rodata
 1 038 bytes in section .text
 
 1 038 bytes of CODE  memory
    55 bytes of CONST memory
     1 byte  of DATA  memory

Errors: none
Warnings: none
