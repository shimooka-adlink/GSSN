###############################################################################
#
# IAR ANSI C/C++ Compiler V7.80.4.12462/W32 for ARM       21/May/2019  17:01:04
# Copyright 1999-2017 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  C:\GNSS\Software\rJ105\source\GNSS_GW\apl\man_usb.c
#    Command line =  
#        C:\GNSS\Software\rJ105\source\GNSS_GW\apl\man_usb.c -D
#        __TARGET_ARCH_7_M -D S1C31W74 -D GNSS_GW_SIDE_A -lCN
#        C:\GNSS\Software\rJ105\source\GNSS_GW\board\S5U1C31W74T1\IAR\DebugFlash\List
#        -lA
#        C:\GNSS\Software\rJ105\source\GNSS_GW\board\S5U1C31W74T1\IAR\DebugFlash\List
#        --diag_suppress Pe177,Pe111,Pa082 -o
#        C:\GNSS\Software\rJ105\source\GNSS_GW\board\S5U1C31W74T1\IAR\DebugFlash\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M0+ -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.5\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\GNSS\Software\rJ105\source\GNSS_GW\board\S5U1C31W74T1\IAR\ -I
#        C:\GNSS\Software\rJ105\source\GNSS_GW\board\S5U1C31W74T1\IAR\..\..\..\
#        -I "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.5\arm\CMSIS\Include\" -I "C:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 7.5\arm\inc\Epson\" -I
#        C:\GNSS\Software\rJ105\source\GNSS_GW\board\S5U1C31W74T1\IAR\..\..\..\..\..\CMSIS\Device\S1C31W74\Include\
#        -I
#        C:\GNSS\Software\rJ105\source\GNSS_GW\board\S5U1C31W74T1\IAR\..\..\..\..\..\CMSIS\Driver\Include\
#        -I
#        C:\GNSS\Software\rJ105\source\GNSS_GW\board\S5U1C31W74T1\IAR\..\..\..\..\..\sePeriphLibrary\
#        -I
#        C:\GNSS\Software\rJ105\source\GNSS_GW\board\S5U1C31W74T1\IAR\..\..\..\..\..\board\S5U1C31W74T1\
#        -I
#        C:\GNSS\Software\rJ105\source\GNSS_GW\board\S5U1C31W74T1\IAR\..\..\..\..\..\USBStack\INC\
#        -I
#        C:\GNSS\Software\rJ105\source\GNSS_GW\board\S5U1C31W74T1\IAR\..\..\..\include\
#        -Ol
#    Locale       =  Japanese_Japan.932
#    List file    =  
#        C:\GNSS\Software\rJ105\source\GNSS_GW\board\S5U1C31W74T1\IAR\DebugFlash\List\man_usb.lst
#    Object file  =  
#        C:\GNSS\Software\rJ105\source\GNSS_GW\board\S5U1C31W74T1\IAR\DebugFlash\Obj\man_usb.o
#
###############################################################################

C:\GNSS\Software\rJ105\source\GNSS_GW\apl\man_usb.c
      1          
      2          /**
      3            ******************************************************************************
      4            * @file    man_usb.c
      5            * @author  コア
      6            * @version V1.0
      7            * @date    2017.10.2
      8            * @brief   シリアルUSBを管理する
      9            ******************************************************************************
     10            $Id: man_usb.c 255 2018-08-01 07:28:31Z shitaoka $
     11            * @attention
     12            *
     13            *****************************************************************************
     14          */
     15          
     16          #include <string.h>
     17          #include <stdio.h>
     18          #include <stdlib.h>
     19          
     20          #include "system_manager.h"
     21          #include "board.h"
     22          #include "man_data.h"
     23          #include "man_cmd.h"
     24          #include "man_timer.h"
     25          #include "man_ope.h"
     26          #include "man_usb.h"
     27          #include "man_error.h"
     28          #include "gnss_gw_common.h"
     29          #include "ctrl_USB.h"
     30          
     31          
     32          #pragma section = "APL_PRG_BLOCK"
     33          

   \                                 In section .bss, align 4
     34          uint32_t usb_log_flag;
   \                     usb_log_flag:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     35          uint32_t usb_console_flag;
   \                     usb_console_flag:
   \   00000000                      DS8 4
     36          
     37          /************************************************************************/
     38          /* declaration of structure                                             */
     39          /************************************************************************/
     40          
     41          #define		MAN_USB_ID_TIMEOUT			1			// 時間経過
     42          #define		MAN_USB_ID_USB_SEND			2			// USB SEND応答
     43          
     44          #define		MAN_USB_TIME_SEND_TIMEOUT	400			// 400ms経過しても送信できない場合
     45          
     46          #define		MAN_USB_RECV_DATA_MAX		2048		// 受信データバッファ
     47          #define		MAN_USB_SEND_DATA_MAX		1024		// 送信データバッファ
     48          
     49          // コマンド受付管理状態
     50          typedef enum {
     51          	MAN_USB_CMD_STOP,				    // コマンド受付停止
     52          	MAN_USB_CMD_START,			    	// コマンド受付開始
     53          } man_usb_cmd_mode_def;
     54          
     55          
     56          // OTAコマンド
     57          typedef enum {
     58          	MAN_USB_OTA_CMD_READY,
     59          	MAN_USB_OTA_CMD_FILE_GET,
     60          	MAN_USB_OTA_CMD_DATA_GET,
     61          } man_usb_ota_cmd_def;
     62          
     63          
     64          // OTAシーケンス
     65          typedef enum {
     66          	MAN_USB_OTA_SEQ_READY,					// 00 : 要求待ち
     67          	MAN_USB_OTA_SEQ_SEND_FILE_INFO_REQ,		// 01 : 取得ファイル情報送信
     68          	MAN_USB_OTA_SEQ_SEND_FILE_INFO,			// 02 : 取得ファイル情報送信中
     69          	MAN_USB_OTA_SEQ_SEND_FILE_INFO_OK,		// 03 : 取得ファイル情報送信成功
     70          	MAN_USB_OTA_SEQ_SEND_FILE_INFO_NG,		// 04 : 取得ファイル情報送信失敗
     71          	MAN_USB_OTA_SEQ_GET_DATA_REQ,			// 05 : 取得ファイル情報送信
     72          	MAN_USB_OTA_SEQ_GET_DATA,				// 06 : 取得ファイル情報送信中
     73          	MAN_USB_OTA_SEQ_GET_DATA_OK,			// 07 : 取得ファイル情報送信成功
     74          	MAN_USB_OTA_SEQ_GET_DATA_NG,			// 08 : 取得ファイル情報送信失敗
     75          } man_usb_ota_seq_def;
     76          
     77          // 受信データ
     78          typedef struct _man_usb_recv_t {
     79          	int32_t					flag;								// データ受信フラグ(1:受信済み)
     80          	uint8_t					data[MAN_USB_RECV_DATA_MAX];		// 受信データ
     81          	int32_t					length;								// データ長
     82          	int32_t					id;									// ID
     83          } man_usb_recv_t;
     84          
     85          // RPT要求
     86          typedef struct _man_usb_rpt_info_t {
     87          	int32_t					flag;				// 要求 0: なし  1: あり
     88          
     89          	int32_t					id;					// ユニークID
     90          	func_man_usb			callback;			// 結果を通知するcallback関数
     91          
     92          	uint8_t					*data;
     93          	int32_t					length;
     94          
     95          	int32_t					snd_len;			// 送信データ数
     96          } man_usb_rpt_info_t;
     97          
     98          // 要求に対する応答
     99          typedef struct _man_usb_resp_cmd_t {
    100          	int32_t					flag;
    101          	int32_t					id;
    102          	int32_t					status;
    103          } man_usb_resp_cmd_t;
    104          
    105          
    106          // OTA情報
    107          typedef struct _man_usb_ota_info_t {
    108          	int32_t					ota_flag;
    109          	man_usb_ota_cmd_def		req_ota_cmd;		// 要求コマンド
    110          	man_usb_ota_seq_def		sequense;			// シーケンス
    111          
    112          	int32_t					file_num;			// ファイル番号
    113          	int32_t					data_size_max;		// 一度に受信するデータサイズ(最大値)
    114          
    115          	int32_t					rcv_file_size;		// 通知されたファイルサイズ
    116          	int32_t					rcv_data_size;		// 通知されたデータサイズ
    117          
    118          	int32_t					id;					// ユニークID
    119          	func_man_usb			callback;			// 結果を通知するcallback関数
    120          	func_man_usb_data		callback_data;		// データを通知するcallback関数
    121          
    122          	man_usb_set_file_info_t	set_file_info;
    123          	man_usb_get_file_info_t	get_file_info;
    124          	
    125          	int32_t					rcv_data_wp;
    126          	uint8_t					snd_data[MAN_USB_SEND_DATA_MAX];
    127          	uint8_t					rcv_data[MAN_USB_RECV_DATA_MAX];
    128          } man_usb_ota_info_t;
    129          
    130          // USB管理ワーク
    131          typedef struct _man_gps_work_t {
    132          	int32_t					usb_used;			// USB使用状態(0:使用不可能  1: 使用可能)
    133          	man_usb_recv_t			recv_data;			// 受信したデータ
    134          	man_usb_resp_cmd_t		resp_cmd;			// 要求に対する応答
    135          	man_usb_rpt_info_t		rpt_info;			// RPT情報
    136          
    137          	man_usb_cmd_mode_def	cmd_mode;			// コマンド受付管理状態
    138          	man_usb_ota_info_t		ota_info;			// OTA情報
    139          	uint32_t				delay_timer;		// 時間監視
    140          	uint8_t					buff[10];
    141          } man_usb_work_t;
    142          
    143          //応答テーブル
    144          
    145          /************************************************************************/
    146          /* definition of variables                                              */
    147          /************************************************************************/
    148          

   \                                 In section .bss, align 4
    149          man_usb_work_t	man_usb_work;
   \                     man_usb_work:
   \   00000000                      DS8 5368

   \                                 In section .bss, align 4
    150          uint8_t respons[MAN_DATA_CMD_LEN_MAX];
   \                     respons:
   \   00000000                      DS8 672
    151          
    152          
    153          /********************************************************************/
    154          /*	callback関数                                                    */
    155          /********************************************************************/
    156          
    157          /********************************************************************/
    158          /*!
    159           * \name	man_usb_callback
    160           * \brief	USBデータ受信通知用callback処理
    161           * \param	data   : 受信データ
    162           *          length : データ長
    163           *          id     : ユニークID
    164           *          status : 受信結果
    165           * \return  なし
    166           * \note	
    167           */
    168          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    169          static void man_usb_callback(uint8_t *data, int32_t length, int32_t id, int32_t status)
    170          {
   \                     man_usb_callback: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x000C             MOVS     R4,R1
   \   00000004   0x0015             MOVS     R5,R2
    171          	if ( (data != NULL) && (status == CTRL_USB_STATUS_OK) && (length > 0) && (length <= MAN_USB_RECV_DATA_MAX) ) {
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD014             BEQ      ??man_usb_callback_0
   \   0000000A   0x2B00             CMP      R3,#+0
   \   0000000C   0xD112             BNE      ??man_usb_callback_0
   \   0000000E   0x0021             MOVS     R1,R4
   \   00000010   0x1E49             SUBS     R1,R1,#+1
   \   00000012   0x2280             MOVS     R2,#+128
   \   00000014   0x0112             LSLS     R2,R2,#+4        ;; #+2048
   \   00000016   0x4291             CMP      R1,R2
   \   00000018   0xD20C             BCS      ??man_usb_callback_0
    172          		// 受信データの保存
    173          		memcpy(&man_usb_work.recv_data.data[0], data, length);
   \   0000001A   0x....             LDR      R6,??DataTable5
   \   0000001C   0x0022             MOVS     R2,R4
   \   0000001E   0x0001             MOVS     R1,R0
   \   00000020   0x0030             MOVS     R0,R6
   \   00000022   0x.... 0x....      BL       __aeabi_memcpy
    174          		man_usb_work.recv_data.length = length;
   \   00000026   0x....             LDR      R0,??DataTable5_1
   \   00000028   0x6004             STR      R4,[R0, #+0]
    175          		man_usb_work.recv_data.id = id;
   \   0000002A   0x....             LDR      R0,??DataTable5_2
   \   0000002C   0x6005             STR      R5,[R0, #+0]
    176          
    177          		// 受信あり
    178          		man_usb_work.recv_data.flag = 1;
   \   0000002E   0x2001             MOVS     R0,#+1
   \   00000030   0x....             LDR      R1,??DataTable5_3
   \   00000032   0x6048             STR      R0,[R1, #+4]
    179          	}
    180          }
   \                     ??man_usb_callback_0: (+1)
   \   00000034   0xBD70             POP      {R4-R6,PC}       ;; return
    181          
    182          
    183          /********************************************************************/
    184          /*!
    185           * \name	man_usb_req_callback
    186           * \brief	要求に対するcallback処理
    187           * \param	id     : ユニークID
    188           *          status : 受信結果
    189           * \return  なし
    190           * \note	
    191           */
    192          /********************************************************************/
    193          static void man_usb_req_callback(int32_t id, int32_t status)
    194          {
    195          	man_usb_work.resp_cmd.flag = 1;
    196          	man_usb_work.resp_cmd.id = id & TIMER_MAN_ID_MASK;
    197          	man_usb_work.resp_cmd.status = status;
    198          }
    199          
    200          /********************************************************************/
    201          /*	static関数                                                      */
    202          /********************************************************************/
    203          
    204          /********************************************************************/
    205          /*!
    206           * \name	man_usb_set_sequense
    207           * \brief	シーケンスを設定する
    208           * \param	sequense : 設定するシーケンス
    209           * \return  なし
    210           * \note	
    211           */
    212          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    213          static void man_usb_set_sequense( man_usb_ota_seq_def sequense )
    214          {
   \                     man_usb_set_sequense: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    215          	if (man_usb_work.ota_info.sequense != sequense) {
   \   00000002   0x....             LDR      R1,??DataTable5_4
   \   00000004   0x7809             LDRB     R1,[R1, #+0]
   \   00000006   0x0002             MOVS     R2,R0
   \   00000008   0xB2D2             UXTB     R2,R2
   \   0000000A   0x4291             CMP      R1,R2
   \   0000000C   0xD007             BEQ      ??man_usb_set_sequense_0
    216          		man_usb_work.ota_info.sequense = sequense;
   \   0000000E   0x....             LDR      R1,??DataTable5_4
   \   00000010   0x7008             STRB     R0,[R1, #+0]
    217          
    218          		// デバックログに登録 
    219          		man_dbglog_setting(MAN_ERROR_DBG_MAN_USB, MAN_ERROR_DBG_TYPE_SEQ, sequense);
   \   00000012   0xB2C0             UXTB     R0,R0
   \   00000014   0x0002             MOVS     R2,R0
   \   00000016   0x2101             MOVS     R1,#+1
   \   00000018   0x200A             MOVS     R0,#+10
   \   0000001A   0x.... 0x....      BL       man_dbglog_setting
    220          	}
    221          }
   \                     ??man_usb_set_sequense_0: (+1)
   \   0000001E   0xBD01             POP      {R0,PC}          ;; return
    222          
    223          /********************************************************************/
    224          /*!
    225           * \name	man_usb_return_callback
    226           * \brief	callback応答を返す処理
    227           * \param	status : 通知するステータス
    228           * \return  なし
    229           * \note	
    230           */
    231          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    232          static void man_usb_return_callback( int32_t status )
    233          {
   \                     man_usb_return_callback: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    234          	// callback関数で終了通知
    235          	if (man_usb_work.ota_info.callback != NULL) {
   \   00000002   0x....             LDR      R1,??DataTable5_5
   \   00000004   0x6809             LDR      R1,[R1, #+0]
   \   00000006   0x2900             CMP      R1,#+0
   \   00000008   0xD008             BEQ      ??man_usb_return_callback_0
    236          		man_usb_work.ota_info.callback(man_usb_work.ota_info.id, status);
   \   0000000A   0x0001             MOVS     R1,R0
   \   0000000C   0x....             LDR      R0,??DataTable5_6
   \   0000000E   0x6800             LDR      R0,[R0, #+0]
   \   00000010   0x....             LDR      R2,??DataTable5_5
   \   00000012   0x6812             LDR      R2,[R2, #+0]
   \   00000014   0x4790             BLX      R2
    237          		man_usb_work.ota_info.callback = NULL;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x....             LDR      R1,??DataTable5_5
   \   0000001A   0x6008             STR      R0,[R1, #+0]
    238          	}
    239          	man_usb_set_sequense(MAN_USB_OTA_SEQ_READY);
   \                     ??man_usb_return_callback_0: (+1)
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0x.... 0x....      BL       man_usb_set_sequense
    240          	man_usb_work.ota_info.req_ota_cmd = MAN_USB_OTA_CMD_READY;
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0x....             LDR      R1,??DataTable5_7
   \   00000026   0x7008             STRB     R0,[R1, #+0]
    241          }
   \   00000028   0xBD01             POP      {R0,PC}          ;; return
    242          
    243          
    244          /********************************************************************/
    245          /*!
    246           * \name	man_usb_return_callback_data
    247           * \brief	callback_data応答を返す処理
    248           * \param	status : 通知するステータス
    249           * \return  なし
    250           * \note	
    251           */
    252          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    253          static void man_usb_return_callback_data( int32_t status )
    254          {
   \                     man_usb_return_callback_data: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    255          	// callback関数で終了通知
    256          	if (man_usb_work.ota_info.callback_data != NULL) {
   \   00000002   0x....             LDR      R1,??DataTable5_8
   \   00000004   0x6809             LDR      R1,[R1, #+0]
   \   00000006   0x2900             CMP      R1,#+0
   \   00000008   0xD00B             BEQ      ??man_usb_return_callback_data_0
    257          		man_usb_work.ota_info.callback_data(&man_usb_work.ota_info.rcv_data[0], man_usb_work.ota_info.rcv_data_wp, man_usb_work.ota_info.id, status);
   \   0000000A   0x0003             MOVS     R3,R0
   \   0000000C   0x....             LDR      R0,??DataTable5_6
   \   0000000E   0x6802             LDR      R2,[R0, #+0]
   \   00000010   0x....             LDR      R0,??DataTable5_9
   \   00000012   0x6801             LDR      R1,[R0, #+0]
   \   00000014   0x....             LDR      R0,??DataTable5_10
   \   00000016   0x....             LDR      R4,??DataTable5_8
   \   00000018   0x6824             LDR      R4,[R4, #+0]
   \   0000001A   0x47A0             BLX      R4
    258          		man_usb_work.ota_info.callback_data = NULL;
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0x....             LDR      R1,??DataTable5_8
   \   00000020   0x6008             STR      R0,[R1, #+0]
    259          	}
    260          	man_usb_set_sequense(MAN_USB_OTA_SEQ_READY);
   \                     ??man_usb_return_callback_data_0: (+1)
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0x.... 0x....      BL       man_usb_set_sequense
    261          	man_usb_work.ota_info.req_ota_cmd = MAN_USB_OTA_CMD_READY;
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0x....             LDR      R1,??DataTable5_7
   \   0000002C   0x7008             STRB     R0,[R1, #+0]
    262          }
   \   0000002E   0xBD10             POP      {R4,PC}          ;; return
    263          
    264          
    265          
    266          /********************************************************************/
    267          /*!
    268           * \name	man_usb_chk_config
    269           * \brief	USBデバイスの設定を確認する
    270           * \param	なし
    271           * \return  なし
    272           * \note	設定後はUSBの使用が可能となります
    273           */
    274          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    275          static void man_usb_chk_config( void )
    276          {
   \                     man_usb_chk_config: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    277          	int32_t	ret;
    278          	
    279          	ret = ctrl_USB_chk_config();
   \   00000002   0x.... 0x....      BL       ctrl_USB_chk_config
    280          	if (ret >= 0) {
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD403             BMI      ??man_usb_chk_config_0
    281          		man_usb_work.usb_used = 1;
   \   0000000A   0x2001             MOVS     R0,#+1
   \   0000000C   0x....             LDR      R1,??DataTable5_3
   \   0000000E   0x6008             STR      R0,[R1, #+0]
   \   00000010   0xE002             B        ??man_usb_chk_config_1
    282          	}
    283          	else {
    284          		man_usb_work.usb_used = 0;
   \                     ??man_usb_chk_config_0: (+1)
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x....             LDR      R1,??DataTable5_3
   \   00000016   0x6008             STR      R0,[R1, #+0]
    285          	}
    286          }
   \                     ??man_usb_chk_config_1: (+1)
   \   00000018   0xBD01             POP      {R0,PC}          ;; return
    287          
    288          
    289          /********************************************************************/
    290          /*	extern関数                                                      */
    291          /********************************************************************/
    292          
    293          /********************************************************************/
    294          /*!
    295           * \name	man_usb_init
    296           * \brief	USB管理の初期化処理
    297           * \param	なし
    298           * \return   0: 正常
    299           *          -1: 異常
    300           * \note	起動時に、呼ばれること
    301           */
    302          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    303          int32_t man_usb_init(void)
    304          {
   \                     man_usb_init: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    305          	int32_t	ret=0;
   \   00000002   0x2400             MOVS     R4,#+0
    306          
    307          	// USB初期化処理
    308          #if 1
    309                  man_usb_req_reset();
   \   00000004   0x.... 0x....      BL       man_usb_req_reset
    310                  seSysSleepMS(200);
   \   00000008   0x20C8             MOVS     R0,#+200
   \   0000000A   0x.... 0x....      BL       seSysSleepMS
    311          #endif
    312                  ret = ctrl_USB_init();
   \   0000000E   0x.... 0x....      BL       ctrl_USB_init
   \   00000012   0x0004             MOVS     R4,R0
    313          
    314          	// 内部変数を初期化する
    315          	memset(&man_usb_work, 0, sizeof(man_usb_work_t));
   \   00000014   0x....             LDR      R1,??DataTable5_11  ;; 0x14f8
   \   00000016   0x2200             MOVS     R2,#+0
   \   00000018   0x....             LDR      R5,??DataTable5_3
   \   0000001A   0x0028             MOVS     R0,R5
   \   0000001C   0x.... 0x....      BL       __aeabi_memset
    316          	memset(&respons[0], 0, MAN_DATA_CMD_LEN_MAX);
   \   00000020   0x....             LDR      R1,??DataTable5_12  ;; 0x29e
   \   00000022   0x2200             MOVS     R2,#+0
   \   00000024   0x....             LDR      R5,??DataTable5_13
   \   00000026   0x0028             MOVS     R0,R5
   \   00000028   0x.... 0x....      BL       __aeabi_memset
    317          
    318          	// USB受信開始処理
    319          	ctrl_USB_recv_start(1, man_usb_callback);
   \   0000002C   0x....             LDR      R1,??DataTable5_14
   \   0000002E   0x2001             MOVS     R0,#+1
   \   00000030   0x.... 0x....      BL       ctrl_USB_recv_start
    320          
    321          	return ret;
   \   00000034   0x0020             MOVS     R0,R4
   \   00000036   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    322          }
    323          
    324          
    325          
    326          /********************************************************************/
    327          /*!
    328           * \name	man_usb_main
    329           * \brief	USB管理のmain処理
    330           * \param	なし
    331           * \return  なし
    332           * \note	毎回、呼ばれること
    333           */
    334          /********************************************************************/

   \                                 In section .text, align 4, keep-with-next
    335          void man_usb_main(void)
    336          {
   \                     man_usb_main: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB088             SUB      SP,SP,#+32
    337          	man_usb_rpt_info_t	*rpt_info = &man_usb_work.rpt_info;
   \   00000004   0x4898             LDR      R0,??man_usb_main_0
    338          	int32_t				length;
    339          	char 				buf[] = "debugcmd";
   \   00000006   0xA804             ADD      R0,SP,#+16
   \   00000008   0x4998             LDR      R1,??man_usb_main_0+0x4
   \   0000000A   0xC91C             LDM      R1!,{R2-R4}
   \   0000000C   0xC01C             STM      R0!,{R2-R4}
   \   0000000E   0x390C             SUBS     R1,R1,#+12
   \   00000010   0x380C             SUBS     R0,R0,#+12
    340          	char				ota_file[] = "OK,";
   \   00000012   0xA801             ADD      R0,SP,#+4
   \   00000014   0x4996             LDR      R1,??man_usb_main_0+0x8
   \   00000016   0x680A             LDR      R2,[R1, #0]
   \   00000018   0x6002             STR      R2,[R0, #0]
    341          	char				ota_data[] = "DATA,";
   \   0000001A   0xA802             ADD      R0,SP,#+8
   \   0000001C   0x4995             LDR      R1,??man_usb_main_0+0xC
   \   0000001E   0xC90C             LDM      R1!,{R2,R3}
   \   00000020   0xC00C             STM      R0!,{R2,R3}
   \   00000022   0x3908             SUBS     R1,R1,#+8
   \   00000024   0x3808             SUBS     R0,R0,#+8
    342          	uint8_t				*data;
    343          	int32_t				data_len;
    344          	int32_t				ret;
    345          	int32_t				i;
    346          	uint32_t			delay_timer;		// 時間監視
    347          
    348          
    349          
    350          	// ******************************************************
    351          	// 受信データ処理
    352          	// ******************************************************
    353          	if (man_usb_work.recv_data.flag == 1) {
   \   00000026   0x4894             LDR      R0,??man_usb_main_0+0x10
   \   00000028   0x6840             LDR      R0,[R0, #+4]
   \   0000002A   0x2801             CMP      R0,#+1
   \   0000002C   0xD000             BEQ      .+4
   \   0000002E   0xE0EF             B        ??man_usb_main_1
    354          		man_usb_work.recv_data.flag = 0;
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0x4991             LDR      R1,??man_usb_main_0+0x10
   \   00000034   0x6048             STR      R0,[R1, #+4]
    355          
    356          		// 通常時
    357          		if (man_usb_work.ota_info.ota_flag == 0) {
   \   00000036   0x4891             LDR      R0,??man_usb_main_0+0x14
   \   00000038   0x6800             LDR      R0,[R0, #+0]
   \   0000003A   0x2800             CMP      R0,#+0
   \   0000003C   0xD133             BNE      ??man_usb_main_2
    358          			// コマンドの受付が許可されている場合のみ実施
    359          			// "debugcmd"コマンドは常に有効とする
    360          			if ( (man_usb_work.cmd_mode == MAN_USB_CMD_START) || (memcmp(&man_usb_work.recv_data.data[0], buf, strlen((const char *)buf)) == 0 ) ) {
   \   0000003E   0x4890             LDR      R0,??man_usb_main_0+0x18
   \   00000040   0x7800             LDRB     R0,[R0, #+0]
   \   00000042   0x2801             CMP      R0,#+1
   \   00000044   0xD00A             BEQ      ??man_usb_main_3
   \   00000046   0xA804             ADD      R0,SP,#+16
   \   00000048   0x.... 0x....      BL       strlen
   \   0000004C   0x0002             MOVS     R2,R0
   \   0000004E   0xA904             ADD      R1,SP,#+16
   \   00000050   0x488C             LDR      R0,??man_usb_main_0+0x1C
   \   00000052   0x.... 0x....      BL       memcmp
   \   00000056   0x2800             CMP      R0,#+0
   \   00000058   0xD000             BEQ      .+4
   \   0000005A   0xE0D9             B        ??man_usb_main_1
    361          				// リセット中は対応しない
    362          				if (man_ope_get_reset_mode() == 0) {
   \                     ??man_usb_main_3: (+1)
   \   0000005C   0x.... 0x....      BL       man_ope_get_reset_mode
   \   00000060   0x2800             CMP      R0,#+0
   \   00000062   0xD000             BEQ      .+4
   \   00000064   0xE0D4             B        ??man_usb_main_1
    363          					// データが存在すれば、解析する(CR+LFは除く)
    364          					if ((man_usb_work.recv_data.length-2) > 0) {
   \   00000066   0x4888             LDR      R0,??man_usb_main_0+0x20
   \   00000068   0x6800             LDR      R0,[R0, #+0]
   \   0000006A   0x1E80             SUBS     R0,R0,#+2
   \   0000006C   0x2801             CMP      R0,#+1
   \   0000006E   0xDA00             BGE      .+4
   \   00000070   0xE0CE             B        ??man_usb_main_1
    365          						man_cmd_analyze(MAN_CMD_ANALYZE_USB, &man_usb_work.recv_data.data[0], (man_usb_work.recv_data.length - 2), &respons[0], MAN_DATA_CMD_LEN_MAX);
   \   00000072   0x4886             LDR      R0,??man_usb_main_0+0x24  ;; 0x29e
   \   00000074   0x9000             STR      R0,[SP, #+0]
   \   00000076   0x4B86             LDR      R3,??man_usb_main_0+0x28
   \   00000078   0x4883             LDR      R0,??man_usb_main_0+0x20
   \   0000007A   0x6802             LDR      R2,[R0, #+0]
   \   0000007C   0x1E92             SUBS     R2,R2,#+2
   \   0000007E   0x4981             LDR      R1,??man_usb_main_0+0x1C
   \   00000080   0x2001             MOVS     R0,#+1
   \   00000082   0x.... 0x....      BL       man_cmd_analyze
    366          						length = strlen((char const *)&respons[0]);
   \   00000086   0x4882             LDR      R0,??man_usb_main_0+0x28
   \   00000088   0x.... 0x....      BL       strlen
   \   0000008C   0x0001             MOVS     R1,R0
    367          						respons[length] = ASCII_CR;
   \   0000008E   0x200D             MOVS     R0,#+13
   \   00000090   0x4A7F             LDR      R2,??man_usb_main_0+0x28
   \   00000092   0x5450             STRB     R0,[R2, R1]
    368          						respons[length+1] = ASCII_LF;
   \   00000094   0x200A             MOVS     R0,#+10
   \   00000096   0x4A7E             LDR      R2,??man_usb_main_0+0x28
   \   00000098   0x1852             ADDS     R2,R2,R1
   \   0000009A   0x7050             STRB     R0,[R2, #+1]
    369          						length += 2;
   \   0000009C   0x1C89             ADDS     R1,R1,#+2
    370          						man_usb_data_send(&respons[0], length);
   \   0000009E   0x487C             LDR      R0,??man_usb_main_0+0x28
   \   000000A0   0x.... 0x....      BL       man_usb_data_send
   \   000000A4   0xE0B4             B        ??man_usb_main_1
    371          					}
    372          				}
    373          			}
    374          		}
    375          
    376          
    377          		// OTA実行中
    378          		else {
    379          			// "OK,10476309"
    380          			if (memcmp(&man_usb_work.recv_data.data[0], ota_file, strlen((const char *)ota_file)) == 0 ) {
   \                     ??man_usb_main_2: (+1)
   \   000000A6   0xA801             ADD      R0,SP,#+4
   \   000000A8   0x.... 0x....      BL       strlen
   \   000000AC   0x0002             MOVS     R2,R0
   \   000000AE   0xA901             ADD      R1,SP,#+4
   \   000000B0   0x4874             LDR      R0,??man_usb_main_0+0x1C
   \   000000B2   0x.... 0x....      BL       memcmp
   \   000000B6   0x2800             CMP      R0,#+0
   \   000000B8   0xD131             BNE      ??man_usb_main_4
    381          				ret = 0;
   \   000000BA   0x2000             MOVS     R0,#+0
    382          				data_len = 0;
   \   000000BC   0x2100             MOVS     R1,#+0
    383          				for (i=3; i<man_usb_work.recv_data.length-2; i++) {
   \   000000BE   0x2203             MOVS     R2,#+3
   \   000000C0   0xE007             B        ??man_usb_main_5
    384          					if ( ('0' <= man_usb_work.recv_data.data[i]) && (man_usb_work.recv_data.data[i] <= '9') ) {
    385          						data_len *= 10;
   \                     ??man_usb_main_6: (+1)
   \   000000C2   0x230A             MOVS     R3,#+10
   \   000000C4   0x4359             MULS     R1,R3,R1
    386          						data_len += man_usb_work.recv_data.data[i]-'0';
   \   000000C6   0x4B6C             LDR      R3,??man_usb_main_0+0x10
   \   000000C8   0x189B             ADDS     R3,R3,R2
   \   000000CA   0x7A1B             LDRB     R3,[R3, #+8]
   \   000000CC   0x3B30             SUBS     R3,R3,#+48
   \   000000CE   0x18C9             ADDS     R1,R1,R3
    387          					}
   \   000000D0   0x1C52             ADDS     R2,R2,#+1
   \                     ??man_usb_main_5: (+1)
   \   000000D2   0x4B6D             LDR      R3,??man_usb_main_0+0x20
   \   000000D4   0x681B             LDR      R3,[R3, #+0]
   \   000000D6   0x1E9B             SUBS     R3,R3,#+2
   \   000000D8   0x429A             CMP      R2,R3
   \   000000DA   0xDA07             BGE      ??man_usb_main_7
   \   000000DC   0x4B66             LDR      R3,??man_usb_main_0+0x10
   \   000000DE   0x189B             ADDS     R3,R3,R2
   \   000000E0   0x7A1B             LDRB     R3,[R3, #+8]
   \   000000E2   0x3B30             SUBS     R3,R3,#+48
   \   000000E4   0x2B0A             CMP      R3,#+10
   \   000000E6   0xD3EC             BCC      ??man_usb_main_6
    388          					else {
    389          						ret = -1;
   \   000000E8   0x2000             MOVS     R0,#+0
   \   000000EA   0x43C0             MVNS     R0,R0            ;; #-1
    390          						break;
    391          					}
    392          				}
    393          				if ( (ret == 0) && (data_len > 0) ) {
   \                     ??man_usb_main_7: (+1)
   \   000000EC   0x2800             CMP      R0,#+0
   \   000000EE   0xD10E             BNE      ??man_usb_main_8
   \   000000F0   0x2901             CMP      R1,#+1
   \   000000F2   0xDB0C             BLT      ??man_usb_main_8
    394          					if (man_usb_work.ota_info.sequense == MAN_USB_OTA_SEQ_SEND_FILE_INFO) {
   \   000000F4   0x....             LDR      R0,??DataTable6
   \   000000F6   0x7800             LDRB     R0,[R0, #+0]
   \   000000F8   0x2802             CMP      R0,#+2
   \   000000FA   0xD000             BEQ      .+4
   \   000000FC   0xE088             B        ??man_usb_main_1
    395          						man_usb_work.ota_info.rcv_file_size = data_len;
   \   000000FE   0x....             LDR      R0,??DataTable6_1
   \   00000100   0x6001             STR      R1,[R0, #+0]
    396          						man_usb_work.ota_info.get_file_info.file_size = data_len;
   \   00000102   0x....             LDR      R0,??DataTable9
   \   00000104   0x6001             STR      R1,[R0, #+0]
    397          						man_usb_set_sequense(MAN_USB_OTA_SEQ_SEND_FILE_INFO_OK);
   \   00000106   0x2003             MOVS     R0,#+3
   \   00000108   0x.... 0x....      BL       man_usb_set_sequense
   \   0000010C   0xE080             B        ??man_usb_main_1
    398          					}
    399          				}
    400          				else {
    401          					if (man_usb_work.ota_info.sequense == MAN_USB_OTA_SEQ_SEND_FILE_INFO) {
   \                     ??man_usb_main_8: (+1)
   \   0000010E   0x....             LDR      R0,??DataTable6
   \   00000110   0x7800             LDRB     R0,[R0, #+0]
   \   00000112   0x2802             CMP      R0,#+2
   \   00000114   0xD17C             BNE      ??man_usb_main_1
    402          						man_usb_set_sequense(MAN_USB_OTA_SEQ_SEND_FILE_INFO_NG);
   \   00000116   0x2004             MOVS     R0,#+4
   \   00000118   0x.... 0x....      BL       man_usb_set_sequense
   \   0000011C   0xE078             B        ??man_usb_main_1
    403          					}
    404          				}
    405          			}
    406          			
    407          			// "DATA,4096"
    408          			else if (memcmp(&man_usb_work.recv_data.data[0], ota_data, strlen((const char *)ota_data)) == 0 ) {
   \                     ??man_usb_main_4: (+1)
   \   0000011E   0xA802             ADD      R0,SP,#+8
   \   00000120   0x.... 0x....      BL       strlen
   \   00000124   0x0002             MOVS     R2,R0
   \   00000126   0xA902             ADD      R1,SP,#+8
   \   00000128   0x4856             LDR      R0,??man_usb_main_0+0x1C
   \   0000012A   0x.... 0x....      BL       memcmp
   \   0000012E   0x2800             CMP      R0,#+0
   \   00000130   0xD13D             BNE      ??man_usb_main_9
    409          				ret = 0;
   \   00000132   0x2000             MOVS     R0,#+0
    410          				data_len = 0;
   \   00000134   0x2100             MOVS     R1,#+0
    411          				for (i=5; i<man_usb_work.recv_data.length-2; i++) {
   \   00000136   0x2205             MOVS     R2,#+5
   \   00000138   0xE007             B        ??man_usb_main_10
    412          					if ( ('0' <= man_usb_work.recv_data.data[i]) && (man_usb_work.recv_data.data[i] <= '9') ) {
    413          						data_len *= 10;
   \                     ??man_usb_main_11: (+1)
   \   0000013A   0x230A             MOVS     R3,#+10
   \   0000013C   0x4359             MULS     R1,R3,R1
    414          						data_len += man_usb_work.recv_data.data[i]-'0';
   \   0000013E   0x4B4E             LDR      R3,??man_usb_main_0+0x10
   \   00000140   0x189B             ADDS     R3,R3,R2
   \   00000142   0x7A1B             LDRB     R3,[R3, #+8]
   \   00000144   0x3B30             SUBS     R3,R3,#+48
   \   00000146   0x18C9             ADDS     R1,R1,R3
    415          					}
   \   00000148   0x1C52             ADDS     R2,R2,#+1
   \                     ??man_usb_main_10: (+1)
   \   0000014A   0x4B4F             LDR      R3,??man_usb_main_0+0x20
   \   0000014C   0x681B             LDR      R3,[R3, #+0]
   \   0000014E   0x1E9B             SUBS     R3,R3,#+2
   \   00000150   0x429A             CMP      R2,R3
   \   00000152   0xDA07             BGE      ??man_usb_main_12
   \   00000154   0x4B48             LDR      R3,??man_usb_main_0+0x10
   \   00000156   0x189B             ADDS     R3,R3,R2
   \   00000158   0x7A1B             LDRB     R3,[R3, #+8]
   \   0000015A   0x3B30             SUBS     R3,R3,#+48
   \   0000015C   0x2B0A             CMP      R3,#+10
   \   0000015E   0xD3EC             BCC      ??man_usb_main_11
    416          					else {
    417          						ret = -1;
   \   00000160   0x2000             MOVS     R0,#+0
   \   00000162   0x43C0             MVNS     R0,R0            ;; #-1
    418          						break;
    419          					}
    420          				}
    421          				
    422          				// データサイズは正常?
    423          				if (ret == 0) {
   \                     ??man_usb_main_12: (+1)
   \   00000164   0x2800             CMP      R0,#+0
   \   00000166   0xD11A             BNE      ??man_usb_main_13
    424          					// データサイズが0の場合は終了
    425          					if (data_len == 0) {
   \   00000168   0x2900             CMP      R1,#+0
   \   0000016A   0xD109             BNE      ??man_usb_main_14
    426          						if (man_usb_work.ota_info.sequense == MAN_USB_OTA_SEQ_GET_DATA) {
   \   0000016C   0x....             LDR      R0,??DataTable6
   \   0000016E   0x7800             LDRB     R0,[R0, #+0]
   \   00000170   0x2806             CMP      R0,#+6
   \   00000172   0xD14D             BNE      ??man_usb_main_1
    427          							man_usb_work.ota_info.rcv_data_size = data_len;
   \   00000174   0x....             LDR      R0,??DataTable12
   \   00000176   0x6001             STR      R1,[R0, #+0]
    428          							man_usb_set_sequense(MAN_USB_OTA_SEQ_GET_DATA_OK);
   \   00000178   0x2007             MOVS     R0,#+7
   \   0000017A   0x.... 0x....      BL       man_usb_set_sequense
   \   0000017E   0xE047             B        ??man_usb_main_1
    429          						}
    430          					}
    431          					// データサイズが0以外の場合はデータ取得
    432          					else if (data_len <= man_usb_work.ota_info.data_size_max) {
   \                     ??man_usb_main_14: (+1)
   \   00000180   0x....             LDR      R0,??DataTable12_1
   \   00000182   0x6800             LDR      R0,[R0, #+0]
   \   00000184   0x4288             CMP      R0,R1
   \   00000186   0xDB02             BLT      ??man_usb_main_15
    433          						man_usb_work.ota_info.rcv_data_size = data_len;
   \   00000188   0x....             LDR      R0,??DataTable12
   \   0000018A   0x6001             STR      R1,[R0, #+0]
   \   0000018C   0xE040             B        ??man_usb_main_1
    434          					}
    435          					else {
    436          						if (man_usb_work.ota_info.sequense == MAN_USB_OTA_SEQ_GET_DATA) {
   \                     ??man_usb_main_15: (+1)
   \   0000018E   0x....             LDR      R0,??DataTable6
   \   00000190   0x7800             LDRB     R0,[R0, #+0]
   \   00000192   0x2806             CMP      R0,#+6
   \   00000194   0xD13C             BNE      ??man_usb_main_1
    437          							man_usb_set_sequense(MAN_USB_OTA_SEQ_GET_DATA_NG);
   \   00000196   0x2008             MOVS     R0,#+8
   \   00000198   0x.... 0x....      BL       man_usb_set_sequense
   \   0000019C   0xE038             B        ??man_usb_main_1
    438          						}
    439          					}
    440          				}
    441          				else {
    442          					if (man_usb_work.ota_info.sequense == MAN_USB_OTA_SEQ_GET_DATA) {
   \                     ??man_usb_main_13: (+1)
   \   0000019E   0x....             LDR      R0,??DataTable6
   \   000001A0   0x7800             LDRB     R0,[R0, #+0]
   \   000001A2   0x2806             CMP      R0,#+6
   \   000001A4   0xD134             BNE      ??man_usb_main_1
    443          						man_usb_set_sequense(MAN_USB_OTA_SEQ_GET_DATA_NG);
   \   000001A6   0x2008             MOVS     R0,#+8
   \   000001A8   0x.... 0x....      BL       man_usb_set_sequense
   \   000001AC   0xE030             B        ??man_usb_main_1
    444          					}
    445          				}
    446          			}
    447          			
    448          			// 512バイトデータ
    449          			else {
    450          				// データ受信中？
    451          				if ( (man_usb_work.ota_info.rcv_data_size != 0) && (man_usb_work.ota_info.sequense == MAN_USB_OTA_SEQ_GET_DATA) ) {
   \                     ??man_usb_main_9: (+1)
   \   000001AE   0x....             LDR      R0,??DataTable12
   \   000001B0   0x6800             LDR      R0,[R0, #+0]
   \   000001B2   0x2800             CMP      R0,#+0
   \   000001B4   0xD02C             BEQ      ??man_usb_main_1
   \   000001B6   0x....             LDR      R0,??DataTable6
   \   000001B8   0x7800             LDRB     R0,[R0, #+0]
   \   000001BA   0x2806             CMP      R0,#+6
   \   000001BC   0xD128             BNE      ??man_usb_main_1
    452          					// バッファに空きがあるか？
    453          					if ( (man_usb_work.ota_info.rcv_data_wp+man_usb_work.recv_data.length) <= MAN_USB_RECV_DATA_MAX ) {
   \   000001BE   0x....             LDR      R0,??DataTable14
   \   000001C0   0x6800             LDR      R0,[R0, #+0]
   \   000001C2   0x4931             LDR      R1,??man_usb_main_0+0x20
   \   000001C4   0x6809             LDR      R1,[R1, #+0]
   \   000001C6   0x1840             ADDS     R0,R0,R1
   \   000001C8   0x....             LDR      R1,??DataTable13  ;; 0x801
   \   000001CA   0x4288             CMP      R0,R1
   \   000001CC   0xDA1D             BGE      ??man_usb_main_16
    454          						memcpy(&man_usb_work.ota_info.rcv_data[man_usb_work.ota_info.rcv_data_wp], &man_usb_work.recv_data.data[0], man_usb_work.recv_data.length);
   \   000001CE   0x482E             LDR      R0,??man_usb_main_0+0x20
   \   000001D0   0x6802             LDR      R2,[R0, #+0]
   \   000001D2   0x492C             LDR      R1,??man_usb_main_0+0x1C
   \   000001D4   0x4828             LDR      R0,??man_usb_main_0+0x10
   \   000001D6   0x....             LDR      R3,??DataTable14
   \   000001D8   0x681B             LDR      R3,[R3, #+0]
   \   000001DA   0x18C0             ADDS     R0,R0,R3
   \   000001DC   0x....             LDR      R3,??DataTable13_1  ;; 0xce8
   \   000001DE   0x18C4             ADDS     R4,R0,R3
   \   000001E0   0x0020             MOVS     R0,R4
   \   000001E2   0x.... 0x....      BL       __aeabi_memcpy
    455          						man_usb_work.ota_info.rcv_data_wp += man_usb_work.recv_data.length;
   \   000001E6   0x....             LDR      R0,??DataTable14
   \   000001E8   0x6800             LDR      R0,[R0, #+0]
   \   000001EA   0x4927             LDR      R1,??man_usb_main_0+0x20
   \   000001EC   0x6809             LDR      R1,[R1, #+0]
   \   000001EE   0x1840             ADDS     R0,R0,R1
   \   000001F0   0x....             LDR      R1,??DataTable14
   \   000001F2   0x6008             STR      R0,[R1, #+0]
    456          						// 全データ受信完了？
    457          						if ( man_usb_work.ota_info.rcv_data_size <= (man_usb_work.ota_info.rcv_data_wp-2) ) {
   \   000001F4   0x....             LDR      R0,??DataTable14
   \   000001F6   0x6800             LDR      R0,[R0, #+0]
   \   000001F8   0x1E80             SUBS     R0,R0,#+2
   \   000001FA   0x....             LDR      R1,??DataTable12
   \   000001FC   0x6809             LDR      R1,[R1, #+0]
   \   000001FE   0x4288             CMP      R0,R1
   \   00000200   0xDB06             BLT      ??man_usb_main_1
    458          							man_usb_set_sequense(MAN_USB_OTA_SEQ_GET_DATA_OK);
   \   00000202   0x2007             MOVS     R0,#+7
   \   00000204   0x.... 0x....      BL       man_usb_set_sequense
   \   00000208   0xE002             B        ??man_usb_main_1
    459          						}
    460          					}
    461          					else {
    462          						man_usb_set_sequense(MAN_USB_OTA_SEQ_GET_DATA_NG);
   \                     ??man_usb_main_16: (+1)
   \   0000020A   0x2008             MOVS     R0,#+8
   \   0000020C   0x.... 0x....      BL       man_usb_set_sequense
    463          					}
    464          				}
    465          			}
    466          		}
    467          	}
    468          
    469          
    470          	// ******************************************************
    471          	// 要求処理
    472          	// ******************************************************
    473          	switch (man_usb_work.ota_info.req_ota_cmd) {
   \                     ??man_usb_main_1: (+1)
   \   00000210   0x....             LDR      R0,??DataTable15
   \   00000212   0x7800             LDRB     R0,[R0, #+0]
   \   00000214   0x2800             CMP      R0,#+0
   \   00000216   0xD003             BEQ      ??man_usb_main_17
   \   00000218   0x2802             CMP      R0,#+2
   \   0000021A   0xD00A             BEQ      ??man_usb_main_18
   \   0000021C   0xD301             BCC      ??man_usb_main_19
   \   0000021E   0xE00F             B        ??man_usb_main_20
    474          	case MAN_USB_OTA_CMD_READY:
    475          		break;
   \                     ??man_usb_main_17: (+1)
   \   00000220   0xE00E             B        ??man_usb_main_20
    476          	case MAN_USB_OTA_CMD_FILE_GET:
    477          		if (man_usb_work.ota_info.sequense == MAN_USB_OTA_SEQ_READY) {
   \                     ??man_usb_main_19: (+1)
   \   00000222   0x....             LDR      R0,??DataTable6
   \   00000224   0x7800             LDRB     R0,[R0, #+0]
   \   00000226   0x2800             CMP      R0,#+0
   \   00000228   0xD102             BNE      ??man_usb_main_21
    478          			man_usb_set_sequense(MAN_USB_OTA_SEQ_SEND_FILE_INFO_REQ);
   \   0000022A   0x2001             MOVS     R0,#+1
   \   0000022C   0x.... 0x....      BL       man_usb_set_sequense
    479          		}
    480          		break;
   \                     ??man_usb_main_21: (+1)
   \   00000230   0xE006             B        ??man_usb_main_20
    481          	case MAN_USB_OTA_CMD_DATA_GET:
    482          		if (man_usb_work.ota_info.sequense == MAN_USB_OTA_SEQ_READY) {
   \                     ??man_usb_main_18: (+1)
   \   00000232   0x....             LDR      R0,??DataTable6
   \   00000234   0x7800             LDRB     R0,[R0, #+0]
   \   00000236   0x2800             CMP      R0,#+0
   \   00000238   0xD102             BNE      ??man_usb_main_22
    483          			man_usb_set_sequense(MAN_USB_OTA_SEQ_GET_DATA_REQ);
   \   0000023A   0x2005             MOVS     R0,#+5
   \   0000023C   0x.... 0x....      BL       man_usb_set_sequense
    484          		}
    485          		break;
    486          	}
    487          
    488          	
    489          	// ******************************************************
    490          	// シーケンス処理
    491          	// ******************************************************
    492          	switch (man_usb_work.ota_info.sequense) {
   \                     ??man_usb_main_22: (+1)
   \                     ??man_usb_main_20: (+1)
   \   00000240   0x....             LDR      R0,??DataTable6
   \   00000242   0x7800             LDRB     R0,[R0, #+0]
   \   00000244   0x2800             CMP      R0,#+0
   \   00000246   0xD025             BEQ      ??man_usb_main_23
   \   00000248   0x2802             CMP      R0,#+2
   \   0000024A   0xD04E             BEQ      ??man_usb_main_24
   \   0000024C   0xD323             BCC      ??man_usb_main_25
   \   0000024E   0x2804             CMP      R0,#+4
   \   00000250   0xD05E             BEQ      ??man_usb_main_26
   \   00000252   0xD359             BCC      ??man_usb_main_27
   \   00000254   0x2806             CMP      R0,#+6
   \   00000256   0xD100             BNE      .+4
   \   00000258   0xE086             B        ??man_usb_main_28
   \   0000025A   0xD35E             BCC      ??man_usb_main_29
   \   0000025C   0x2808             CMP      R0,#+8
   \   0000025E   0xD100             BNE      .+4
   \   00000260   0xE095             B        ??man_usb_main_30
   \   00000262   0xD200             BCS      .+4
   \   00000264   0xE08F             B        ??man_usb_main_31
   \   00000266   0xE096             B        ??man_usb_main_32
   \                     ??man_usb_main_0:
   \   00000268   0x........         DC32     man_usb_work+0x81C
   \   0000026C   0x........         DC32     ?_0
   \   00000270   0x........         DC32     ?_1
   \   00000274   0x........         DC32     ?_2
   \   00000278   0x........         DC32     man_usb_work
   \   0000027C   0x........         DC32     man_usb_work+0x838
   \   00000280   0x........         DC32     man_usb_work+0x834
   \   00000284   0x........         DC32     man_usb_work+0x8
   \   00000288   0x........         DC32     man_usb_work+0x808
   \   0000028C   0x0000029E         DC32     0x29e
   \   00000290   0x........         DC32     respons
    493          	case MAN_USB_OTA_SEQ_READY:					// 要求待ち
    494          		break;
   \                     ??man_usb_main_23: (+1)
   \   00000294   0xE07F             B        ??man_usb_main_32
    495          
    496          	// man_usb_send_file_info
    497          	case MAN_USB_OTA_SEQ_SEND_FILE_INFO_REQ:	// 取得ファイル情報送信
    498          		man_usb_work.ota_info.rcv_file_size = 0;
   \                     ??man_usb_main_25: (+1)
   \   00000296   0x2000             MOVS     R0,#+0
   \   00000298   0x....             LDR      R1,??DataTable6_1
   \   0000029A   0x6008             STR      R0,[R1, #+0]
    499          		// 送信バッファクリア
    500          		memset(&man_usb_work.ota_info.snd_data[0], 0, MAN_USB_SEND_DATA_MAX);
   \   0000029C   0x2180             MOVS     R1,#+128
   \   0000029E   0x00C9             LSLS     R1,R1,#+3        ;; #+1024
   \   000002A0   0x2200             MOVS     R2,#+0
   \   000002A2   0x....             LDR      R4,??DataTable17
   \   000002A4   0x0020             MOVS     R0,R4
   \   000002A6   0x.... 0x....      BL       __aeabi_memset
    501          		data = &man_usb_work.ota_info.snd_data[0];
   \   000002AA   0x....             LDR      R4,??DataTable17
    502          		// "fileget,GNSS_GW_FW_r195_s.101,4096"
    503          		sprintf((char *)data, "fileget,%s.%03d,%d\r\n", man_usb_work.ota_info.set_file_info.filename, man_usb_work.ota_info.file_num, man_usb_work.ota_info.data_size_max);
   \   000002AC   0x....             LDR      R0,??DataTable12_1
   \   000002AE   0x6800             LDR      R0,[R0, #+0]
   \   000002B0   0x9000             STR      R0,[SP, #+0]
   \   000002B2   0x....             LDR      R0,??DataTable17_1
   \   000002B4   0x6803             LDR      R3,[R0, #+0]
   \   000002B6   0x....             LDR      R2,??DataTable17_2
   \   000002B8   0x....             LDR      R1,??DataTable18
   \   000002BA   0x0020             MOVS     R0,R4
   \   000002BC   0x.... 0x....      BL       sprintf
    504          		length = strlen((char const *)data);
   \   000002C0   0x0020             MOVS     R0,R4
   \   000002C2   0x.... 0x....      BL       strlen
   \   000002C6   0x0001             MOVS     R1,R0
    505          		ret = man_usb_data_send(data, length);
   \   000002C8   0x0020             MOVS     R0,R4
   \   000002CA   0x.... 0x....      BL       man_usb_data_send
    506          		if (ret >= 0) {
   \   000002CE   0x2800             CMP      R0,#+0
   \   000002D0   0xD407             BMI      ??man_usb_main_33
    507          			man_usb_set_sequense(MAN_USB_OTA_SEQ_SEND_FILE_INFO);
   \   000002D2   0x2002             MOVS     R0,#+2
   \   000002D4   0x.... 0x....      BL       man_usb_set_sequense
    508          			man_usb_work.delay_timer = man_timer_get_1ms_count();
   \   000002D8   0x.... 0x....      BL       man_timer_get_1ms_count
   \   000002DC   0x....             LDR      R1,??DataTable18_1
   \   000002DE   0x6008             STR      R0,[R1, #+0]
   \   000002E0   0xE002             B        ??man_usb_main_34
    509          		}
    510          		else {
    511          			man_usb_set_sequense(MAN_USB_OTA_SEQ_SEND_FILE_INFO_NG);
   \                     ??man_usb_main_33: (+1)
   \   000002E2   0x2004             MOVS     R0,#+4
   \   000002E4   0x.... 0x....      BL       man_usb_set_sequense
    512          		}
    513          		break;
   \                     ??man_usb_main_34: (+1)
   \   000002E8   0xE055             B        ??man_usb_main_32
    514          	case MAN_USB_OTA_SEQ_SEND_FILE_INFO:		// 取得ファイル情報送信中
    515          		delay_timer = man_timer_get_elapsed_time(man_usb_work.delay_timer, man_timer_get_1ms_count());
   \                     ??man_usb_main_24: (+1)
   \   000002EA   0x.... 0x....      BL       man_timer_get_1ms_count
   \   000002EE   0x0001             MOVS     R1,R0
   \   000002F0   0x....             LDR      R0,??DataTable18_1
   \   000002F2   0x6800             LDR      R0,[R0, #+0]
   \   000002F4   0x.... 0x....      BL       man_timer_get_elapsed_time
    516          		// 2秒間応答が無い場合は異常終了する
    517          		if (delay_timer >= 2000) {
   \   000002F8   0x21FA             MOVS     R1,#+250
   \   000002FA   0x00C9             LSLS     R1,R1,#+3        ;; #+2000
   \   000002FC   0x4288             CMP      R0,R1
   \   000002FE   0xD302             BCC      ??man_usb_main_35
    518          			man_usb_set_sequense(MAN_USB_OTA_SEQ_SEND_FILE_INFO_NG);
   \   00000300   0x2004             MOVS     R0,#+4
   \   00000302   0x.... 0x....      BL       man_usb_set_sequense
    519          		}
    520          		break;
   \                     ??man_usb_main_35: (+1)
   \   00000306   0xE046             B        ??man_usb_main_32
    521          	case MAN_USB_OTA_SEQ_SEND_FILE_INFO_OK:		// 取得ファイル情報送信成功
    522          		man_usb_return_callback(MAN_USB_STATUS_OK);
   \                     ??man_usb_main_27: (+1)
   \   00000308   0x2000             MOVS     R0,#+0
   \   0000030A   0x.... 0x....      BL       man_usb_return_callback
    523          		break;
   \   0000030E   0xE042             B        ??man_usb_main_32
    524          	case MAN_USB_OTA_SEQ_SEND_FILE_INFO_NG:		// 取得ファイル情報送信失敗
    525          		man_usb_return_callback(MAN_USB_STATUS_NG);
   \                     ??man_usb_main_26: (+1)
   \   00000310   0x2000             MOVS     R0,#+0
   \   00000312   0x43C0             MVNS     R0,R0            ;; #-1
   \   00000314   0x.... 0x....      BL       man_usb_return_callback
    526          		break;
   \   00000318   0xE03D             B        ??man_usb_main_32
    527          
    528          
    529          	// man_usb_get_data
    530          	case MAN_USB_OTA_SEQ_GET_DATA_REQ:			// 取得ファイル情報送信
    531          		man_usb_work.ota_info.rcv_data_wp = 0;
   \                     ??man_usb_main_29: (+1)
   \   0000031A   0x2000             MOVS     R0,#+0
   \   0000031C   0x....             LDR      R1,??DataTable14
   \   0000031E   0x6008             STR      R0,[R1, #+0]
    532          		// 送信バッファクリア
    533          		memset(&man_usb_work.ota_info.snd_data[0], 0, MAN_USB_SEND_DATA_MAX);
   \   00000320   0x2180             MOVS     R1,#+128
   \   00000322   0x00C9             LSLS     R1,R1,#+3        ;; #+1024
   \   00000324   0x2200             MOVS     R2,#+0
   \   00000326   0x....             LDR      R4,??DataTable17
   \   00000328   0x0020             MOVS     R0,R4
   \   0000032A   0x.... 0x....      BL       __aeabi_memset
    534          		data = &man_usb_work.ota_info.snd_data[0];
   \   0000032E   0x....             LDR      R4,??DataTable17
    535          		// "dataget"
    536          		sprintf((char *)data, "dataget\r\n");
   \   00000330   0x....             LDR      R1,??DataTable18_2
   \   00000332   0x0020             MOVS     R0,R4
   \   00000334   0x.... 0x....      BL       sprintf
    537          		length = strlen((char const *)data);
   \   00000338   0x0020             MOVS     R0,R4
   \   0000033A   0x.... 0x....      BL       strlen
   \   0000033E   0x0001             MOVS     R1,R0
    538          		ret = man_usb_data_send(data, length);
   \   00000340   0x0020             MOVS     R0,R4
   \   00000342   0x.... 0x....      BL       man_usb_data_send
    539          		if (ret >= 0) {
   \   00000346   0x2800             CMP      R0,#+0
   \   00000348   0xD40A             BMI      ??man_usb_main_36
    540          			man_usb_set_sequense(MAN_USB_OTA_SEQ_GET_DATA);
   \   0000034A   0x2006             MOVS     R0,#+6
   \   0000034C   0x.... 0x....      BL       man_usb_set_sequense
    541          			man_usb_work.ota_info.rcv_data_size = 0;
   \   00000350   0x2000             MOVS     R0,#+0
   \   00000352   0x....             LDR      R1,??DataTable12
   \   00000354   0x6008             STR      R0,[R1, #+0]
    542          			man_usb_work.delay_timer = man_timer_get_1ms_count();
   \   00000356   0x.... 0x....      BL       man_timer_get_1ms_count
   \   0000035A   0x....             LDR      R1,??DataTable18_1
   \   0000035C   0x6008             STR      R0,[R1, #+0]
   \   0000035E   0xE002             B        ??man_usb_main_37
    543          		}
    544          		else {
    545          			man_usb_set_sequense(MAN_USB_OTA_SEQ_GET_DATA_NG);
   \                     ??man_usb_main_36: (+1)
   \   00000360   0x2008             MOVS     R0,#+8
   \   00000362   0x.... 0x....      BL       man_usb_set_sequense
    546          		}
    547          		break;
   \                     ??man_usb_main_37: (+1)
   \   00000366   0xE016             B        ??man_usb_main_32
    548          	case MAN_USB_OTA_SEQ_GET_DATA:				// 取得ファイル情報送信中
    549          		delay_timer = man_timer_get_elapsed_time(man_usb_work.delay_timer, man_timer_get_1ms_count());
   \                     ??man_usb_main_28: (+1)
   \   00000368   0x.... 0x....      BL       man_timer_get_1ms_count
   \   0000036C   0x0001             MOVS     R1,R0
   \   0000036E   0x....             LDR      R0,??DataTable18_1
   \   00000370   0x6800             LDR      R0,[R0, #+0]
   \   00000372   0x.... 0x....      BL       man_timer_get_elapsed_time
    550          		// 4秒間応答が無い場合は異常終了する
    551          		if (delay_timer >= 4000) {
   \   00000376   0x21FA             MOVS     R1,#+250
   \   00000378   0x0109             LSLS     R1,R1,#+4        ;; #+4000
   \   0000037A   0x4288             CMP      R0,R1
   \   0000037C   0xD302             BCC      ??man_usb_main_38
    552          			man_usb_set_sequense(MAN_USB_OTA_SEQ_GET_DATA_NG);
   \   0000037E   0x2008             MOVS     R0,#+8
   \   00000380   0x.... 0x....      BL       man_usb_set_sequense
    553          		}
    554          		break;
   \                     ??man_usb_main_38: (+1)
   \   00000384   0xE007             B        ??man_usb_main_32
    555          	case MAN_USB_OTA_SEQ_GET_DATA_OK:			// 取得ファイル情報送信成功
    556          		man_usb_return_callback_data(MAN_USB_STATUS_OK);
   \                     ??man_usb_main_31: (+1)
   \   00000386   0x2000             MOVS     R0,#+0
   \   00000388   0x.... 0x....      BL       man_usb_return_callback_data
    557          		break;
   \   0000038C   0xE003             B        ??man_usb_main_32
    558          	case MAN_USB_OTA_SEQ_GET_DATA_NG:			// 取得ファイル情報送信失敗
    559          		man_usb_return_callback_data(MAN_USB_STATUS_NG);
   \                     ??man_usb_main_30: (+1)
   \   0000038E   0x2000             MOVS     R0,#+0
   \   00000390   0x43C0             MVNS     R0,R0            ;; #-1
   \   00000392   0x.... 0x....      BL       man_usb_return_callback_data
    560          		break;
    561          	}
    562          }
   \                     ??man_usb_main_32: (+1)
   \   00000396   0xB008             ADD      SP,SP,#+32
   \   00000398   0xBD10             POP      {R4,PC}          ;; return
    563          
    564          
    565          /********************************************************************/
    566          /*!
    567           * \name	man_usb_100ms_main
    568           * \brief	100ms毎に行う処理
    569           * \param	なし
    570           * \return  なし
    571           * \note	100ms毎に、呼ばれること
    572           */
    573          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    574          void man_usb_100ms_main( void )
    575          {
   \                     man_usb_100ms_main: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    576          	// USBデバイスの設定を確認する
    577          	man_usb_chk_config();
   \   00000002   0x.... 0x....      BL       man_usb_chk_config
    578          }
   \   00000006   0xBD01             POP      {R0,PC}          ;; return
    579          
    580          /********************************************************************/
    581          /*!
    582           * \name	man_usb_rpt_send
    583           * \brief	USB SEND開始
    584           * \param	data      : 送信データ
    585           *          length    : データ長
    586           *          id        : ユニーク番号
    587           *          callback  : 完了を通知するcallback関数
    588           * \return   0: 成功
    589           *          -1:失敗
    590           * \note	必要時に、呼ばれること
    591           *          data は完了するまで破壊しないこと
    592           */
    593          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    594          int32_t man_usb_rpt_send(uint8_t *data, int32_t length, int32_t id, func_man_usb callback)
    595          {
   \                     man_usb_rpt_send: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0014             MOVS     R4,R2
   \   00000004   0x001D             MOVS     R5,R3
    596          	int32_t	ret = 0;
   \   00000006   0x2200             MOVS     R2,#+0
    597          
    598          
    599          	man_usb_data_send(data, length);
   \   00000008   0x.... 0x....      BL       man_usb_data_send
    600          	if (callback != NULL) {
   \   0000000C   0x0028             MOVS     R0,R5
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD002             BEQ      ??man_usb_rpt_send_0
    601          		callback(id, MAN_USB_STATUS_OK);
   \   00000012   0x2100             MOVS     R1,#+0
   \   00000014   0x0020             MOVS     R0,R4
   \   00000016   0x47A8             BLX      R5
    602          	}
    603          	return 0;
   \                     ??man_usb_rpt_send_0: (+1)
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    604          }
    605          
    606          
    607          /********************************************************************/
    608          /*!
    609           * \name	man_usb_data_send
    610           * \brief	USB データ送信開始
    611           * \param	data      : 送信データ
    612           *          length    : データ長
    613           * \return   0: 成功
    614           *          -1:失敗
    615           * \note	必要時に、呼ばれること
    616           *          data は完了するまで破壊しないこと
    617           */
    618          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    619          int32_t man_usb_data_send(uint8_t *data, int32_t length)
    620          {
   \                     man_usb_data_send: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    621          	int32_t	ret = -1;
   \   00000002   0x2200             MOVS     R2,#+0
   \   00000004   0x43D2             MVNS     R2,R2            ;; #-1
    622          	
    623          	if (man_usb_work.usb_used == 1) {
   \   00000006   0x....             LDR      R3,??DataTable18_3
   \   00000008   0x681B             LDR      R3,[R3, #+0]
   \   0000000A   0x2B01             CMP      R3,#+1
   \   0000000C   0xD102             BNE      ??man_usb_data_send_0
    624          		ret = ctrl_USB_send(data, length);
   \   0000000E   0x.... 0x....      BL       ctrl_USB_send
   \   00000012   0x0002             MOVS     R2,R0
    625          	}
    626          	
    627          	return ret;
   \                     ??man_usb_data_send_0: (+1)
   \   00000014   0x0010             MOVS     R0,R2
   \   00000016   0xBD02             POP      {R1,PC}          ;; return
    628          }
    629          
    630          
    631          /********************************************************************/
    632          /*!
    633           * \name	man_usb_data_send_crlf
    634           * \brief	USB CR+LF送信開始
    635           * \param	なし
    636           * \return  なし
    637           * \note	必要時に、呼ばれること
    638           */
    639          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    640          void man_usb_data_send_crlf( void)
    641          {
   \                     man_usb_data_send_crlf: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    642          	man_usb_work.buff[0] = ASCII_CR;
   \   00000002   0x200D             MOVS     R0,#+13
   \   00000004   0x....             LDR      R1,??DataTable18_4
   \   00000006   0x7008             STRB     R0,[R1, #+0]
    643          	man_usb_work.buff[1] = ASCII_LF;
   \   00000008   0x200A             MOVS     R0,#+10
   \   0000000A   0x....             LDR      R1,??DataTable18_5
   \   0000000C   0x7008             STRB     R0,[R1, #+0]
    644          	man_usb_data_send(&man_usb_work.buff[0], 2);
   \   0000000E   0x2102             MOVS     R1,#+2
   \   00000010   0x....             LDR      R0,??DataTable18_4
   \   00000012   0x.... 0x....      BL       man_usb_data_send
    645          }
   \   00000016   0xBD01             POP      {R0,PC}          ;; return
    646          
    647          /********************************************************************/
    648          /*!
    649           * \name	man_usb_req_cmd_start
    650           * \brief	コマンド受付を開始する処理
    651           * \param	なし
    652           * \return  なし
    653           * \note	必要時に、呼ばれること
    654           */
    655          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    656          void man_usb_req_cmd_start( void )
    657          {
    658          	man_usb_work.cmd_mode = MAN_USB_CMD_START;
   \                     man_usb_req_cmd_start: (+1)
   \   00000000   0x2001             MOVS     R0,#+1
   \   00000002   0x....             LDR      R1,??DataTable18_6
   \   00000004   0x7008             STRB     R0,[R1, #+0]
    659          }
   \   00000006   0x4770             BX       LR               ;; return
    660          
    661          
    662          /********************************************************************/
    663          /*!
    664           * \name	man_usb_req_cmd_end
    665           * \brief	コマンド受付を終了する処理
    666           * \param	なし
    667           * \return  なし
    668           * \note	必要時に、呼ばれること
    669           */
    670          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    671          void man_usb_req_cmd_stop( void )
    672          {
    673          	man_usb_work.cmd_mode = MAN_USB_CMD_STOP;
   \                     man_usb_req_cmd_stop: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x....             LDR      R1,??DataTable18_6
   \   00000004   0x7008             STRB     R0,[R1, #+0]
    674          }
   \   00000006   0x4770             BX       LR               ;; return
    675          
    676          
    677          /********************************************************************/
    678          /*!
    679           * \name	man_usb_req_reset
    680           * \brief	USBデバイスをリセットする処理
    681           * \param	なし
    682           * \return  なし
    683           * \note	必要時に、呼ばれること
    684           */
    685          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    686          void man_usb_req_reset( void )
    687          {
   \                     man_usb_req_reset: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    688          	ctrl_usb_req_reset();
   \   00000002   0x.... 0x....      BL       ctrl_usb_req_reset
    689          }
   \   00000006   0xBD01             POP      {R0,PC}          ;; return
    690          
    691          
    692          /********************************************************************/
    693          /*!
    694           * \name	man_usb_ota_open
    695           * \brief	USB OTA開始処理
    696           * \param	なし
    697           * \return  なし
    698           * \note	OTA開始時に、呼ばれること
    699           */
    700          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    701          void man_usb_ota_open( void )
    702          {
    703          	man_usb_work.ota_info.ota_flag = 1;
   \                     man_usb_ota_open: (+1)
   \   00000000   0x2001             MOVS     R0,#+1
   \   00000002   0x....             LDR      R1,??DataTable18_7
   \   00000004   0x6008             STR      R0,[R1, #+0]
    704          }
   \   00000006   0x4770             BX       LR               ;; return
    705          
    706          /********************************************************************/
    707          /*!
    708           * \name	man_usb_ota_close
    709           * \brief	USB OTA終了処理
    710           * \param	なし
    711           * \return  なし
    712           * \note	OTA終了時に、呼ばれること
    713           */
    714          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    715          void man_usb_ota_close( void )
    716          {
    717          	man_usb_work.ota_info.ota_flag = 0;
   \                     man_usb_ota_close: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x....             LDR      R1,??DataTable18_7
   \   00000004   0x6008             STR      R0,[R1, #+0]
    718          }
   \   00000006   0x4770             BX       LR               ;; return
    719          
    720          
    721          /********************************************************************/
    722          /*!
    723           * \name	man_usb_set_file_info
    724           * \brief	USB OTAファイル情報の指定処理
    725           * \param	なし
    726           * \return  なし
    727           * \note	必要時に、呼ばれること
    728           */
    729          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    730          void man_usb_set_file_info( man_usb_set_file_info_t set_file_info )
    731          {
   \                     man_usb_set_file_info: (+1)
   \   00000000   0xB40F             PUSH     {R0-R3}
   \   00000002   0xB580             PUSH     {R7,LR}
    732          	man_usb_work.ota_info.set_file_info = set_file_info;
   \   00000004   0x....             LDR      R0,??DataTable17_2
   \   00000006   0xA902             ADD      R1,SP,#+8
   \   00000008   0x2282             MOVS     R2,#+130
   \   0000000A   0x.... 0x....      BL       __aeabi_memcpy
    733          }
   \   0000000E   0x9801             LDR      R0,[SP, #+4]
   \   00000010   0xB006             ADD      SP,SP,#+24
   \   00000012   0x4700             BX       R0               ;; return
    734          
    735          /********************************************************************/
    736          /*!
    737           * \name	man_usb_send_file_info
    738           * \brief	取得ファイル情報送信処理
    739           * \param	file_num   : ファイル番号
    740           *          data_size_max  : 一度に取得できるデータサイズ
    741           *          id         : ユニーク番号
    742           *          callback   : 完了を通知するcallback関数
    743           * \return   0: 成功
    744           *          -1:失敗
    745           * \note	man_usb_ota_open後、呼ばれること
    746           */
    747          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    748          int32_t man_usb_send_file_info( int32_t file_num, int32_t data_size_max, int32_t id, func_man_usb callback )
    749          {
   \                     man_usb_send_file_info: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    750          	int32_t		ret=-1;
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x43C0             MVNS     R0,R0            ;; #-1
    751          
    752          
    753          	if ( (man_usb_work.ota_info.ota_flag == 1) && (man_usb_work.ota_info.req_ota_cmd == MAN_USB_OTA_CMD_READY) ) {
   \   00000008   0x....             LDR      R5,??DataTable18_7
   \   0000000A   0x682D             LDR      R5,[R5, #+0]
   \   0000000C   0x2D01             CMP      R5,#+1
   \   0000000E   0xD10F             BNE      ??man_usb_send_file_info_0
   \   00000010   0x....             LDR      R5,??DataTable15
   \   00000012   0x782D             LDRB     R5,[R5, #+0]
   \   00000014   0x2D00             CMP      R5,#+0
   \   00000016   0xD10B             BNE      ??man_usb_send_file_info_0
    754          		man_usb_work.ota_info.file_num = file_num;
   \   00000018   0x....             LDR      R0,??DataTable17_1
   \   0000001A   0x6004             STR      R4,[R0, #+0]
    755          		man_usb_work.ota_info.data_size_max = data_size_max;
   \   0000001C   0x....             LDR      R0,??DataTable18_8
   \   0000001E   0x6001             STR      R1,[R0, #+0]
    756          		man_usb_work.ota_info.id = id;
   \   00000020   0x....             LDR      R0,??DataTable18_9
   \   00000022   0x6002             STR      R2,[R0, #+0]
    757          		man_usb_work.ota_info.callback = callback;
   \   00000024   0x....             LDR      R0,??DataTable18_10
   \   00000026   0x6003             STR      R3,[R0, #+0]
    758          	
    759          		man_usb_work.ota_info.req_ota_cmd = MAN_USB_OTA_CMD_FILE_GET;
   \   00000028   0x2001             MOVS     R0,#+1
   \   0000002A   0x....             LDR      R1,??DataTable15
   \   0000002C   0x7008             STRB     R0,[R1, #+0]
    760          		
    761          		ret = 0;
   \   0000002E   0x2000             MOVS     R0,#+0
    762          	}
    763          	return ret;
   \                     ??man_usb_send_file_info_0: (+1)
   \   00000030   0xBD30             POP      {R4,R5,PC}       ;; return
    764          }
    765          
    766          /********************************************************************/
    767          /*!
    768           * \name	man_usb_get_file_info
    769           * \brief	USB OTAファイル情報の取得処理
    770           * \param	なし
    771           * \return  ファイル情報へのポインタ
    772           * \note	man_usb_send_file_info関数の成功後に呼ばれること
    773           */
    774          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    775          man_usb_get_file_info_t * man_usb_get_file_info( void )
    776          {
    777          	return &man_usb_work.ota_info.get_file_info;
   \                     man_usb_get_file_info: (+1)
   \   00000000   0x....             LDR      R0,??DataTable18_11
   \   00000002   0x4770             BX       LR               ;; return
    778          }
    779          
    780          
    781          /********************************************************************/
    782          /*!
    783           * \name	man_usb_get_data
    784           * \brief	ファイルのデータを取得する
    785           * \param	id            : ユニーク番号
    786           *          callback_data : 受信データを通知するcallback関数
    787           * \return   0: 成功
    788           *          -1:失敗
    789           * \note	man_usb_ota_open後、呼ばれること
    790           */
    791          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    792          int32_t man_usb_get_data(int32_t id, func_man_usb_data callback_data)
    793          {
   \                     man_usb_get_data: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0x0002             MOVS     R2,R0
    794          	int32_t		ret=-1;
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x43C0             MVNS     R0,R0            ;; #-1
    795          
    796          	if ( (man_usb_work.ota_info.ota_flag == 1) && (man_usb_work.ota_info.req_ota_cmd == MAN_USB_OTA_CMD_READY) ) {
   \   00000008   0x....             LDR      R3,??DataTable18_7
   \   0000000A   0x681B             LDR      R3,[R3, #+0]
   \   0000000C   0x2B01             CMP      R3,#+1
   \   0000000E   0xD10B             BNE      ??man_usb_get_data_0
   \   00000010   0x....             LDR      R3,??DataTable18_12
   \   00000012   0x781B             LDRB     R3,[R3, #+0]
   \   00000014   0x2B00             CMP      R3,#+0
   \   00000016   0xD107             BNE      ??man_usb_get_data_0
    797          		man_usb_work.ota_info.id = id;
   \   00000018   0x....             LDR      R0,??DataTable18_9
   \   0000001A   0x6002             STR      R2,[R0, #+0]
    798          		man_usb_work.ota_info.callback_data = callback_data;
   \   0000001C   0x....             LDR      R0,??DataTable18_13
   \   0000001E   0x6001             STR      R1,[R0, #+0]
    799          
    800          		man_usb_work.ota_info.req_ota_cmd = MAN_USB_OTA_CMD_DATA_GET;
   \   00000020   0x2002             MOVS     R0,#+2
   \   00000022   0x....             LDR      R1,??DataTable18_12
   \   00000024   0x7008             STRB     R0,[R1, #+0]
    801          		
    802          		ret = 0;
   \   00000026   0x2000             MOVS     R0,#+0
    803          	}
    804          
    805          	return ret;
   \                     ??man_usb_get_data_0: (+1)
   \   00000028   0xBD00             POP      {PC}             ;; return
    806          }
    807          
    808          
    809          /********************************************************************/
    810          /*!
    811           * \name	man_usb_send_usbota_result
    812           * \brief	USB 端末OTA結果を送信する
    813           * \param	result          : 結果
    814           * \return   0: 成功
    815           *          -1:失敗
    816           * \note	
    817           */
    818          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    819          int32_t man_usb_send_usbota_result(int32_t result)
    820          {
   \                     man_usb_send_usbota_result: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0005             MOVS     R5,R0
    821          	uint8_t		*data;
    822          	int32_t		length;
    823          	int32_t		ret;
    824          	man_data_get_other_t *other = man_data_get_other();
   \   00000004   0x.... 0x....      BL       man_data_get_other
   \   00000008   0x0006             MOVS     R6,R0
    825          
    826          	memset(&man_usb_work.ota_info.snd_data[0], 0, MAN_USB_SEND_DATA_MAX);
   \   0000000A   0x2180             MOVS     R1,#+128
   \   0000000C   0x00C9             LSLS     R1,R1,#+3        ;; #+1024
   \   0000000E   0x2200             MOVS     R2,#+0
   \   00000010   0x....             LDR      R4,??DataTable17
   \   00000012   0x0020             MOVS     R0,R4
   \   00000014   0x.... 0x....      BL       __aeabi_memset
    827          	data = &man_usb_work.ota_info.snd_data[0];
   \   00000018   0x....             LDR      R4,??DataTable17
    828          	
    829          	// "usbota"
    830          	if (result == MAN_USB_STATUS_OK) {
   \   0000001A   0x2D00             CMP      R5,#+0
   \   0000001C   0xD106             BNE      ??man_usb_send_usbota_result_0
    831          		sprintf((char *)data, "usbota,%s=Normal!\r\n", other->cid);
   \   0000001E   0x0032             MOVS     R2,R6
   \   00000020   0x3210             ADDS     R2,R2,#+16
   \   00000022   0x....             LDR      R1,??DataTable18_14
   \   00000024   0x0020             MOVS     R0,R4
   \   00000026   0x.... 0x....      BL       sprintf
   \   0000002A   0xE005             B        ??man_usb_send_usbota_result_1
    832          	}
    833          	else {
    834          		sprintf((char *)data, "usbota,%s=Abnormal!\r\n", other->cid);
   \                     ??man_usb_send_usbota_result_0: (+1)
   \   0000002C   0x0032             MOVS     R2,R6
   \   0000002E   0x3210             ADDS     R2,R2,#+16
   \   00000030   0x....             LDR      R1,??DataTable18_15
   \   00000032   0x0020             MOVS     R0,R4
   \   00000034   0x.... 0x....      BL       sprintf
    835          	}
    836          	length = strlen((char const *)data);
   \                     ??man_usb_send_usbota_result_1: (+1)
   \   00000038   0x0020             MOVS     R0,R4
   \   0000003A   0x.... 0x....      BL       strlen
    837          	ret = man_usb_data_send(data, length);
   \   0000003E   0x0001             MOVS     R1,R0
   \   00000040   0x0020             MOVS     R0,R4
   \   00000042   0x.... 0x....      BL       man_usb_data_send
    838          
    839          	return ret;
   \   00000046   0xBD70             POP      {R4-R6,PC}       ;; return
    840          }
    841          
    842          
    843          /********************************************************************/
    844          /*!
    845           * \name	man_usb_send_usbgpsota_result
    846           * \brief	USB GPS OTA結果を送信する
    847           * \param	result          : 結果
    848           * \return   0: 成功
    849           *          -1:失敗
    850           * \note	
    851           */
    852          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    853          int32_t man_usb_send_usbgpsota_result(int32_t result)
    854          {
   \                     man_usb_send_usbgpsota_result: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0005             MOVS     R5,R0
    855          	uint8_t		*data;
    856          	int32_t		length;
    857          	int32_t		ret;
    858          	man_data_get_other_t *other = man_data_get_other();
   \   00000004   0x.... 0x....      BL       man_data_get_other
   \   00000008   0x0006             MOVS     R6,R0
    859          
    860          	memset(&man_usb_work.ota_info.snd_data[0], 0, MAN_USB_SEND_DATA_MAX);
   \   0000000A   0x2180             MOVS     R1,#+128
   \   0000000C   0x00C9             LSLS     R1,R1,#+3        ;; #+1024
   \   0000000E   0x2200             MOVS     R2,#+0
   \   00000010   0x....             LDR      R4,??DataTable18_16
   \   00000012   0x0020             MOVS     R0,R4
   \   00000014   0x.... 0x....      BL       __aeabi_memset
    861          	data = &man_usb_work.ota_info.snd_data[0];
   \   00000018   0x....             LDR      R4,??DataTable18_16
    862          	
    863          	// "usbgpsota"
    864          	if (result == MAN_USB_STATUS_OK) {
   \   0000001A   0x2D00             CMP      R5,#+0
   \   0000001C   0xD106             BNE      ??man_usb_send_usbgpsota_result_0
    865          		sprintf((char *)data, "usbgpsota,%s=Normal!\r\n", other->cid);
   \   0000001E   0x0032             MOVS     R2,R6
   \   00000020   0x3210             ADDS     R2,R2,#+16
   \   00000022   0x....             LDR      R1,??DataTable18_17
   \   00000024   0x0020             MOVS     R0,R4
   \   00000026   0x.... 0x....      BL       sprintf
   \   0000002A   0xE005             B        ??man_usb_send_usbgpsota_result_1
    866          	}
    867          	else {
    868          		sprintf((char *)data, "usbgpsota,%s=Abnormal!\r\n", other->cid);
   \                     ??man_usb_send_usbgpsota_result_0: (+1)
   \   0000002C   0x0032             MOVS     R2,R6
   \   0000002E   0x3210             ADDS     R2,R2,#+16
   \   00000030   0x....             LDR      R1,??DataTable18_18
   \   00000032   0x0020             MOVS     R0,R4
   \   00000034   0x.... 0x....      BL       sprintf
    869          	}
    870          	length = strlen((char const *)data);
   \                     ??man_usb_send_usbgpsota_result_1: (+1)
   \   00000038   0x0020             MOVS     R0,R4
   \   0000003A   0x.... 0x....      BL       strlen
    871          	ret = man_usb_data_send(data, length);
   \   0000003E   0x0001             MOVS     R1,R0
   \   00000040   0x0020             MOVS     R0,R4
   \   00000042   0x.... 0x....      BL       man_usb_data_send
    872          
    873          	return ret;
   \   00000046   0xBD70             POP      {R4-R6,PC}       ;; return
    874          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5:
   \   00000000   0x........         DC32     man_usb_work+0x8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_1:
   \   00000000   0x........         DC32     man_usb_work+0x808

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_2:
   \   00000000   0x........         DC32     man_usb_work+0x80C

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_3:
   \   00000000   0x........         DC32     man_usb_work

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_4:
   \   00000000   0x........         DC32     man_usb_work+0x83D

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_5:
   \   00000000   0x........         DC32     man_usb_work+0x854

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_6:
   \   00000000   0x........         DC32     man_usb_work+0x850

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_7:
   \   00000000   0x........         DC32     man_usb_work+0x83C

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_8:
   \   00000000   0x........         DC32     man_usb_work+0x858

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_9:
   \   00000000   0x........         DC32     man_usb_work+0x8E4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_10:
   \   00000000   0x........         DC32     man_usb_work+0xCE8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_11:
   \   00000000   0x000014F8         DC32     0x14f8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_12:
   \   00000000   0x0000029E         DC32     0x29e

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_13:
   \   00000000   0x........         DC32     respons

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_14:
   \   00000000   0x........         DC32     man_usb_callback

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6:
   \   00000000   0x........         DC32     man_usb_work+0x83D

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_1:
   \   00000000   0x........         DC32     man_usb_work+0x848

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \   00000000   0x........         DC32     man_usb_work+0x8E0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12:
   \   00000000   0x........         DC32     man_usb_work+0x84C

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_1:
   \   00000000   0x........         DC32     man_usb_work+0x844

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13:
   \   00000000   0x00000801         DC32     0x801

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_1:
   \   00000000   0x00000CE8         DC32     0xce8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14:
   \   00000000   0x........         DC32     man_usb_work+0x8E4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15:
   \   00000000   0x........         DC32     man_usb_work+0x83C

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17:
   \   00000000   0x........         DC32     man_usb_work+0x8E8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_1:
   \   00000000   0x........         DC32     man_usb_work+0x840

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_2:
   \   00000000   0x........         DC32     man_usb_work+0x85C

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18:
   \   00000000   0x........         DC32     ?_3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_1:
   \   00000000   0x........         DC32     man_usb_work+0x14E8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_2:
   \   00000000   0x........         DC32     ?_4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_3:
   \   00000000   0x........         DC32     man_usb_work

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_4:
   \   00000000   0x........         DC32     man_usb_work+0x14EC

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_5:
   \   00000000   0x........         DC32     man_usb_work+0x14ED

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_6:
   \   00000000   0x........         DC32     man_usb_work+0x834

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_7:
   \   00000000   0x........         DC32     man_usb_work+0x838

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_8:
   \   00000000   0x........         DC32     man_usb_work+0x844

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_9:
   \   00000000   0x........         DC32     man_usb_work+0x850

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_10:
   \   00000000   0x........         DC32     man_usb_work+0x854

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_11:
   \   00000000   0x........         DC32     man_usb_work+0x8E0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_12:
   \   00000000   0x........         DC32     man_usb_work+0x83C

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_13:
   \   00000000   0x........         DC32     man_usb_work+0x858

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_14:
   \   00000000   0x........         DC32     ?_5

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_15:
   \   00000000   0x........         DC32     ?_6

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_16:
   \   00000000   0x........         DC32     man_usb_work+0x8E8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_17:
   \   00000000   0x........         DC32     ?_7

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_18:
   \   00000000   0x........         DC32     ?_8

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x64 0x65          DC8 "debugcmd"
   \              0x62 0x75    
   \              0x67 0x63    
   \              0x6D 0x64    
   \              0x00         
   \   00000009   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_1:
   \   00000000   0x4F 0x4B          DC8 "OK,"
   \              0x2C 0x00    

   \                                 In section .rodata, align 4
   \                     ?_2:
   \   00000000   0x44 0x41          DC8 "DATA,"
   \              0x54 0x41    
   \              0x2C 0x00    
   \   00000006   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_3:
   \   00000000   0x66 0x69          DC8 "fileget,%s.%03d,%d\015\012"
   \              0x6C 0x65    
   \              0x67 0x65    
   \              0x74 0x2C    
   \              0x25 0x73    
   \              0x2E 0x25    
   \              0x30 0x33    
   \              0x64 0x2C    
   \              0x25 0x64    
   \              0x0D 0x0A    
   \              0x00         
   \   00000015   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_4:
   \   00000000   0x64 0x61          DC8 "dataget\015\012"
   \              0x74 0x61    
   \              0x67 0x65    
   \              0x74 0x0D    
   \              0x0A 0x00    
   \   0000000A   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_5:
   \   00000000   0x75 0x73          DC8 "usbota,%s=Normal!\015\012"
   \              0x62 0x6F    
   \              0x74 0x61    
   \              0x2C 0x25    
   \              0x73 0x3D    
   \              0x4E 0x6F    
   \              0x72 0x6D    
   \              0x61 0x6C    
   \              0x21 0x0D    
   \              0x0A 0x00    

   \                                 In section .rodata, align 4
   \                     ?_6:
   \   00000000   0x75 0x73          DC8 "usbota,%s=Abnormal!\015\012"
   \              0x62 0x6F    
   \              0x74 0x61    
   \              0x2C 0x25    
   \              0x73 0x3D    
   \              0x41 0x62    
   \              0x6E 0x6F    
   \              0x72 0x6D    
   \              0x61 0x6C    
   \              0x21 0x0D    
   \              0x0A 0x00    
   \   00000016   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_7:
   \   00000000   0x75 0x73          DC8 "usbgpsota,%s=Normal!\015\012"
   \              0x62 0x67    
   \              0x70 0x73    
   \              0x6F 0x74    
   \              0x61 0x2C    
   \              0x25 0x73    
   \              0x3D 0x4E    
   \              0x6F 0x72    
   \              0x6D 0x61    
   \              0x6C 0x21    
   \              0x0D 0x0A    
   \              0x00         
   \   00000017   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     ?_8:
   \   00000000   0x75 0x73          DC8 "usbgpsota,%s=Abnormal!\015\012"
   \              0x62 0x67    
   \              0x70 0x73    
   \              0x6F 0x74    
   \              0x61 0x2C    
   \              0x25 0x73    
   \              0x3D 0x41    
   \              0x62 0x6E    
   \              0x6F 0x72    
   \              0x6D 0x61    
   \              0x6C 0x21    
   \              0x0D 0x0A    
   \              0x00         
   \   00000019   0x00 0x00          DC8 0, 0, 0
   \              0x00         
    875          
    876          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   man_usb_100ms_main
         8   -> man_usb_chk_config
      16   man_usb_callback
        16   -> __aeabi_memcpy
       8   man_usb_chk_config
         8   -> ctrl_USB_chk_config
       8   man_usb_data_send
         8   -> ctrl_USB_send
       8   man_usb_data_send_crlf
         8   -> man_usb_data_send
       4   man_usb_get_data
       0   man_usb_get_file_info
      16   man_usb_init
        16   -> __aeabi_memset
        16   -> ctrl_USB_init
        16   -> ctrl_USB_recv_start
        16   -> man_usb_req_reset
        16   -> seSysSleepMS
      40   man_usb_main
        40   -> __aeabi_memcpy
        40   -> __aeabi_memset
        40   -> man_cmd_analyze
        40   -> man_ope_get_reset_mode
        40   -> man_timer_get_1ms_count
        40   -> man_timer_get_elapsed_time
        40   -> man_usb_data_send
        40   -> man_usb_return_callback
        40   -> man_usb_return_callback_data
        40   -> man_usb_set_sequense
        40   -> memcmp
        40   -> sprintf
        40   -> strlen
       0   man_usb_ota_close
       0   man_usb_ota_open
       0   man_usb_req_cmd_start
       0   man_usb_req_cmd_stop
       8   man_usb_req_reset
         8   -> ctrl_usb_req_reset
       8   man_usb_return_callback
         8   -- Indirect call
         8   -> man_usb_set_sequense
       8   man_usb_return_callback_data
         8   -- Indirect call
         8   -> man_usb_set_sequense
      16   man_usb_rpt_send
        16   -- Indirect call
        16   -> man_usb_data_send
      12   man_usb_send_file_info
      16   man_usb_send_usbgpsota_result
        16   -> __aeabi_memset
        16   -> man_data_get_other
        16   -> man_usb_data_send
        16   -> sprintf
        16   -> strlen
      16   man_usb_send_usbota_result
        16   -> __aeabi_memset
        16   -> man_data_get_other
        16   -> man_usb_data_send
        16   -> sprintf
        16   -> strlen
      24   man_usb_set_file_info
        24   -> __aeabi_memcpy
       8   man_usb_set_sequense
         8   -> man_dbglog_setting


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable12
       4  ??DataTable12_1
       4  ??DataTable13
       4  ??DataTable13_1
       4  ??DataTable14
       4  ??DataTable15
       4  ??DataTable17
       4  ??DataTable17_1
       4  ??DataTable17_2
       4  ??DataTable18
       4  ??DataTable18_1
       4  ??DataTable18_10
       4  ??DataTable18_11
       4  ??DataTable18_12
       4  ??DataTable18_13
       4  ??DataTable18_14
       4  ??DataTable18_15
       4  ??DataTable18_16
       4  ??DataTable18_17
       4  ??DataTable18_18
       4  ??DataTable18_2
       4  ??DataTable18_3
       4  ??DataTable18_4
       4  ??DataTable18_5
       4  ??DataTable18_6
       4  ??DataTable18_7
       4  ??DataTable18_8
       4  ??DataTable18_9
       4  ??DataTable5
       4  ??DataTable5_1
       4  ??DataTable5_10
       4  ??DataTable5_11
       4  ??DataTable5_12
       4  ??DataTable5_13
       4  ??DataTable5_14
       4  ??DataTable5_2
       4  ??DataTable5_3
       4  ??DataTable5_4
       4  ??DataTable5_5
       4  ??DataTable5_6
       4  ??DataTable5_7
       4  ??DataTable5_8
       4  ??DataTable5_9
       4  ??DataTable6
       4  ??DataTable6_1
       4  ??DataTable9
      12  ?_0
       4  ?_1
       8  ?_2
      24  ?_3
      12  ?_4
      20  ?_5
      24  ?_6
      24  ?_7
      28  ?_8
       8  man_usb_100ms_main
      54  man_usb_callback
      26  man_usb_chk_config
      24  man_usb_data_send
      24  man_usb_data_send_crlf
      42  man_usb_get_data
       4  man_usb_get_file_info
      56  man_usb_init
     922  man_usb_main
       8  man_usb_ota_close
       8  man_usb_ota_open
       8  man_usb_req_cmd_start
       8  man_usb_req_cmd_stop
       8  man_usb_req_reset
      42  man_usb_return_callback
      48  man_usb_return_callback_data
      28  man_usb_rpt_send
      50  man_usb_send_file_info
      72  man_usb_send_usbgpsota_result
      72  man_usb_send_usbota_result
      20  man_usb_set_file_info
      32  man_usb_set_sequense
    5368  man_usb_work
     672  respons
       4  usb_console_flag
       4  usb_log_flag

 
 6 048 bytes in section .bss
   156 bytes in section .rodata
 1 748 bytes in section .text
 
 1 748 bytes of CODE  memory
   156 bytes of CONST memory
 6 048 bytes of DATA  memory

Errors: none
Warnings: none
