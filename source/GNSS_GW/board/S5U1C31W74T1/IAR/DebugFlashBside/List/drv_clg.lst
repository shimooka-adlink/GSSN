###############################################################################
#
# IAR ANSI C/C++ Compiler V7.80.4.12462/W32 for ARM       21/May/2019  17:01:18
# Copyright 1999-2017 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  C:\GNSS\Software\rJ105\source\GNSS_GW\driver\clg\drv_clg.c
#    Command line =  
#        C:\GNSS\Software\rJ105\source\GNSS_GW\driver\clg\drv_clg.c -D
#        __TARGET_ARCH_7_M -D S1C31W74 -D GNSS_GW_SIDE_B -lCN
#        C:\GNSS\Software\rJ105\source\GNSS_GW\board\S5U1C31W74T1\IAR\DebugFlashBside\List
#        -lA
#        C:\GNSS\Software\rJ105\source\GNSS_GW\board\S5U1C31W74T1\IAR\DebugFlashBside\List
#        --diag_suppress Pe177,Pe111,Pa082 -o
#        C:\GNSS\Software\rJ105\source\GNSS_GW\board\S5U1C31W74T1\IAR\DebugFlashBside\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M0+ -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.5\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\GNSS\Software\rJ105\source\GNSS_GW\board\S5U1C31W74T1\IAR\ -I
#        C:\GNSS\Software\rJ105\source\GNSS_GW\board\S5U1C31W74T1\IAR\..\..\..\
#        -I "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.5\arm\CMSIS\Include\" -I "C:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 7.5\arm\inc\Epson\" -I
#        C:\GNSS\Software\rJ105\source\GNSS_GW\board\S5U1C31W74T1\IAR\..\..\..\..\..\CMSIS\Device\S1C31W74\Include\
#        -I
#        C:\GNSS\Software\rJ105\source\GNSS_GW\board\S5U1C31W74T1\IAR\..\..\..\..\..\CMSIS\Driver\Include\
#        -I
#        C:\GNSS\Software\rJ105\source\GNSS_GW\board\S5U1C31W74T1\IAR\..\..\..\..\..\sePeriphLibrary\
#        -I
#        C:\GNSS\Software\rJ105\source\GNSS_GW\board\S5U1C31W74T1\IAR\..\..\..\..\..\board\S5U1C31W74T1\
#        -I
#        C:\GNSS\Software\rJ105\source\GNSS_GW\board\S5U1C31W74T1\IAR\..\..\..\..\..\USBStack\INC\
#        -I
#        C:\GNSS\Software\rJ105\source\GNSS_GW\board\S5U1C31W74T1\IAR\..\..\..\include\
#        -Ol
#    Locale       =  Japanese_Japan.932
#    List file    =  
#        C:\GNSS\Software\rJ105\source\GNSS_GW\board\S5U1C31W74T1\IAR\DebugFlashBside\List\drv_clg.lst
#    Object file  =  
#        C:\GNSS\Software\rJ105\source\GNSS_GW\board\S5U1C31W74T1\IAR\DebugFlashBside\Obj\drv_clg.o
#
###############################################################################

C:\GNSS\Software\rJ105\source\GNSS_GW\driver\clg\drv_clg.c
      1          /**
      2            ******************************************************************************
      3            * @file    drv_clg.c
      4            * @author  コア
      5            * @version V1.0
      6            * @date    2017.10.2
      7            * @brief   SLEEPモードとHALTモード機能を提供する
      8            ******************************************************************************
      9            $Id: drv_clg.c 203 2018-06-15 07:23:42Z shitaoka $
     10            * @attention
     11            *
     12            *****************************************************************************
     13            */ 
     14          
     15          #include <string.h>
     16          #include <stdio.h>
     17          #include <stdlib.h>
     18          #include "board.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void NVIC_EnableIRQ(IRQn_Type)
   \                     NVIC_EnableIRQ: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB240             SXTB     R0,R0
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD405             BMI      ??NVIC_EnableIRQ_0
   \   00000008   0x2101             MOVS     R1,#+1
   \   0000000A   0x06C0             LSLS     R0,R0,#+27       ;; ZeroExtS R0,R0,#+27,#+27
   \   0000000C   0x0EC0             LSRS     R0,R0,#+27
   \   0000000E   0x4081             LSLS     R1,R1,R0
   \   00000010   0x....             LDR      R0,??DataTable4  ;; 0xe000e100
   \   00000012   0x6001             STR      R1,[R0, #+0]
   \                     ??NVIC_EnableIRQ_0: (+1)
   \   00000014   0xBD00             POP      {PC}             ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp uint32_t NVIC_GetEnableIRQ(IRQn_Type)
   \                     NVIC_GetEnableIRQ: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB240             SXTB     R0,R0
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD408             BMI      ??NVIC_GetEnableIRQ_0
   \   00000008   0x....             LDR      R1,??DataTable4  ;; 0xe000e100
   \   0000000A   0x6809             LDR      R1,[R1, #+0]
   \   0000000C   0x06C0             LSLS     R0,R0,#+27       ;; ZeroExtS R0,R0,#+27,#+27
   \   0000000E   0x0EC0             LSRS     R0,R0,#+27
   \   00000010   0x40C1             LSRS     R1,R1,R0
   \   00000012   0x0008             MOVS     R0,R1
   \   00000014   0x07C0             LSLS     R0,R0,#+31       ;; ZeroExtS R0,R0,#+31,#+31
   \   00000016   0x0FC0             LSRS     R0,R0,#+31
   \   00000018   0xE000             B        ??NVIC_GetEnableIRQ_1
   \                     ??NVIC_GetEnableIRQ_0: (+1)
   \   0000001A   0x2000             MOVS     R0,#+0
   \                     ??NVIC_GetEnableIRQ_1: (+1)
   \   0000001C   0xBD00             POP      {PC}             ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void NVIC_DisableIRQ(IRQn_Type)
   \                     NVIC_DisableIRQ: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB240             SXTB     R0,R0
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD405             BMI      ??NVIC_DisableIRQ_0
   \   00000008   0x2101             MOVS     R1,#+1
   \   0000000A   0x06C0             LSLS     R0,R0,#+27       ;; ZeroExtS R0,R0,#+27,#+27
   \   0000000C   0x0EC0             LSRS     R0,R0,#+27
   \   0000000E   0x4081             LSLS     R1,R1,R0
   \   00000010   0x....             LDR      R0,??DataTable5  ;; 0xe000e180
   \   00000012   0x6001             STR      R1,[R0, #+0]
   \                     ??NVIC_DisableIRQ_0: (+1)
   \   00000014   0xBD00             POP      {PC}             ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void NVIC_SetPriority(IRQn_Type, uint32_t)
   \                     NVIC_SetPriority: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB240             SXTB     R0,R0
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD41B             BMI      ??NVIC_SetPriority_0
   \   00000008   0x....             LDR      R2,??DataTable5_1  ;; 0xe000e400
   \   0000000A   0xB240             SXTB     R0,R0
   \   0000000C   0x0883             LSRS     R3,R0,#+2
   \   0000000E   0x2404             MOVS     R4,#+4
   \   00000010   0x4363             MULS     R3,R4,R3
   \   00000012   0x58D2             LDR      R2,[R2, R3]
   \   00000014   0x23FF             MOVS     R3,#+255
   \   00000016   0x0784             LSLS     R4,R0,#+30       ;; ZeroExtS R4,R0,#+30,#+30
   \   00000018   0x0FA4             LSRS     R4,R4,#+30
   \   0000001A   0x2508             MOVS     R5,#+8
   \   0000001C   0x436C             MULS     R4,R5,R4
   \   0000001E   0x40A3             LSLS     R3,R3,R4
   \   00000020   0x439A             BICS     R2,R2,R3
   \   00000022   0x0189             LSLS     R1,R1,#+6
   \   00000024   0xB2C9             UXTB     R1,R1
   \   00000026   0x0783             LSLS     R3,R0,#+30       ;; ZeroExtS R3,R0,#+30,#+30
   \   00000028   0x0F9B             LSRS     R3,R3,#+30
   \   0000002A   0x2408             MOVS     R4,#+8
   \   0000002C   0x4363             MULS     R3,R4,R3
   \   0000002E   0x4099             LSLS     R1,R1,R3
   \   00000030   0x4311             ORRS     R1,R1,R2
   \   00000032   0x....             LDR      R2,??DataTable5_1  ;; 0xe000e400
   \   00000034   0xB240             SXTB     R0,R0
   \   00000036   0x0880             LSRS     R0,R0,#+2
   \   00000038   0x2304             MOVS     R3,#+4
   \   0000003A   0x4358             MULS     R0,R3,R0
   \   0000003C   0x5011             STR      R1,[R2, R0]
   \   0000003E   0xE020             B        ??NVIC_SetPriority_1
   \                     ??NVIC_SetPriority_0: (+1)
   \   00000040   0x....             LDR      R3,??DataTable5_2  ;; 0xe000ed1c
   \   00000042   0xB240             SXTB     R0,R0
   \   00000044   0x0702             LSLS     R2,R0,#+28       ;; ZeroExtS R2,R0,#+28,#+28
   \   00000046   0x0F12             LSRS     R2,R2,#+28
   \   00000048   0x3A08             SUBS     R2,R2,#+8
   \   0000004A   0x0892             LSRS     R2,R2,#+2
   \   0000004C   0x2404             MOVS     R4,#+4
   \   0000004E   0x4362             MULS     R2,R4,R2
   \   00000050   0x....             LDR      R4,??DataTable5_2  ;; 0xe000ed1c
   \   00000052   0xB240             SXTB     R0,R0
   \   00000054   0x0705             LSLS     R5,R0,#+28       ;; ZeroExtS R5,R0,#+28,#+28
   \   00000056   0x0F2D             LSRS     R5,R5,#+28
   \   00000058   0x3D08             SUBS     R5,R5,#+8
   \   0000005A   0x08AD             LSRS     R5,R5,#+2
   \   0000005C   0x2604             MOVS     R6,#+4
   \   0000005E   0x4375             MULS     R5,R6,R5
   \   00000060   0x5964             LDR      R4,[R4, R5]
   \   00000062   0x25FF             MOVS     R5,#+255
   \   00000064   0x0786             LSLS     R6,R0,#+30       ;; ZeroExtS R6,R0,#+30,#+30
   \   00000066   0x0FB6             LSRS     R6,R6,#+30
   \   00000068   0x2708             MOVS     R7,#+8
   \   0000006A   0x437E             MULS     R6,R7,R6
   \   0000006C   0x40B5             LSLS     R5,R5,R6
   \   0000006E   0x43AC             BICS     R4,R4,R5
   \   00000070   0x0189             LSLS     R1,R1,#+6
   \   00000072   0xB2C9             UXTB     R1,R1
   \   00000074   0x0780             LSLS     R0,R0,#+30       ;; ZeroExtS R0,R0,#+30,#+30
   \   00000076   0x0F80             LSRS     R0,R0,#+30
   \   00000078   0x2508             MOVS     R5,#+8
   \   0000007A   0x4368             MULS     R0,R5,R0
   \   0000007C   0x4081             LSLS     R1,R1,R0
   \   0000007E   0x4321             ORRS     R1,R1,R4
   \   00000080   0x5099             STR      R1,[R3, R2]
   \                     ??NVIC_SetPriority_1: (+1)
   \   00000082   0xBDF0             POP      {R4-R7,PC}       ;; return
     19          #include "system_manager.h"
     20          #include "settings.h"
     21          #include "se_clg.h"
     22          #include "se_t16.h"
     23          #include "se_common.h"
     24          #include "se_pport.h"
     25          #include "drv_gpio.h"
     26          #include "se_rtca.h"
     27          
     28          #include "se_usb.h"
     29          #include "se_svd2.h"
     30          
     31          #include "se_svd2.h"
     32          
     33          
     34          #include "gnss_gw_common.h"
     35          #include "man_usb.h"
     36          #include "man_data.h"
     37          #include "man_gpio.h"
     38          #include "man_charge.h"
     39          #include "ctrl_I2C0.h"
     40          #include "ctrl_W25Q.h"
     41              
     42          #include "ctrl_BQ24160A.h"
     43          
     44          
     45          #pragma section = "DRV_PRG_BLOCK"
     46          

   \                                 In section .bss, align 2
     47          static uint16_t AlarmOccured;
   \                     AlarmOccured:
   \   00000000                      DS8 2

   \                                 In section .bss, align 2
     48          static uint16_t extOnOccured;
   \                     extOnOccured:
   \   00000000                      DS8 2

   \                                 In section .bss, align 2
     49          static uint16_t extSwOccured;
   \                     extSwOccured:
   \   00000000                      DS8 2

   \                                 In section .bss, align 2
     50          static uint16_t UsbOccured;
   \                     UsbOccured:
   \   00000000                      DS8 2

   \                                 In section .bss, align 2
     51          static uint16_t offSwOccured;
   \                     offSwOccured:
   \   00000000                      DS8 2

   \                                 In section .bss, align 2
     52          static uint16_t NmiIntOccured;
   \                     NmiIntOccured:
   \   00000000                      DS8 2
     53          
     54          
     55          /********************************************************************/
     56          /*!
     57           * \name	drv_clg_init
     58           * \brief	初期化を行います
     59           * \param	なし
     60           * \return   
     61           * \note	
     62           */
     63          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
     64          void drv_clg_init( void ) 
     65          {
   \                     drv_clg_init: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
     66          	// SLEEPモード時のCLOCKの動作を決めます。
     67          	// USB用のクロックは停止
     68          	// seDISABLE : CLOCKは動作
     69          	// seENABLE  : CLOCKは停止
     70          	seCLG_SetOperInSlp( seCLG_IOSC, seENABLE );		// メインクロック停止
   \   00000002   0x2101             MOVS     R1,#+1
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x.... 0x....      BL       seCLG_SetOperInSlp
     71          	seCLG_SetOperInSlp( seCLG_OSC3, seENABLE );		// USBクロック停止
   \   0000000A   0x2101             MOVS     R1,#+1
   \   0000000C   0x2002             MOVS     R0,#+2
   \   0000000E   0x.... 0x....      BL       seCLG_SetOperInSlp
     72          	seCLG_SetOperInSlp( seCLG_OSC1, seDISABLE );	// RTCクロック動作
   \   00000012   0x2100             MOVS     R1,#+0
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0x.... 0x....      BL       seCLG_SetOperInSlp
     73          }
   \   0000001A   0xBD01             POP      {R0,PC}          ;; return
     74          
     75          /********************************************************************/
     76          /*!
     77           * \name	sleep_mode
     78           * \brief	OFFモードでのSLEEPモードに入ります
     79           * \param	なし
     80           * \return  1: POWER EXT MODE SW
     81           *          2: 外部電源ON/OFF信号
     82           * \note	起床条件( INPORT5 : sePPORT_P04)を設定  :: 外部電源ON信号
     83           *                    INPORT18: sePPORT_P05)を設定  :: 外部電源(USB)ON信号
     84           *                    INPORT9 :                     :: OFF MODE SW(OFF)
     85           */
     86          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
     87          int sleep_mode( void ) 
     88          {
   \                     sleep_mode: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
     89          	int32_t		ret;
     90          	uint32_t	get_irq_usb;
     91          	uint32_t	get_irq_svd2;
     92          	uint32_t	get_irq_port;
     93           
     94                 ctrl_BQ24160A_init_setting(0xffff);
   \   00000002   0x....             LDR      R0,??DataTable5_3  ;; 0xffff
   \   00000004   0x.... 0x....      BL       ctrl_BQ24160A_init_setting
     95          
     96          
     97          	// USB割り込み 無効
     98          	get_irq_port = NVIC_GetEnableIRQ( PORT_IRQn );
   \   00000008   0x2002             MOVS     R0,#+2
   \   0000000A   0x.... 0x....      BL       NVIC_GetEnableIRQ
   \   0000000E   0x0006             MOVS     R6,R0
     99          	get_irq_usb = NVIC_GetEnableIRQ( USB_IRQn );
   \   00000010   0x2013             MOVS     R0,#+19
   \   00000012   0x.... 0x....      BL       NVIC_GetEnableIRQ
   \   00000016   0x0004             MOVS     R4,R0
    100          	get_irq_svd2 = NVIC_GetEnableIRQ( SVD2_1_IRQn );
   \   00000018   0x2014             MOVS     R0,#+20
   \   0000001A   0x.... 0x....      BL       NVIC_GetEnableIRQ
   \   0000001E   0x0005             MOVS     R5,R0
    101          	if (get_irq_usb != 0) {
   \   00000020   0x2C00             CMP      R4,#+0
   \   00000022   0xD002             BEQ      ??sleep_mode_0
    102          		NVIC_DisableIRQ( USB_IRQn );
   \   00000024   0x2013             MOVS     R0,#+19
   \   00000026   0x.... 0x....      BL       NVIC_DisableIRQ
    103          	}
    104          	if (get_irq_svd2 != 0) {
   \                     ??sleep_mode_0: (+1)
   \   0000002A   0x2D00             CMP      R5,#+0
   \   0000002C   0xD002             BEQ      ??sleep_mode_1
    105          		NVIC_DisableIRQ( SVD2_1_IRQn );
   \   0000002E   0x2014             MOVS     R0,#+20
   \   00000030   0x.... 0x....      BL       NVIC_DisableIRQ
    106          	}
    107          
    108          	// SW
    109          	sePPORT_EnableInt( INPORT5,  sePPORT_INT_EDGE_FALLING );		// PORT割り込み(立ち下がり)を有効にする
   \                     ??sleep_mode_1: (+1)
   \   00000034   0x2101             MOVS     R1,#+1
   \   00000036   0x2004             MOVS     R0,#+4
   \   00000038   0x.... 0x....      BL       sePPORT_EnableInt
    110          	sePPORT_EnableInt( INPORT18, sePPORT_INT_EDGE_FALLING );		// PORT割り込み(立ち下がり)を有効にする
   \   0000003C   0x2101             MOVS     R1,#+1
   \   0000003E   0x2005             MOVS     R0,#+5
   \   00000040   0x.... 0x....      BL       sePPORT_EnableInt
    111          	sePPORT_EnableInt( INPORT9, sePPORT_INT_EDGE_RISING );			// PORT割り込み(立上り)を有効にする
   \   00000044   0x2100             MOVS     R1,#+0
   \   00000046   0x2033             MOVS     R0,#+51
   \   00000048   0x.... 0x....      BL       sePPORT_EnableInt
    112          	sePPORT_DisableInt(INPORT12);									// USB VBUS PORT割り込みを無効にする
   \   0000004C   0x2048             MOVS     R0,#+72
   \   0000004E   0x.... 0x....      BL       sePPORT_DisableInt
    113          //	NVIC_ClearPendingIRQ( PORT_IRQn ); 								// 
    114          	NVIC_EnableIRQ( PORT_IRQn );									// PORT割り込み許可
   \   00000052   0x2002             MOVS     R0,#+2
   \   00000054   0x.... 0x....      BL       NVIC_EnableIRQ
    115          
    116          	// UART割り込み 無効
    117          	NVIC_DisableIRQ( UART2_0_IRQn );
   \   00000058   0x2006             MOVS     R0,#+6
   \   0000005A   0x.... 0x....      BL       NVIC_DisableIRQ
    118          	NVIC_DisableIRQ( UART2_1_IRQn );
   \   0000005E   0x200C             MOVS     R0,#+12
   \   00000060   0x.... 0x....      BL       NVIC_DisableIRQ
    119          
    120          	// I2C CH0 使用終了
    121          	ctrl_I2C0_end();
   \   00000064   0x.... 0x....      BL       ctrl_I2C0_end
    122          	// SPIA CH0 使用終了
    123          	ctrl_SPIA_end();
   \   00000068   0x.... 0x....      BL       ctrl_SPIA_end
    124          	// 低消費電力設定
    125          	man_gpio_3p3v_power(MAN_GPIO_CTRL_OFF);
   \   0000006C   0x2000             MOVS     R0,#+0
   \   0000006E   0x.... 0x....      BL       man_gpio_3p3v_power
    126          
    127          	// sleep
    128          	extOnOccured = seINTERRUPT_NOT_OCCURRED;
   \   00000072   0x2000             MOVS     R0,#+0
   \   00000074   0x....             LDR      R1,??DataTable5_4
   \   00000076   0x8008             STRH     R0,[R1, #+0]
    129          	UsbOccured   = seINTERRUPT_NOT_OCCURRED;
   \   00000078   0x2000             MOVS     R0,#+0
   \   0000007A   0x....             LDR      R1,??DataTable5_5
   \   0000007C   0x8008             STRH     R0,[R1, #+0]
    130          	offSwOccured = seINTERRUPT_NOT_OCCURRED;
   \   0000007E   0x2000             MOVS     R0,#+0
   \   00000080   0x....             LDR      R1,??DataTable5_6
   \   00000082   0x8008             STRH     R0,[R1, #+0]
    131          	while (1) {
    132          		setSleep();
   \                     ??sleep_mode_2: (+1)
   \   00000084   0x.... 0x....      BL       setSleep
    133          		if (extOnOccured != seINTERRUPT_NOT_OCCURRED) break;
   \   00000088   0x....             LDR      R0,??DataTable5_4
   \   0000008A   0x8800             LDRH     R0,[R0, #+0]
   \   0000008C   0x2800             CMP      R0,#+0
   \   0000008E   0xD107             BNE      ??sleep_mode_3
    134          		if (UsbOccured   != seINTERRUPT_NOT_OCCURRED) break;
   \                     ??sleep_mode_4: (+1)
   \   00000090   0x....             LDR      R0,??DataTable5_5
   \   00000092   0x8800             LDRH     R0,[R0, #+0]
   \   00000094   0x2800             CMP      R0,#+0
   \   00000096   0xD103             BNE      ??sleep_mode_3
    135          		if (offSwOccured != seINTERRUPT_NOT_OCCURRED) break;
   \                     ??sleep_mode_5: (+1)
   \   00000098   0x....             LDR      R0,??DataTable5_6
   \   0000009A   0x8800             LDRH     R0,[R0, #+0]
   \   0000009C   0x2800             CMP      R0,#+0
   \   0000009E   0xD0F1             BEQ      ??sleep_mode_2
    136          	};
    137          
    138          	// 低消費電力解除
    139          	man_gpio_3p3v_power(MAN_GPIO_CTRL_ON);
   \                     ??sleep_mode_3: (+1)
   \   000000A0   0x2001             MOVS     R0,#+1
   \   000000A2   0x.... 0x....      BL       man_gpio_3p3v_power
    140          	// SPIA CH0 使用再開
    141          	ctrl_SPIA_re_start();
   \   000000A6   0x.... 0x....      BL       ctrl_SPIA_re_start
    142          	// I2C CH0使用再開
    143          	ctrl_I2C0_re_start();
   \   000000AA   0x.... 0x....      BL       ctrl_I2C0_re_start
    144          
    145          	// UART割り込み 有効
    146          	NVIC_EnableIRQ( UART2_0_IRQn );
   \   000000AE   0x2006             MOVS     R0,#+6
   \   000000B0   0x.... 0x....      BL       NVIC_EnableIRQ
    147          	NVIC_EnableIRQ( UART2_1_IRQn );
   \   000000B4   0x200C             MOVS     R0,#+12
   \   000000B6   0x.... 0x....      BL       NVIC_EnableIRQ
    148          
    149          	sePPORT_DisableInt( INPORT9 );									// PORT割り込みを無効にする
   \   000000BA   0x2033             MOVS     R0,#+51
   \   000000BC   0x.... 0x....      BL       sePPORT_DisableInt
    150          	sePPORT_DisableInt( INPORT5 );									// PORT割り込みを無効にする
   \   000000C0   0x2004             MOVS     R0,#+4
   \   000000C2   0x.... 0x....      BL       sePPORT_DisableInt
    151          	sePPORT_DisableInt( INPORT18);									// PORT割り込みを無効にする
   \   000000C6   0x2005             MOVS     R0,#+5
   \   000000C8   0x.... 0x....      BL       sePPORT_DisableInt
    152          	sePPORT_EnableInt( INPORT12, sePPORT_INT_EDGE_RISING );			// USB VBUS PORT割り込み(rising edge)
   \   000000CC   0x2100             MOVS     R1,#+0
   \   000000CE   0x2048             MOVS     R0,#+72
   \   000000D0   0x.... 0x....      BL       sePPORT_EnableInt
    153          
    154          	// USB割り込みを元に戻す
    155          	if (get_irq_usb != 0) {
   \   000000D4   0x2C00             CMP      R4,#+0
   \   000000D6   0xD002             BEQ      ??sleep_mode_6
    156          		NVIC_EnableIRQ( USB_IRQn );
   \   000000D8   0x2013             MOVS     R0,#+19
   \   000000DA   0x.... 0x....      BL       NVIC_EnableIRQ
    157          	}
    158          	if (get_irq_svd2 != 0) {
   \                     ??sleep_mode_6: (+1)
   \   000000DE   0x2D00             CMP      R5,#+0
   \   000000E0   0xD002             BEQ      ??sleep_mode_7
    159          		NVIC_EnableIRQ( SVD2_1_IRQn );
   \   000000E2   0x2014             MOVS     R0,#+20
   \   000000E4   0x.... 0x....      BL       NVIC_EnableIRQ
    160          	}
    161          	if (get_irq_port == 0) {
   \                     ??sleep_mode_7: (+1)
   \   000000E8   0x2E00             CMP      R6,#+0
   \   000000EA   0xD102             BNE      ??sleep_mode_8
    162          		NVIC_DisableIRQ( PORT_IRQn );
   \   000000EC   0x2002             MOVS     R0,#+2
   \   000000EE   0x.... 0x....      BL       NVIC_DisableIRQ
    163          	}
    164          
    165          	// 戻り値設定
    166          	if (UsbOccured != seINTERRUPT_NOT_OCCURRED) {
   \                     ??sleep_mode_8: (+1)
   \   000000F2   0x....             LDR      R0,??DataTable5_5
   \   000000F4   0x8800             LDRH     R0,[R0, #+0]
   \   000000F6   0x2800             CMP      R0,#+0
   \   000000F8   0xD014             BEQ      ??sleep_mode_9
    167          		if ( !seUSB_IsVbusConnected() ) {
   \   000000FA   0x.... 0x....      BL       seUSB_IsVbusConnected
   \   000000FE   0x2800             CMP      R0,#+0
   \   00000100   0xD10E             BNE      ??sleep_mode_10
    168          			// USB VBUS端子=='H'を確認する
    169          			if (sePPORT_GetInput(INPORT12) != 0) {
   \   00000102   0x2048             MOVS     R0,#+72
   \   00000104   0x.... 0x....      BL       sePPORT_GetInput
   \   00000108   0x2800             CMP      R0,#+0
   \   0000010A   0xD009             BEQ      ??sleep_mode_10
    170          				// USB VBUS割り込み処理
    171          				seUSB_ConfigurePortsForUsb( seUSB_PERIPH );
   \   0000010C   0x2001             MOVS     R0,#+1
   \   0000010E   0x.... 0x....      BL       seUSB_ConfigurePortsForUsb
    172          				seUSB_ConfSvdDetectDisconnect();
   \   00000112   0x.... 0x....      BL       seUSB_ConfSvdDetectDisconnect
    173          				seSVD2_Start( SVD2_1 );
   \   00000116   0x....             LDR      R0,??DataTable5_7  ;; 0x40000980
   \   00000118   0x.... 0x....      BL       seSVD2_Start
    174          				seUSB_Attach();
   \   0000011C   0x.... 0x....      BL       seUSB_Attach
    175          			}
    176          		}
    177          		ret = 2;
   \                     ??sleep_mode_10: (+1)
   \   00000120   0x2402             MOVS     R4,#+2
   \   00000122   0xE006             B        ??sleep_mode_11
    178          	}
    179          	else if (extOnOccured != seINTERRUPT_NOT_OCCURRED) {
   \                     ??sleep_mode_9: (+1)
   \   00000124   0x....             LDR      R0,??DataTable5_4
   \   00000126   0x8800             LDRH     R0,[R0, #+0]
   \   00000128   0x2800             CMP      R0,#+0
   \   0000012A   0xD001             BEQ      ??sleep_mode_12
    180          		ret = 2;
   \   0000012C   0x2402             MOVS     R4,#+2
   \   0000012E   0xE000             B        ??sleep_mode_11
    181          	}
    182          	else {
    183          		ret = 1;
   \                     ??sleep_mode_12: (+1)
   \   00000130   0x2401             MOVS     R4,#+1
    184          	}
    185          
    186                  ctrl_BQ24160A_init_setting(BQ24160A_REQ_TE_ON);
   \                     ??sleep_mode_11: (+1)
   \   00000132   0x2000             MOVS     R0,#+0
   \   00000134   0x.... 0x....      BL       ctrl_BQ24160A_init_setting
    187            
    188           	return ret;
   \   00000138   0x0020             MOVS     R0,R4
   \   0000013A   0xBD70             POP      {R4-R6,PC}       ;; return
    189          }
    190          
    191          
    192          /********************************************************************/
    193          /*!
    194           * \name	sleep_mode_exton
    195           * \brief	外部電源ONのSLEEPモードに入ります
    196           * \param	なし
    197           * \return  1: POWER EXT MODE SW
    198           *          2: 外部電源ON/OFF信号
    199           * \note	起床条件( INPORT5 : sePPORT_P04)を設定  :: 外部電源ON信号
    200           *                    INPORT18: sePPORT_P05)を設定  :: 外部電源(USB)ON信号
    201           *                    INPORT8 :                     :: POWER EXT MODE SW(OFF)
    202           */
    203          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    204          int32_t sleep_mode_exton( void ) 
    205          {
   \                     sleep_mode_exton: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
    206          	int32_t		ret;
    207          	uint32_t	get_irq_usb;
    208          	uint32_t	get_irq_svd2;
    209          	uint32_t	get_irq_port;
    210          
    211          #ifdef ADLINK_DEBUG_MESSAGE
    212                  sprintf(print_buf,"\r\n sleep_mode_exton()\r\n");
    213                 man_usb_data_send(print_buf,strlen(print_buf));
    214          #endif //ADLINK_DEBUG_MESSAGE
    215          
    216                 ctrl_BQ24160A_init_setting(0xffff);
   \   00000002   0x....             LDR      R0,??DataTable5_3  ;; 0xffff
   \   00000004   0x.... 0x....      BL       ctrl_BQ24160A_init_setting
    217          
    218          	// USB割り込み 無効
    219          	get_irq_port = NVIC_GetEnableIRQ( PORT_IRQn );
   \   00000008   0x2002             MOVS     R0,#+2
   \   0000000A   0x.... 0x....      BL       NVIC_GetEnableIRQ
   \   0000000E   0x0006             MOVS     R6,R0
    220          	get_irq_usb = NVIC_GetEnableIRQ( USB_IRQn );
   \   00000010   0x2013             MOVS     R0,#+19
   \   00000012   0x.... 0x....      BL       NVIC_GetEnableIRQ
   \   00000016   0x0004             MOVS     R4,R0
    221          	get_irq_svd2 = NVIC_GetEnableIRQ( SVD2_1_IRQn );
   \   00000018   0x2014             MOVS     R0,#+20
   \   0000001A   0x.... 0x....      BL       NVIC_GetEnableIRQ
   \   0000001E   0x0005             MOVS     R5,R0
    222          	if (get_irq_usb != 0) {
   \   00000020   0x2C00             CMP      R4,#+0
   \   00000022   0xD002             BEQ      ??sleep_mode_exton_0
    223          		NVIC_DisableIRQ( USB_IRQn );
   \   00000024   0x2013             MOVS     R0,#+19
   \   00000026   0x.... 0x....      BL       NVIC_DisableIRQ
    224          	}
    225          	if (get_irq_svd2 != 0) {
   \                     ??sleep_mode_exton_0: (+1)
   \   0000002A   0x2D00             CMP      R5,#+0
   \   0000002C   0xD002             BEQ      ??sleep_mode_exton_1
    226          		NVIC_DisableIRQ( SVD2_1_IRQn );
   \   0000002E   0x2014             MOVS     R0,#+20
   \   00000030   0x.... 0x....      BL       NVIC_DisableIRQ
    227          	}
    228          
    229          
    230          	// 起床条件を設定
    231          
    232          	// SW
    233          	sePPORT_EnableInt( INPORT5,  sePPORT_INT_EDGE_FALLING );		// PORT割り込み(立ち下がり)を有効にする
   \                     ??sleep_mode_exton_1: (+1)
   \   00000034   0x2101             MOVS     R1,#+1
   \   00000036   0x2004             MOVS     R0,#+4
   \   00000038   0x.... 0x....      BL       sePPORT_EnableInt
    234          	sePPORT_EnableInt( INPORT18, sePPORT_INT_EDGE_FALLING );		// PORT割り込み(立ち下がり)を有効にする
   \   0000003C   0x2101             MOVS     R1,#+1
   \   0000003E   0x2005             MOVS     R0,#+5
   \   00000040   0x.... 0x....      BL       sePPORT_EnableInt
    235          	sePPORT_EnableInt( INPORT8,  sePPORT_INT_EDGE_RISING );			// PORT割り込み(立ち上がり)を有効にする
   \   00000044   0x2100             MOVS     R1,#+0
   \   00000046   0x2032             MOVS     R0,#+50
   \   00000048   0x.... 0x....      BL       sePPORT_EnableInt
    236          	sePPORT_DisableInt(INPORT12);									// USB VBUS PORT割り込みを無効にする
   \   0000004C   0x2048             MOVS     R0,#+72
   \   0000004E   0x.... 0x....      BL       sePPORT_DisableInt
    237          //	NVIC_ClearPendingIRQ( PORT_IRQn ); 								// 
    238          	NVIC_EnableIRQ( PORT_IRQn );									// PORT割り込み許可
   \   00000052   0x2002             MOVS     R0,#+2
   \   00000054   0x.... 0x....      BL       NVIC_EnableIRQ
    239          
    240          	// UART割り込み 無効
    241          	NVIC_DisableIRQ( UART2_0_IRQn );
   \   00000058   0x2006             MOVS     R0,#+6
   \   0000005A   0x.... 0x....      BL       NVIC_DisableIRQ
    242          	NVIC_DisableIRQ( UART2_1_IRQn );
   \   0000005E   0x200C             MOVS     R0,#+12
   \   00000060   0x.... 0x....      BL       NVIC_DisableIRQ
    243          
    244          	// I2C CH0 使用終了
    245          	ctrl_I2C0_end();
   \   00000064   0x.... 0x....      BL       ctrl_I2C0_end
    246          	// SPIA CH0 使用終了
    247          	ctrl_SPIA_end();
   \   00000068   0x.... 0x....      BL       ctrl_SPIA_end
    248          	// 低消費電力設定
    249          	man_gpio_3p3v_power(MAN_GPIO_CTRL_OFF);
   \   0000006C   0x2000             MOVS     R0,#+0
   \   0000006E   0x.... 0x....      BL       man_gpio_3p3v_power
    250          
    251          	// sleep
    252          	extOnOccured = seINTERRUPT_NOT_OCCURRED;
   \   00000072   0x2000             MOVS     R0,#+0
   \   00000074   0x....             LDR      R1,??DataTable5_4
   \   00000076   0x8008             STRH     R0,[R1, #+0]
    253          	UsbOccured   = seINTERRUPT_NOT_OCCURRED;
   \   00000078   0x2000             MOVS     R0,#+0
   \   0000007A   0x....             LDR      R1,??DataTable5_5
   \   0000007C   0x8008             STRH     R0,[R1, #+0]
    254          	extSwOccured = seINTERRUPT_NOT_OCCURRED;
   \   0000007E   0x2000             MOVS     R0,#+0
   \   00000080   0x....             LDR      R1,??DataTable6
   \   00000082   0x8008             STRH     R0,[R1, #+0]
    255          	while (1) {
    256          		// Wait For Interrupt 
    257          		setSleep();
   \                     ??sleep_mode_exton_2: (+1)
   \   00000084   0x.... 0x....      BL       setSleep
    258          		if (extOnOccured != seINTERRUPT_NOT_OCCURRED) break;
   \   00000088   0x....             LDR      R0,??DataTable5_4
   \   0000008A   0x8800             LDRH     R0,[R0, #+0]
   \   0000008C   0x2800             CMP      R0,#+0
   \   0000008E   0xD107             BNE      ??sleep_mode_exton_3
    259          		if (UsbOccured   != seINTERRUPT_NOT_OCCURRED) break;
   \                     ??sleep_mode_exton_4: (+1)
   \   00000090   0x....             LDR      R0,??DataTable5_5
   \   00000092   0x8800             LDRH     R0,[R0, #+0]
   \   00000094   0x2800             CMP      R0,#+0
   \   00000096   0xD103             BNE      ??sleep_mode_exton_3
    260          		if (extSwOccured != seINTERRUPT_NOT_OCCURRED) break;
   \                     ??sleep_mode_exton_5: (+1)
   \   00000098   0x....             LDR      R0,??DataTable6
   \   0000009A   0x8800             LDRH     R0,[R0, #+0]
   \   0000009C   0x2800             CMP      R0,#+0
   \   0000009E   0xD0F1             BEQ      ??sleep_mode_exton_2
    261          	};
    262          
    263          	// 低消費電力解除
    264          	man_gpio_3p3v_power(MAN_GPIO_CTRL_ON);
   \                     ??sleep_mode_exton_3: (+1)
   \   000000A0   0x2001             MOVS     R0,#+1
   \   000000A2   0x.... 0x....      BL       man_gpio_3p3v_power
    265          	// SPIA CH0 使用再開
    266          	ctrl_SPIA_re_start();
   \   000000A6   0x.... 0x....      BL       ctrl_SPIA_re_start
    267          	// I2C CH0使用再開
    268          	ctrl_I2C0_re_start();
   \   000000AA   0x.... 0x....      BL       ctrl_I2C0_re_start
    269          
    270          	// UART割り込み 有効
    271          	NVIC_EnableIRQ( UART2_0_IRQn );
   \   000000AE   0x2006             MOVS     R0,#+6
   \   000000B0   0x.... 0x....      BL       NVIC_EnableIRQ
    272          	NVIC_EnableIRQ( UART2_1_IRQn );
   \   000000B4   0x200C             MOVS     R0,#+12
   \   000000B6   0x.... 0x....      BL       NVIC_EnableIRQ
    273          
    274          	sePPORT_DisableInt( INPORT8 );									// PORT割り込みを無効にする
   \   000000BA   0x2032             MOVS     R0,#+50
   \   000000BC   0x.... 0x....      BL       sePPORT_DisableInt
    275          	sePPORT_DisableInt( INPORT5 );									// PORT割り込みを無効にする
   \   000000C0   0x2004             MOVS     R0,#+4
   \   000000C2   0x.... 0x....      BL       sePPORT_DisableInt
    276          	sePPORT_DisableInt( INPORT18);									// PORT割り込みを無効にする
   \   000000C6   0x2005             MOVS     R0,#+5
   \   000000C8   0x.... 0x....      BL       sePPORT_DisableInt
    277          	sePPORT_EnableInt( INPORT12, sePPORT_INT_EDGE_RISING );			// USB VBUS PORT割り込み(rising edge)
   \   000000CC   0x2100             MOVS     R1,#+0
   \   000000CE   0x2048             MOVS     R0,#+72
   \   000000D0   0x.... 0x....      BL       sePPORT_EnableInt
    278          
    279          	// USB割り込みを元に戻す
    280          	if (get_irq_usb != 0) {
   \   000000D4   0x2C00             CMP      R4,#+0
   \   000000D6   0xD002             BEQ      ??sleep_mode_exton_6
    281          		NVIC_EnableIRQ( USB_IRQn );
   \   000000D8   0x2013             MOVS     R0,#+19
   \   000000DA   0x.... 0x....      BL       NVIC_EnableIRQ
    282          	}
    283          	if (get_irq_svd2 != 0) {
   \                     ??sleep_mode_exton_6: (+1)
   \   000000DE   0x2D00             CMP      R5,#+0
   \   000000E0   0xD002             BEQ      ??sleep_mode_exton_7
    284          		NVIC_EnableIRQ( SVD2_1_IRQn );
   \   000000E2   0x2014             MOVS     R0,#+20
   \   000000E4   0x.... 0x....      BL       NVIC_EnableIRQ
    285          	}
    286          	if (get_irq_port == 0) {
   \                     ??sleep_mode_exton_7: (+1)
   \   000000E8   0x2E00             CMP      R6,#+0
   \   000000EA   0xD102             BNE      ??sleep_mode_exton_8
    287          		NVIC_DisableIRQ( PORT_IRQn );
   \   000000EC   0x2002             MOVS     R0,#+2
   \   000000EE   0x.... 0x....      BL       NVIC_DisableIRQ
    288          	}
    289          
    290          	// 戻り値設定
    291          	if (UsbOccured != seINTERRUPT_NOT_OCCURRED) {
   \                     ??sleep_mode_exton_8: (+1)
   \   000000F2   0x....             LDR      R0,??DataTable5_5
   \   000000F4   0x8800             LDRH     R0,[R0, #+0]
   \   000000F6   0x2800             CMP      R0,#+0
   \   000000F8   0xD014             BEQ      ??sleep_mode_exton_9
    292          		if ( !seUSB_IsVbusConnected() ) {
   \   000000FA   0x.... 0x....      BL       seUSB_IsVbusConnected
   \   000000FE   0x2800             CMP      R0,#+0
   \   00000100   0xD10E             BNE      ??sleep_mode_exton_10
    293          			// USB VBUS端子=='H'を確認する
    294          			if (sePPORT_GetInput(INPORT12) != 0) {
   \   00000102   0x2048             MOVS     R0,#+72
   \   00000104   0x.... 0x....      BL       sePPORT_GetInput
   \   00000108   0x2800             CMP      R0,#+0
   \   0000010A   0xD009             BEQ      ??sleep_mode_exton_10
    295          				// USB VBUS割り込み処理
    296          				seUSB_ConfigurePortsForUsb( seUSB_PERIPH );
   \   0000010C   0x2001             MOVS     R0,#+1
   \   0000010E   0x.... 0x....      BL       seUSB_ConfigurePortsForUsb
    297          				seUSB_ConfSvdDetectDisconnect();
   \   00000112   0x.... 0x....      BL       seUSB_ConfSvdDetectDisconnect
    298          				seSVD2_Start( SVD2_1 );
   \   00000116   0x....             LDR      R0,??DataTable5_7  ;; 0x40000980
   \   00000118   0x.... 0x....      BL       seSVD2_Start
    299          				seUSB_Attach();
   \   0000011C   0x.... 0x....      BL       seUSB_Attach
    300          			}
    301          		}
    302          		ret = 2;
   \                     ??sleep_mode_exton_10: (+1)
   \   00000120   0x2402             MOVS     R4,#+2
   \   00000122   0xE006             B        ??sleep_mode_exton_11
    303          	}
    304          	else if (extOnOccured != seINTERRUPT_NOT_OCCURRED) {
   \                     ??sleep_mode_exton_9: (+1)
   \   00000124   0x....             LDR      R0,??DataTable5_4
   \   00000126   0x8800             LDRH     R0,[R0, #+0]
   \   00000128   0x2800             CMP      R0,#+0
   \   0000012A   0xD001             BEQ      ??sleep_mode_exton_12
    305          		ret = 2;
   \   0000012C   0x2402             MOVS     R4,#+2
   \   0000012E   0xE000             B        ??sleep_mode_exton_11
    306          	}
    307          	else {
    308          		ret = 1;
   \                     ??sleep_mode_exton_12: (+1)
   \   00000130   0x2401             MOVS     R4,#+1
    309          	}
    310          
    311          #ifdef ADLINK_DEBUG_MESSAGE
    312                  sprintf(print_buf,"\r\n sleep_mode_exton() end\r\n");
    313                 man_usb_data_send(print_buf,strlen(print_buf));
    314          #endif //ADLINK_DEBUG_MESSAGE
    315          //        ctrl_BQ24160A_init_setting();
    316          
    317                  ctrl_BQ24160A_init_setting(BQ24160A_REQ_TE_ON);
   \                     ??sleep_mode_exton_11: (+1)
   \   00000132   0x2000             MOVS     R0,#+0
   \   00000134   0x.... 0x....      BL       ctrl_BQ24160A_init_setting
    318          	return ret;
   \   00000138   0x0020             MOVS     R0,R4
   \   0000013A   0xBD70             POP      {R4-R6,PC}       ;; return
    319          }
    320          
    321           
    322          /********************************************************************/
    323          /*!
    324           * \name	sleep_mode_alarm
    325           * \brief	アラーム付きSLEEPモードに入ります
    326           * \param	hour : アラーム時間(時)
    327           *          min  : アラーム時間(分)
    328           *          sec  : アラーム時間(秒)
    329           * \return  1: POWER EXT MODE SW
    330           *          2: 外部電源ON/OFF信号
    331           *          3: alarm
    332           * \note	起床条件(INPORT5 : sePPORT_P04)を設定  :: 外部電源ON信号
    333           *                   INPORT18: sePPORT_P05)を設定  :: 外部電源(USB)ON信号
    334           *                   INPORT8 :                     :: POWER EXT MODE SW
    335           *                  (アラーム)                     :: 定刻時刻
    336           */
    337          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    338          int32_t sleep_mode_alarm( uint8_t hour, uint8_t min , uint8_t sec) 
    339          {
   \                     sleep_mode_alarm: (+1)
   \   00000000   0xB5F7             PUSH     {R0-R2,R4-R7,LR}
   \   00000002   0x0007             MOVS     R7,R0
    340          	seRTCA_AM_PM 	ind;
    341          	int32_t			ret;
    342          	uint32_t		get_irq_usb;
    343          	uint32_t		get_irq_svd2;
    344          	uint32_t		get_irq_port;
    345          
    346          #ifdef ADLINK_DEBUG_MESSAGE
    347                  sprintf(print_buf,"\r\n sleep_mode_alarm()\r\n");
    348                 man_usb_data_send(print_buf,strlen(print_buf));
    349          #endif //ADLINK_DEBUG_MESSAGE
    350          
    351                  ctrl_BQ24160A_init_setting(0xffff);   // Disable charging
   \   00000004   0x....             LDR      R0,??DataTable7  ;; 0xffff
   \   00000006   0x.... 0x....      BL       ctrl_BQ24160A_init_setting
    352          	// USB割り込み 無効
    353          	get_irq_port = NVIC_GetEnableIRQ( PORT_IRQn );
   \   0000000A   0x2002             MOVS     R0,#+2
   \   0000000C   0x.... 0x....      BL       NVIC_GetEnableIRQ
   \   00000010   0x0006             MOVS     R6,R0
    354          	get_irq_usb = NVIC_GetEnableIRQ( USB_IRQn );
   \   00000012   0x2013             MOVS     R0,#+19
   \   00000014   0x.... 0x....      BL       NVIC_GetEnableIRQ
   \   00000018   0x0005             MOVS     R5,R0
    355          	get_irq_svd2 = NVIC_GetEnableIRQ( SVD2_1_IRQn );
   \   0000001A   0x2014             MOVS     R0,#+20
   \   0000001C   0x.... 0x....      BL       NVIC_GetEnableIRQ
   \   00000020   0x0004             MOVS     R4,R0
    356          	if (get_irq_usb != 0) {
   \   00000022   0x2D00             CMP      R5,#+0
   \   00000024   0xD002             BEQ      ??sleep_mode_alarm_0
    357          		NVIC_DisableIRQ( USB_IRQn );
   \   00000026   0x2013             MOVS     R0,#+19
   \   00000028   0x.... 0x....      BL       NVIC_DisableIRQ
    358          	}
    359          	if (get_irq_svd2 != 0) {
   \                     ??sleep_mode_alarm_0: (+1)
   \   0000002C   0x2C00             CMP      R4,#+0
   \   0000002E   0xD002             BEQ      ??sleep_mode_alarm_1
    360          		NVIC_DisableIRQ( SVD2_1_IRQn );
   \   00000030   0x2014             MOVS     R0,#+20
   \   00000032   0x.... 0x....      BL       NVIC_DisableIRQ
    361          	}
    362          
    363          
    364          	// 起床条件を設定
    365          
    366          	// SW
    367          	sePPORT_EnableInt( INPORT5,  sePPORT_INT_EDGE_FALLING );		// PORT割り込み(立ち下がり)を有効にする
   \                     ??sleep_mode_alarm_1: (+1)
   \   00000036   0x2101             MOVS     R1,#+1
   \   00000038   0x2004             MOVS     R0,#+4
   \   0000003A   0x.... 0x....      BL       sePPORT_EnableInt
    368          	sePPORT_EnableInt( INPORT18, sePPORT_INT_EDGE_FALLING );		// PORT割り込み(立ち下がり)を有効にする
   \   0000003E   0x2101             MOVS     R1,#+1
   \   00000040   0x2005             MOVS     R0,#+5
   \   00000042   0x.... 0x....      BL       sePPORT_EnableInt
    369          	sePPORT_EnableInt( INPORT8,  sePPORT_INT_EDGE_RISING );			// PORT割り込み(立ち上がり)を有効にする
   \   00000046   0x2100             MOVS     R1,#+0
   \   00000048   0x2032             MOVS     R0,#+50
   \   0000004A   0x.... 0x....      BL       sePPORT_EnableInt
    370          	sePPORT_DisableInt(INPORT12);									// USB VBUS PORT割り込みを無効にする
   \   0000004E   0x2048             MOVS     R0,#+72
   \   00000050   0x.... 0x....      BL       sePPORT_DisableInt
    371          //	NVIC_ClearPendingIRQ( PORT_IRQn ); 								// 
    372          	NVIC_EnableIRQ( PORT_IRQn );									// PORT割り込み許可
   \   00000054   0x2002             MOVS     R0,#+2
   \   00000056   0x.... 0x....      BL       NVIC_EnableIRQ
    373          
    374          	// UART割り込み 無効
    375          	NVIC_DisableIRQ( UART2_0_IRQn );
   \   0000005A   0x2006             MOVS     R0,#+6
   \   0000005C   0x.... 0x....      BL       NVIC_DisableIRQ
    376          	NVIC_DisableIRQ( UART2_1_IRQn );
   \   00000060   0x200C             MOVS     R0,#+12
   \   00000062   0x.... 0x....      BL       NVIC_DisableIRQ
    377          
    378          	// アラームを設定する
    379          	if (hour >= 12) ind = seRTCA_HUR_RTCAP_PM;
   \   00000066   0xB2FF             UXTB     R7,R7
   \   00000068   0x2F0C             CMP      R7,#+12
   \   0000006A   0xDB01             BLT      ??sleep_mode_alarm_2
   \   0000006C   0x2301             MOVS     R3,#+1
   \   0000006E   0xE000             B        ??sleep_mode_alarm_3
    380          	else			ind = seRTCA_HUR_RTCAP_AM;
   \                     ??sleep_mode_alarm_2: (+1)
   \   00000070   0x2300             MOVS     R3,#+0
    381          
    382          	seRTCA_SetAlarm( hour, min, sec, ind );						// アラームを設定
   \                     ??sleep_mode_alarm_3: (+1)
   \   00000072   0xB2DB             UXTB     R3,R3
   \   00000074   0x4668             MOV      R0,SP
   \   00000076   0x7A02             LDRB     R2,[R0, #+8]
   \   00000078   0x4668             MOV      R0,SP
   \   0000007A   0x7901             LDRB     R1,[R0, #+4]
   \   0000007C   0x0038             MOVS     R0,R7
   \   0000007E   0xB2C0             UXTB     R0,R0
   \   00000080   0x.... 0x....      BL       seRTCA_SetAlarm
    383          	NVIC_SetPriority( RTC_IRQn, 3 );  					// 
   \   00000084   0x2103             MOVS     R1,#+3
   \   00000086   0x2004             MOVS     R0,#+4
   \   00000088   0x.... 0x....      BL       NVIC_SetPriority
    384          	NVIC_EnableIRQ( RTC_IRQn );							// RTCA割り込み許可
   \   0000008C   0x2004             MOVS     R0,#+4
   \   0000008E   0x.... 0x....      BL       NVIC_EnableIRQ
    385          
    386          	// I2C CH0 使用終了
    387          	ctrl_I2C0_end();
   \   00000092   0x.... 0x....      BL       ctrl_I2C0_end
    388          	// SPIA CH0 使用終了
    389          	ctrl_SPIA_end();
   \   00000096   0x.... 0x....      BL       ctrl_SPIA_end
    390          	// 低消費電力設定
    391          	man_gpio_3p3v_power(MAN_GPIO_CTRL_OFF);
   \   0000009A   0x2000             MOVS     R0,#+0
   \   0000009C   0x.... 0x....      BL       man_gpio_3p3v_power
    392          
    393          	// sleep
    394          	extOnOccured = seINTERRUPT_NOT_OCCURRED;
   \   000000A0   0x2000             MOVS     R0,#+0
   \   000000A2   0x....             LDR      R1,??DataTable9
   \   000000A4   0x8008             STRH     R0,[R1, #+0]
    395          	UsbOccured   = seINTERRUPT_NOT_OCCURRED;
   \   000000A6   0x2000             MOVS     R0,#+0
   \   000000A8   0x....             LDR      R1,??DataTable8
   \   000000AA   0x8008             STRH     R0,[R1, #+0]
    396          	AlarmOccured = seINTERRUPT_NOT_OCCURRED;
   \   000000AC   0x2000             MOVS     R0,#+0
   \   000000AE   0x....             LDR      R1,??DataTable8_1
   \   000000B0   0x8008             STRH     R0,[R1, #+0]
    397          	extSwOccured = seINTERRUPT_NOT_OCCURRED;
   \   000000B2   0x2000             MOVS     R0,#+0
   \   000000B4   0x....             LDR      R1,??DataTable6
   \   000000B6   0x8008             STRH     R0,[R1, #+0]
    398          #if 0
    399                  uint32_t cnt= 15;  //15秒
    400                  wdt_NMI_init(); 
    401                  wdt_start();
    402                  while(cnt-- > 0)
    403                  {
    404          		setSleep();
    405          		// Wait For Interrupt 
    406          		if (AlarmOccured != seINTERRUPT_NOT_OCCURRED) break;
    407          		if (extOnOccured != seINTERRUPT_NOT_OCCURRED) break;
    408          		if (UsbOccured   != seINTERRUPT_NOT_OCCURRED) break;
    409          		if (extSwOccured != seINTERRUPT_NOT_OCCURRED) break;
    410          	};
    411                  wdt_stop();
    412          #else
    413          	while (1) {
    414          		// Wait For Interrupt 
    415          		setSleep();
   \                     ??sleep_mode_alarm_4: (+1)
   \   000000B8   0x.... 0x....      BL       setSleep
    416          		if (AlarmOccured != seINTERRUPT_NOT_OCCURRED) break;
   \   000000BC   0x....             LDR      R0,??DataTable8_1
   \   000000BE   0x8800             LDRH     R0,[R0, #+0]
   \   000000C0   0x2800             CMP      R0,#+0
   \   000000C2   0xD10B             BNE      ??sleep_mode_alarm_5
    417          		if (extOnOccured != seINTERRUPT_NOT_OCCURRED) break;
   \                     ??sleep_mode_alarm_6: (+1)
   \   000000C4   0x....             LDR      R0,??DataTable9
   \   000000C6   0x8800             LDRH     R0,[R0, #+0]
   \   000000C8   0x2800             CMP      R0,#+0
   \   000000CA   0xD107             BNE      ??sleep_mode_alarm_5
    418          		if (UsbOccured   != seINTERRUPT_NOT_OCCURRED) break;
   \                     ??sleep_mode_alarm_7: (+1)
   \   000000CC   0x....             LDR      R0,??DataTable8
   \   000000CE   0x8800             LDRH     R0,[R0, #+0]
   \   000000D0   0x2800             CMP      R0,#+0
   \   000000D2   0xD103             BNE      ??sleep_mode_alarm_5
    419          		if (extSwOccured != seINTERRUPT_NOT_OCCURRED) break;
   \                     ??sleep_mode_alarm_8: (+1)
   \   000000D4   0x....             LDR      R0,??DataTable6
   \   000000D6   0x8800             LDRH     R0,[R0, #+0]
   \   000000D8   0x2800             CMP      R0,#+0
   \   000000DA   0xD0ED             BEQ      ??sleep_mode_alarm_4
    420          	};
    421          
    422          #endif
    423                  
    424          	// 低消費電力解除
    425          	man_gpio_3p3v_power(MAN_GPIO_CTRL_ON);
   \                     ??sleep_mode_alarm_5: (+1)
   \   000000DC   0x2001             MOVS     R0,#+1
   \   000000DE   0x.... 0x....      BL       man_gpio_3p3v_power
    426          	// SPIA CH0 使用再開
    427          	ctrl_SPIA_re_start();
   \   000000E2   0x.... 0x....      BL       ctrl_SPIA_re_start
    428          	// I2C CH0使用再開
    429          	ctrl_I2C0_re_start();
   \   000000E6   0x.... 0x....      BL       ctrl_I2C0_re_start
    430          
    431          	// UART割り込み 有効
    432          	NVIC_EnableIRQ( UART2_0_IRQn );
   \   000000EA   0x2006             MOVS     R0,#+6
   \   000000EC   0x.... 0x....      BL       NVIC_EnableIRQ
    433          	NVIC_EnableIRQ( UART2_1_IRQn );
   \   000000F0   0x200C             MOVS     R0,#+12
   \   000000F2   0x.... 0x....      BL       NVIC_EnableIRQ
    434          
    435          	sePPORT_DisableInt( INPORT8 );									// PORT割り込みを無効にする
   \   000000F6   0x2032             MOVS     R0,#+50
   \   000000F8   0x.... 0x....      BL       sePPORT_DisableInt
    436          	sePPORT_DisableInt( INPORT5 );									// PORT割り込みを無効にする
   \   000000FC   0x2004             MOVS     R0,#+4
   \   000000FE   0x.... 0x....      BL       sePPORT_DisableInt
    437          	sePPORT_DisableInt( INPORT18 );									// PORT割り込みを無効にする
   \   00000102   0x2005             MOVS     R0,#+5
   \   00000104   0x.... 0x....      BL       sePPORT_DisableInt
    438          	sePPORT_EnableInt( INPORT12, sePPORT_INT_EDGE_RISING );			// USB VBUS PORT割り込み(rising edge)
   \   00000108   0x2100             MOVS     R1,#+0
   \   0000010A   0x2048             MOVS     R0,#+72
   \   0000010C   0x.... 0x....      BL       sePPORT_EnableInt
    439          	NVIC_DisableIRQ( RTC_IRQn );									// RTCA割り込み禁止
   \   00000110   0x2004             MOVS     R0,#+4
   \   00000112   0x.... 0x....      BL       NVIC_DisableIRQ
    440          
    441          	// USB割り込みを元に戻す
    442          	if (get_irq_usb != 0) {
   \   00000116   0x2D00             CMP      R5,#+0
   \   00000118   0xD002             BEQ      ??sleep_mode_alarm_9
    443          		NVIC_EnableIRQ( USB_IRQn );
   \   0000011A   0x2013             MOVS     R0,#+19
   \   0000011C   0x.... 0x....      BL       NVIC_EnableIRQ
    444          	}
    445          	if (get_irq_svd2 != 0) {
   \                     ??sleep_mode_alarm_9: (+1)
   \   00000120   0x2C00             CMP      R4,#+0
   \   00000122   0xD002             BEQ      ??sleep_mode_alarm_10
    446          		NVIC_EnableIRQ( SVD2_1_IRQn );
   \   00000124   0x2014             MOVS     R0,#+20
   \   00000126   0x.... 0x....      BL       NVIC_EnableIRQ
    447          	}
    448          	if (get_irq_port == 0) {
   \                     ??sleep_mode_alarm_10: (+1)
   \   0000012A   0x2E00             CMP      R6,#+0
   \   0000012C   0xD102             BNE      ??sleep_mode_alarm_11
    449          		NVIC_DisableIRQ( PORT_IRQn );
   \   0000012E   0x2002             MOVS     R0,#+2
   \   00000130   0x.... 0x....      BL       NVIC_DisableIRQ
    450          	}
    451          
    452          	// 戻り値設定
    453          	if (UsbOccured != seINTERRUPT_NOT_OCCURRED) {
   \                     ??sleep_mode_alarm_11: (+1)
   \   00000134   0x....             LDR      R0,??DataTable8
   \   00000136   0x8800             LDRH     R0,[R0, #+0]
   \   00000138   0x2800             CMP      R0,#+0
   \   0000013A   0xD014             BEQ      ??sleep_mode_alarm_12
    454          		if ( !seUSB_IsVbusConnected() ) {
   \   0000013C   0x.... 0x....      BL       seUSB_IsVbusConnected
   \   00000140   0x2800             CMP      R0,#+0
   \   00000142   0xD10E             BNE      ??sleep_mode_alarm_13
    455          			// USB VBUS端子=='H'を確認する
    456          			if (sePPORT_GetInput(INPORT12) != 0) {
   \   00000144   0x2048             MOVS     R0,#+72
   \   00000146   0x.... 0x....      BL       sePPORT_GetInput
   \   0000014A   0x2800             CMP      R0,#+0
   \   0000014C   0xD009             BEQ      ??sleep_mode_alarm_13
    457          				// USB VBUS割り込み処理
    458          				seUSB_ConfigurePortsForUsb( seUSB_PERIPH );
   \   0000014E   0x2001             MOVS     R0,#+1
   \   00000150   0x.... 0x....      BL       seUSB_ConfigurePortsForUsb
    459          				seUSB_ConfSvdDetectDisconnect();
   \   00000154   0x.... 0x....      BL       seUSB_ConfSvdDetectDisconnect
    460          				seSVD2_Start( SVD2_1 );
   \   00000158   0x....             LDR      R0,??DataTable9_1  ;; 0x40000980
   \   0000015A   0x.... 0x....      BL       seSVD2_Start
    461          				seUSB_Attach();
   \   0000015E   0x.... 0x....      BL       seUSB_Attach
    462          			}
    463          		}
    464          		ret = 2;
   \                     ??sleep_mode_alarm_13: (+1)
   \   00000162   0x2402             MOVS     R4,#+2
   \   00000164   0xE00C             B        ??sleep_mode_alarm_14
    465          	}
    466          	else if (AlarmOccured != seINTERRUPT_NOT_OCCURRED) {
   \                     ??sleep_mode_alarm_12: (+1)
   \   00000166   0x....             LDR      R0,??DataTable8_1
   \   00000168   0x8800             LDRH     R0,[R0, #+0]
   \   0000016A   0x2800             CMP      R0,#+0
   \   0000016C   0xD001             BEQ      ??sleep_mode_alarm_15
    467          		ret = 3;
   \   0000016E   0x2403             MOVS     R4,#+3
   \   00000170   0xE006             B        ??sleep_mode_alarm_14
    468          	}
    469          	else if (extOnOccured != seINTERRUPT_NOT_OCCURRED) {
   \                     ??sleep_mode_alarm_15: (+1)
   \   00000172   0x....             LDR      R0,??DataTable9
   \   00000174   0x8800             LDRH     R0,[R0, #+0]
   \   00000176   0x2800             CMP      R0,#+0
   \   00000178   0xD001             BEQ      ??sleep_mode_alarm_16
    470          		ret = 2;
   \   0000017A   0x2402             MOVS     R4,#+2
   \   0000017C   0xE000             B        ??sleep_mode_alarm_14
    471          	}
    472          	else {
    473          		ret = 1;
   \                     ??sleep_mode_alarm_16: (+1)
   \   0000017E   0x2401             MOVS     R4,#+1
    474          	}
    475          #ifdef ADLINK_DEBUG_MESSAGE
    476                  sprintf(print_buf,"\r\n sleep_mode_alarm() end\r\n");
    477                 man_usb_data_send(print_buf,strlen(print_buf));
    478          #endif //ADLINK_DEBUG_MESSAGE
    479           //     		seSysSleepMS(1000);
    480                   ctrl_BQ24160A_init_setting(BQ24160A_REQ_TE_ON);
   \                     ??sleep_mode_alarm_14: (+1)
   \   00000180   0x2000             MOVS     R0,#+0
   \   00000182   0x.... 0x....      BL       ctrl_BQ24160A_init_setting
    481          
    482          	return ret;
   \   00000186   0x0020             MOVS     R0,R4
   \   00000188   0xBDFE             POP      {R1-R7,PC}       ;; return
    483          }
    484          
    485          
    486          /********************************************************************/
    487          /*!
    488           * \name	sleep_mode_system_error
    489           * \brief	システムエラー時にに15秒間SLEEPモードに入ります
    490           * \param	なし
    491           * \return      なし
    492           * \note	起床条件
    493           *                    INPORT8 :                     :: POWER EXT MODE SW(OFF)
    494           */
    495          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    496          int32_t sleep_mode_system_error( void ) 
    497          {
   \                     sleep_mode_system_error: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
    498          	int32_t		ret;
    499          	uint32_t	get_irq_usb;
    500          	uint32_t	get_irq_svd2;
    501          	uint32_t	get_irq_port;
    502          
    503          #ifdef ADLINK_DEBUG_MESSAGE
    504                  sprintf(print_buf,"\r\n sleep_mode_system_error()\r\n");
    505                 man_usb_data_send(print_buf,strlen(print_buf));
    506          #endif //ADLINK_DEBUG_MESSAGE
    507          	// USB割り込み 無効
    508          
    509                 ctrl_BQ24160A_init_setting(0xffff);    // Disable charging
   \   00000002   0x....             LDR      R0,??DataTable7  ;; 0xffff
   \   00000004   0x.... 0x....      BL       ctrl_BQ24160A_init_setting
    510                 
    511                 get_irq_port = NVIC_GetEnableIRQ( PORT_IRQn );
   \   00000008   0x2002             MOVS     R0,#+2
   \   0000000A   0x.... 0x....      BL       NVIC_GetEnableIRQ
   \   0000000E   0x0007             MOVS     R7,R0
    512          	get_irq_usb = NVIC_GetEnableIRQ( USB_IRQn );
   \   00000010   0x2013             MOVS     R0,#+19
   \   00000012   0x.... 0x....      BL       NVIC_GetEnableIRQ
   \   00000016   0x0004             MOVS     R4,R0
    513                  get_irq_svd2 = NVIC_GetEnableIRQ( SVD2_1_IRQn );
   \   00000018   0x2014             MOVS     R0,#+20
   \   0000001A   0x.... 0x....      BL       NVIC_GetEnableIRQ
   \   0000001E   0x0005             MOVS     R5,R0
    514          	if (get_irq_usb != 0) {
   \   00000020   0x2C00             CMP      R4,#+0
   \   00000022   0xD002             BEQ      ??sleep_mode_system_error_0
    515          		NVIC_DisableIRQ( USB_IRQn );
   \   00000024   0x2013             MOVS     R0,#+19
   \   00000026   0x.... 0x....      BL       NVIC_DisableIRQ
    516          	}
    517          	if (get_irq_svd2 != 0) {
   \                     ??sleep_mode_system_error_0: (+1)
   \   0000002A   0x2D00             CMP      R5,#+0
   \   0000002C   0xD002             BEQ      ??sleep_mode_system_error_1
    518          		NVIC_DisableIRQ( SVD2_1_IRQn );
   \   0000002E   0x2014             MOVS     R0,#+20
   \   00000030   0x.... 0x....      BL       NVIC_DisableIRQ
    519          	}
    520          
    521          
    522          	// 起床条件を設定
    523          
    524          	// SW
    525          	sePPORT_EnableInt( INPORT5,  sePPORT_INT_EDGE_FALLING );		// PORT割り込み(立ち下がり)を有効にする
   \                     ??sleep_mode_system_error_1: (+1)
   \   00000034   0x2101             MOVS     R1,#+1
   \   00000036   0x2004             MOVS     R0,#+4
   \   00000038   0x.... 0x....      BL       sePPORT_EnableInt
    526          	sePPORT_EnableInt( INPORT18, sePPORT_INT_EDGE_FALLING );		// PORT割り込み(立ち下がり)を有効にする
   \   0000003C   0x2101             MOVS     R1,#+1
   \   0000003E   0x2005             MOVS     R0,#+5
   \   00000040   0x.... 0x....      BL       sePPORT_EnableInt
    527          	sePPORT_EnableInt( INPORT8,  sePPORT_INT_EDGE_RISING );			// PORT割り込み(立ち上がり)を有効にする
   \   00000044   0x2100             MOVS     R1,#+0
   \   00000046   0x2032             MOVS     R0,#+50
   \   00000048   0x.... 0x....      BL       sePPORT_EnableInt
    528          	sePPORT_DisableInt(INPORT12);									// USB VBUS PORT割り込みを無効にする
   \   0000004C   0x2048             MOVS     R0,#+72
   \   0000004E   0x.... 0x....      BL       sePPORT_DisableInt
    529          	NVIC_EnableIRQ( PORT_IRQn );									// PORT割り込み許可
   \   00000052   0x2002             MOVS     R0,#+2
   \   00000054   0x.... 0x....      BL       NVIC_EnableIRQ
    530          
    531          	// UART割り込み 無効
    532          	NVIC_DisableIRQ( UART2_0_IRQn );
   \   00000058   0x2006             MOVS     R0,#+6
   \   0000005A   0x.... 0x....      BL       NVIC_DisableIRQ
    533          	NVIC_DisableIRQ( UART2_1_IRQn );
   \   0000005E   0x200C             MOVS     R0,#+12
   \   00000060   0x.... 0x....      BL       NVIC_DisableIRQ
    534          
    535          	// I2C CH0 使用終了
    536          	ctrl_I2C0_end();
   \   00000064   0x.... 0x....      BL       ctrl_I2C0_end
    537          	// SPIA CH0 使用終了
    538          	ctrl_SPIA_end();
   \   00000068   0x.... 0x....      BL       ctrl_SPIA_end
    539          	// 低消費電力設定
    540          	man_gpio_3p3v_power(MAN_GPIO_CTRL_OFF);
   \   0000006C   0x2000             MOVS     R0,#+0
   \   0000006E   0x.... 0x....      BL       man_gpio_3p3v_power
    541          
    542          	// sleep
    543          	extOnOccured = seINTERRUPT_NOT_OCCURRED;
   \   00000072   0x2000             MOVS     R0,#+0
   \   00000074   0x....             LDR      R1,??DataTable9
   \   00000076   0x8008             STRH     R0,[R1, #+0]
    544          	UsbOccured   = seINTERRUPT_NOT_OCCURRED;
   \   00000078   0x2000             MOVS     R0,#+0
   \   0000007A   0x....             LDR      R1,??DataTable8
   \   0000007C   0x8008             STRH     R0,[R1, #+0]
    545          	extSwOccured = seINTERRUPT_NOT_OCCURRED;
   \   0000007E   0x2000             MOVS     R0,#+0
   \   00000080   0x....             LDR      R1,??DataTable9_2
   \   00000082   0x8008             STRH     R0,[R1, #+0]
    546                  NmiIntOccured = seINTERRUPT_NOT_OCCURRED;
   \   00000084   0x2000             MOVS     R0,#+0
   \   00000086   0x....             LDR      R1,??DataTable9_3
   \   00000088   0x8008             STRH     R0,[R1, #+0]
    547          
    548                  uint32_t cnt= 15;  //15秒
   \   0000008A   0x260F             MOVS     R6,#+15
    549                  wdt_NMI_init(); 
   \   0000008C   0x.... 0x....      BL       wdt_NMI_init
    550                  wdt_start();
   \   00000090   0x.... 0x....      BL       wdt_start
   \   00000094   0xE001             B        ??sleep_mode_system_error_2
    551                  while(cnt-- > 0)
    552                  {
    553                    setSleep();
   \                     ??sleep_mode_system_error_3: (+1)
   \   00000096   0x.... 0x....      BL       setSleep
    554                  }
   \                     ??sleep_mode_system_error_2: (+1)
   \   0000009A   0x0030             MOVS     R0,R6
   \   0000009C   0x1E46             SUBS     R6,R0,#+1
   \   0000009E   0x2800             CMP      R0,#+0
   \   000000A0   0xD1F9             BNE      ??sleep_mode_system_error_3
    555                  wdt_stop();
   \   000000A2   0x.... 0x....      BL       wdt_stop
    556          	// 低消費電力解除
    557          	man_gpio_3p3v_power(MAN_GPIO_CTRL_ON);
   \   000000A6   0x2001             MOVS     R0,#+1
   \   000000A8   0x.... 0x....      BL       man_gpio_3p3v_power
    558          	// SPIA CH0 使用再開
    559          	ctrl_SPIA_re_start();
   \   000000AC   0x.... 0x....      BL       ctrl_SPIA_re_start
    560          	// I2C CH0使用再開
    561          	ctrl_I2C0_re_start();
   \   000000B0   0x.... 0x....      BL       ctrl_I2C0_re_start
    562          
    563          	// UART割り込み 有効
    564          	NVIC_EnableIRQ( UART2_0_IRQn );
   \   000000B4   0x2006             MOVS     R0,#+6
   \   000000B6   0x.... 0x....      BL       NVIC_EnableIRQ
    565          	NVIC_EnableIRQ( UART2_1_IRQn );
   \   000000BA   0x200C             MOVS     R0,#+12
   \   000000BC   0x.... 0x....      BL       NVIC_EnableIRQ
    566          
    567          	sePPORT_DisableInt( INPORT8 );									// PORT割り込みを無効にする
   \   000000C0   0x2032             MOVS     R0,#+50
   \   000000C2   0x.... 0x....      BL       sePPORT_DisableInt
    568          	sePPORT_DisableInt( INPORT5 );									// PORT割り込みを無効にする
   \   000000C6   0x2004             MOVS     R0,#+4
   \   000000C8   0x.... 0x....      BL       sePPORT_DisableInt
    569          	sePPORT_DisableInt( INPORT18);									// PORT割り込みを無効にする
   \   000000CC   0x2005             MOVS     R0,#+5
   \   000000CE   0x.... 0x....      BL       sePPORT_DisableInt
    570          	sePPORT_EnableInt( INPORT12, sePPORT_INT_EDGE_RISING );			// USB VBUS PORT割り込み(rising edge)
   \   000000D2   0x2100             MOVS     R1,#+0
   \   000000D4   0x2048             MOVS     R0,#+72
   \   000000D6   0x.... 0x....      BL       sePPORT_EnableInt
    571          
    572          	// USB割り込みを元に戻す
    573          	if (get_irq_usb != 0) {
   \   000000DA   0x2C00             CMP      R4,#+0
   \   000000DC   0xD002             BEQ      ??sleep_mode_system_error_4
    574          		NVIC_EnableIRQ( USB_IRQn );
   \   000000DE   0x2013             MOVS     R0,#+19
   \   000000E0   0x.... 0x....      BL       NVIC_EnableIRQ
    575          	}
    576          	if (get_irq_svd2 != 0) {
   \                     ??sleep_mode_system_error_4: (+1)
   \   000000E4   0x2D00             CMP      R5,#+0
   \   000000E6   0xD002             BEQ      ??sleep_mode_system_error_5
    577          		NVIC_EnableIRQ( SVD2_1_IRQn );
   \   000000E8   0x2014             MOVS     R0,#+20
   \   000000EA   0x.... 0x....      BL       NVIC_EnableIRQ
    578          	}
    579          	if (get_irq_port == 0) {
   \                     ??sleep_mode_system_error_5: (+1)
   \   000000EE   0x2F00             CMP      R7,#+0
   \   000000F0   0xD102             BNE      ??sleep_mode_system_error_6
    580          		NVIC_DisableIRQ( PORT_IRQn );
   \   000000F2   0x2002             MOVS     R0,#+2
   \   000000F4   0x.... 0x....      BL       NVIC_DisableIRQ
    581          	}
    582          
    583          	// 戻り値設定
    584          	if (UsbOccured != seINTERRUPT_NOT_OCCURRED) {
   \                     ??sleep_mode_system_error_6: (+1)
   \   000000F8   0x....             LDR      R0,??DataTable8
   \   000000FA   0x8800             LDRH     R0,[R0, #+0]
   \   000000FC   0x2800             CMP      R0,#+0
   \   000000FE   0xD014             BEQ      ??sleep_mode_system_error_7
    585          		if ( !seUSB_IsVbusConnected() ) {
   \   00000100   0x.... 0x....      BL       seUSB_IsVbusConnected
   \   00000104   0x2800             CMP      R0,#+0
   \   00000106   0xD10E             BNE      ??sleep_mode_system_error_8
    586          			// USB VBUS端子=='H'を確認する
    587                                  if (sePPORT_GetInput(INPORT12) != 0) {
   \   00000108   0x2048             MOVS     R0,#+72
   \   0000010A   0x.... 0x....      BL       sePPORT_GetInput
   \   0000010E   0x2800             CMP      R0,#+0
   \   00000110   0xD009             BEQ      ??sleep_mode_system_error_8
    588          				// USB VBUS割り込み処理
    589          				seUSB_ConfigurePortsForUsb( seUSB_PERIPH );
   \   00000112   0x2001             MOVS     R0,#+1
   \   00000114   0x.... 0x....      BL       seUSB_ConfigurePortsForUsb
    590          				seUSB_ConfSvdDetectDisconnect();
   \   00000118   0x.... 0x....      BL       seUSB_ConfSvdDetectDisconnect
    591          				seSVD2_Start( SVD2_1 );
   \   0000011C   0x....             LDR      R0,??DataTable9_1  ;; 0x40000980
   \   0000011E   0x.... 0x....      BL       seSVD2_Start
    592          				seUSB_Attach();
   \   00000122   0x.... 0x....      BL       seUSB_Attach
    593          			}
    594          		}
    595          
    596                        ret = 2;
   \                     ??sleep_mode_system_error_8: (+1)
   \   00000126   0x2402             MOVS     R4,#+2
   \   00000128   0xE006             B        ??sleep_mode_system_error_9
    597          	}
    598          	else if (extOnOccured != seINTERRUPT_NOT_OCCURRED) {
   \                     ??sleep_mode_system_error_7: (+1)
   \   0000012A   0x....             LDR      R0,??DataTable9
   \   0000012C   0x8800             LDRH     R0,[R0, #+0]
   \   0000012E   0x2800             CMP      R0,#+0
   \   00000130   0xD001             BEQ      ??sleep_mode_system_error_10
    599          		ret = 2;
   \   00000132   0x2402             MOVS     R4,#+2
   \   00000134   0xE000             B        ??sleep_mode_system_error_9
    600          	}
    601          	else {
    602          		ret = 1;
   \                     ??sleep_mode_system_error_10: (+1)
   \   00000136   0x2401             MOVS     R4,#+1
    603          	}
    604          #ifdef ADLINK_DEBUG_MESSAGE
    605                  sprintf(print_buf,"\r\n sleep_mode_system_error(:%d)",ret);
    606                 man_usb_data_send(print_buf,strlen(print_buf));
    607          #endif //ADLINK_DEBUG_MESSAGE
    608                 
    609                  ctrl_BQ24160A_init_setting(BQ24160A_REQ_TE_ON);
   \                     ??sleep_mode_system_error_9: (+1)
   \   00000138   0x2000             MOVS     R0,#+0
   \   0000013A   0x.... 0x....      BL       ctrl_BQ24160A_init_setting
    610          
    611                   return ret;
   \   0000013E   0x0020             MOVS     R0,R4
   \   00000140   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    612          }
    613          
    614          
    615          // PORT割り込み処理

   \                                 In section .text, align 2, keep-with-next
    616          void PORT_IRQHandler( void )
    617          {
   \                     PORT_IRQHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    618          	if ( PPORT->P9INTF_b.P9IF0 ) {						// P90 port interrupt flag
   \   00000002   0x....             LDR      R0,??DataTable9_4  ;; 0x40000296
   \   00000004   0x8800             LDRH     R0,[R0, #+0]
   \   00000006   0x0001             MOVS     R1,R0
   \   00000008   0x07C9             LSLS     R1,R1,#+31       ;; ZeroExtS R1,R1,#+31,#+31
   \   0000000A   0x0FC9             LSRS     R1,R1,#+31
   \   0000000C   0x2900             CMP      R1,#+0
   \   0000000E   0xD010             BEQ      ??PORT_IRQHandler_0
    619          		PPORT->P9INTF = 0x01;
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0x....             LDR      R1,??DataTable9_4  ;; 0x40000296
   \   00000014   0x8008             STRH     R0,[R1, #+0]
    620          		if ( !seUSB_IsVbusConnected() ) {
   \   00000016   0x.... 0x....      BL       seUSB_IsVbusConnected
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD109             BNE      ??PORT_IRQHandler_0
    621          			seUSB_ConfigurePortsForUsb( seUSB_PERIPH );
   \   0000001E   0x2001             MOVS     R0,#+1
   \   00000020   0x.... 0x....      BL       seUSB_ConfigurePortsForUsb
    622          			seUSB_ConfSvdDetectDisconnect();
   \   00000024   0x.... 0x....      BL       seUSB_ConfSvdDetectDisconnect
    623          			seSVD2_Start( SVD2_1 );
   \   00000028   0x....             LDR      R0,??DataTable9_1  ;; 0x40000980
   \   0000002A   0x.... 0x....      BL       seSVD2_Start
    624          			seUSB_Attach();
   \   0000002E   0x.... 0x....      BL       seUSB_Attach
    625          		}
    626          	} 
    627          
    628          	if (sePPORT_GetIntFlag( INPORT9 ) == seINTERRUPT_OCCURRED) {
   \                     ??PORT_IRQHandler_0: (+1)
   \   00000032   0x2033             MOVS     R0,#+51
   \   00000034   0x.... 0x....      BL       sePPORT_GetIntFlag
   \   00000038   0x2801             CMP      R0,#+1
   \   0000003A   0xD105             BNE      ??PORT_IRQHandler_1
    629          		sePPORT_ClearIntFlag( INPORT9 );
   \   0000003C   0x2033             MOVS     R0,#+51
   \   0000003E   0x.... 0x....      BL       sePPORT_ClearIntFlag
    630          		offSwOccured = seINTERRUPT_OCCURRED;
   \   00000042   0x2001             MOVS     R0,#+1
   \   00000044   0x....             LDR      R1,??DataTable9_5
   \   00000046   0x8008             STRH     R0,[R1, #+0]
    631          	}
    632          	if (sePPORT_GetIntFlag( INPORT8 ) == seINTERRUPT_OCCURRED) {
   \                     ??PORT_IRQHandler_1: (+1)
   \   00000048   0x2032             MOVS     R0,#+50
   \   0000004A   0x.... 0x....      BL       sePPORT_GetIntFlag
   \   0000004E   0x2801             CMP      R0,#+1
   \   00000050   0xD105             BNE      ??PORT_IRQHandler_2
    633          		sePPORT_ClearIntFlag( INPORT8 );
   \   00000052   0x2032             MOVS     R0,#+50
   \   00000054   0x.... 0x....      BL       sePPORT_ClearIntFlag
    634          		extSwOccured = seINTERRUPT_OCCURRED;
   \   00000058   0x2001             MOVS     R0,#+1
   \   0000005A   0x....             LDR      R1,??DataTable9_2
   \   0000005C   0x8008             STRH     R0,[R1, #+0]
    635          	}
    636          	if (sePPORT_GetIntFlag( INPORT5 ) == seINTERRUPT_OCCURRED) {
   \                     ??PORT_IRQHandler_2: (+1)
   \   0000005E   0x2004             MOVS     R0,#+4
   \   00000060   0x.... 0x....      BL       sePPORT_GetIntFlag
   \   00000064   0x2801             CMP      R0,#+1
   \   00000066   0xD105             BNE      ??PORT_IRQHandler_3
    637          		sePPORT_ClearIntFlag( INPORT5 );
   \   00000068   0x2004             MOVS     R0,#+4
   \   0000006A   0x.... 0x....      BL       sePPORT_ClearIntFlag
    638          		extOnOccured = seINTERRUPT_OCCURRED;
   \   0000006E   0x2001             MOVS     R0,#+1
   \   00000070   0x....             LDR      R1,??DataTable9
   \   00000072   0x8008             STRH     R0,[R1, #+0]
    639          	}
    640          	if (sePPORT_GetIntFlag( INPORT18 ) == seINTERRUPT_OCCURRED) {
   \                     ??PORT_IRQHandler_3: (+1)
   \   00000074   0x2005             MOVS     R0,#+5
   \   00000076   0x.... 0x....      BL       sePPORT_GetIntFlag
   \   0000007A   0x2801             CMP      R0,#+1
   \   0000007C   0xD105             BNE      ??PORT_IRQHandler_4
    641          		sePPORT_ClearIntFlag( INPORT18 );
   \   0000007E   0x2005             MOVS     R0,#+5
   \   00000080   0x.... 0x....      BL       sePPORT_ClearIntFlag
    642          		UsbOccured = seINTERRUPT_OCCURRED;
   \   00000084   0x2001             MOVS     R0,#+1
   \   00000086   0x....             LDR      R1,??DataTable8
   \   00000088   0x8008             STRH     R0,[R1, #+0]
    643          	}
    644          
    645          }
   \                     ??PORT_IRQHandler_4: (+1)
   \   0000008A   0xBD01             POP      {R0,PC}          ;; return
    646          
    647          
    648          // RTCA割り込み

   \                                 In section .text, align 2, keep-with-next
    649          void RTCA_IRQHandler( void )
    650          //void PRG_RTCA_IRQHandler( void )
    651          {
   \                     RTCA_IRQHandler: (+1)
   \   00000000   0xB500             PUSH     {LR}
    652            
    653            // alarm interrupt
    654            if( RTCA->INTE & seRTCA_ALARMI ) {
   \   00000002   0x....             LDR      R0,??DataTable9_6  ;; 0x400000d2
   \   00000004   0x8800             LDRH     R0,[R0, #+0]
   \   00000006   0x05C0             LSLS     R0,R0,#+23
   \   00000008   0xD50A             BPL      ??RTCA_IRQHandler_0
    655              if( RTCA->INTF & seRTCA_ALARMI ) {
   \   0000000A   0x....             LDR      R0,??DataTable9_7  ;; 0x400000d0
   \   0000000C   0x8800             LDRH     R0,[R0, #+0]
   \   0000000E   0x05C0             LSLS     R0,R0,#+23
   \   00000010   0xD506             BPL      ??RTCA_IRQHandler_0
    656                AlarmOccured = seINTERRUPT_OCCURRED;
   \   00000012   0x2001             MOVS     R0,#+1
   \   00000014   0x....             LDR      R1,??DataTable9_8
   \   00000016   0x8008             STRH     R0,[R1, #+0]
    657                RTCA->INTF = seRTCA_ALARMI;
   \   00000018   0x2080             MOVS     R0,#+128
   \   0000001A   0x0040             LSLS     R0,R0,#+1        ;; #+256
   \   0000001C   0x....             LDR      R1,??DataTable9_7  ;; 0x400000d0
   \   0000001E   0x8008             STRH     R0,[R1, #+0]
    658              }
    659            }
    660          }
   \                     ??RTCA_IRQHandler_0: (+1)
   \   00000020   0xBD00             POP      {PC}             ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \   00000000   0xE000E100         DC32     0xe000e100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5:
   \   00000000   0xE000E180         DC32     0xe000e180

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_1:
   \   00000000   0xE000E400         DC32     0xe000e400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_2:
   \   00000000   0xE000ED1C         DC32     0xe000ed1c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_3:
   \   00000000   0x0000FFFF         DC32     0xffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_4:
   \   00000000   0x........         DC32     extOnOccured

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_5:
   \   00000000   0x........         DC32     UsbOccured

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_6:
   \   00000000   0x........         DC32     offSwOccured

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_7:
   \   00000000   0x40000980         DC32     0x40000980

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6:
   \   00000000   0x........         DC32     extSwOccured

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7:
   \   00000000   0x0000FFFF         DC32     0xffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \   00000000   0x........         DC32     UsbOccured

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_1:
   \   00000000   0x........         DC32     AlarmOccured

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \   00000000   0x........         DC32     extOnOccured

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_1:
   \   00000000   0x40000980         DC32     0x40000980

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_2:
   \   00000000   0x........         DC32     extSwOccured

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_3:
   \   00000000   0x........         DC32     NmiIntOccured

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_4:
   \   00000000   0x40000296         DC32     0x40000296

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_5:
   \   00000000   0x........         DC32     offSwOccured

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_6:
   \   00000000   0x400000D2         DC32     0x400000d2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_7:
   \   00000000   0x400000D0         DC32     0x400000d0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_8:
   \   00000000   0x........         DC32     AlarmOccured
    661          
    662          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       4   NVIC_DisableIRQ
       4   NVIC_EnableIRQ
       4   NVIC_GetEnableIRQ
      20   NVIC_SetPriority
       8   PORT_IRQHandler
         8   -> sePPORT_ClearIntFlag
         8   -> sePPORT_GetIntFlag
         8   -> seSVD2_Start
         8   -> seUSB_Attach
         8   -> seUSB_ConfSvdDetectDisconnect
         8   -> seUSB_ConfigurePortsForUsb
         8   -> seUSB_IsVbusConnected
       4   RTCA_IRQHandler
       8   drv_clg_init
         8   -> seCLG_SetOperInSlp
      16   sleep_mode
        16   -> NVIC_DisableIRQ
        16   -> NVIC_EnableIRQ
        16   -> NVIC_GetEnableIRQ
        16   -> ctrl_BQ24160A_init_setting
        16   -> ctrl_I2C0_end
        16   -> ctrl_I2C0_re_start
        16   -> ctrl_SPIA_end
        16   -> ctrl_SPIA_re_start
        16   -> man_gpio_3p3v_power
        16   -> sePPORT_DisableInt
        16   -> sePPORT_EnableInt
        16   -> sePPORT_GetInput
        16   -> seSVD2_Start
        16   -> seUSB_Attach
        16   -> seUSB_ConfSvdDetectDisconnect
        16   -> seUSB_ConfigurePortsForUsb
        16   -> seUSB_IsVbusConnected
        16   -> setSleep
      32   sleep_mode_alarm
        32   -> NVIC_DisableIRQ
        32   -> NVIC_EnableIRQ
        32   -> NVIC_GetEnableIRQ
        32   -> NVIC_SetPriority
        32   -> ctrl_BQ24160A_init_setting
        32   -> ctrl_I2C0_end
        32   -> ctrl_I2C0_re_start
        32   -> ctrl_SPIA_end
        32   -> ctrl_SPIA_re_start
        32   -> man_gpio_3p3v_power
        32   -> sePPORT_DisableInt
        32   -> sePPORT_EnableInt
        32   -> sePPORT_GetInput
        32   -> seRTCA_SetAlarm
        32   -> seSVD2_Start
        32   -> seUSB_Attach
        32   -> seUSB_ConfSvdDetectDisconnect
        32   -> seUSB_ConfigurePortsForUsb
        32   -> seUSB_IsVbusConnected
        32   -> setSleep
      16   sleep_mode_exton
        16   -> NVIC_DisableIRQ
        16   -> NVIC_EnableIRQ
        16   -> NVIC_GetEnableIRQ
        16   -> ctrl_BQ24160A_init_setting
        16   -> ctrl_I2C0_end
        16   -> ctrl_I2C0_re_start
        16   -> ctrl_SPIA_end
        16   -> ctrl_SPIA_re_start
        16   -> man_gpio_3p3v_power
        16   -> sePPORT_DisableInt
        16   -> sePPORT_EnableInt
        16   -> sePPORT_GetInput
        16   -> seSVD2_Start
        16   -> seUSB_Attach
        16   -> seUSB_ConfSvdDetectDisconnect
        16   -> seUSB_ConfigurePortsForUsb
        16   -> seUSB_IsVbusConnected
        16   -> setSleep
      24   sleep_mode_system_error
        24   -> NVIC_DisableIRQ
        24   -> NVIC_EnableIRQ
        24   -> NVIC_GetEnableIRQ
        24   -> ctrl_BQ24160A_init_setting
        24   -> ctrl_I2C0_end
        24   -> ctrl_I2C0_re_start
        24   -> ctrl_SPIA_end
        24   -> ctrl_SPIA_re_start
        24   -> man_gpio_3p3v_power
        24   -> sePPORT_DisableInt
        24   -> sePPORT_EnableInt
        24   -> sePPORT_GetInput
        24   -> seSVD2_Start
        24   -> seUSB_Attach
        24   -> seUSB_ConfSvdDetectDisconnect
        24   -> seUSB_ConfigurePortsForUsb
        24   -> seUSB_IsVbusConnected
        24   -> setSleep
        24   -> wdt_NMI_init
        24   -> wdt_start
        24   -> wdt_stop


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable4
       4  ??DataTable5
       4  ??DataTable5_1
       4  ??DataTable5_2
       4  ??DataTable5_3
       4  ??DataTable5_4
       4  ??DataTable5_5
       4  ??DataTable5_6
       4  ??DataTable5_7
       4  ??DataTable6
       4  ??DataTable7
       4  ??DataTable8
       4  ??DataTable8_1
       4  ??DataTable9
       4  ??DataTable9_1
       4  ??DataTable9_2
       4  ??DataTable9_3
       4  ??DataTable9_4
       4  ??DataTable9_5
       4  ??DataTable9_6
       4  ??DataTable9_7
       4  ??DataTable9_8
       2  AlarmOccured
      22  NVIC_DisableIRQ
      22  NVIC_EnableIRQ
      30  NVIC_GetEnableIRQ
     132  NVIC_SetPriority
       2  NmiIntOccured
     140  PORT_IRQHandler
      34  RTCA_IRQHandler
       2  UsbOccured
      28  drv_clg_init
       2  extOnOccured
       2  extSwOccured
       2  offSwOccured
     316  sleep_mode
     394  sleep_mode_alarm
     316  sleep_mode_exton
     322  sleep_mode_system_error

 
    12 bytes in section .bss
 1 844 bytes in section .text
 
 1 844 bytes of CODE memory
    12 bytes of DATA memory

Errors: none
Warnings: 4
