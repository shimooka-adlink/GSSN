///////////////////////////////////////////////////////////////////////////////
//
// IAR ANSI C/C++ Compiler V7.80.4.12462/W32 for ARM      21/May/2019  17:01:21
// Copyright 1999-2017 IAR Systems AB.
//
//    Cpu mode     =  thumb
//    Endian       =  little
//    Source file  =  C:\GNSS\Software\rJ105\source\GNSS_GW\apl\man_data.c
//    Command line =  
//        C:\GNSS\Software\rJ105\source\GNSS_GW\apl\man_data.c -D
//        __TARGET_ARCH_7_M -D S1C31W74 -D GNSS_GW_SIDE_B -lCN
//        C:\GNSS\Software\rJ105\source\GNSS_GW\board\S5U1C31W74T1\IAR\DebugFlashBside\List
//        -lA
//        C:\GNSS\Software\rJ105\source\GNSS_GW\board\S5U1C31W74T1\IAR\DebugFlashBside\List
//        --diag_suppress Pe177,Pe111,Pa082 -o
//        C:\GNSS\Software\rJ105\source\GNSS_GW\board\S5U1C31W74T1\IAR\DebugFlashBside\Obj
//        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
//        --no_clustering --no_scheduling --debug --endian=little
//        --cpu=Cortex-M0+ -e --fpu=None --dlib_config "C:\Program Files
//        (x86)\IAR Systems\Embedded Workbench
//        7.5\arm\INC\c\DLib_Config_Normal.h" -I
//        C:\GNSS\Software\rJ105\source\GNSS_GW\board\S5U1C31W74T1\IAR\ -I
//        C:\GNSS\Software\rJ105\source\GNSS_GW\board\S5U1C31W74T1\IAR\..\..\..\
//        -I "C:\Program Files (x86)\IAR Systems\Embedded Workbench
//        7.5\arm\CMSIS\Include\" -I "C:\Program Files (x86)\IAR
//        Systems\Embedded Workbench 7.5\arm\inc\Epson\" -I
//        C:\GNSS\Software\rJ105\source\GNSS_GW\board\S5U1C31W74T1\IAR\..\..\..\..\..\CMSIS\Device\S1C31W74\Include\
//        -I
//        C:\GNSS\Software\rJ105\source\GNSS_GW\board\S5U1C31W74T1\IAR\..\..\..\..\..\CMSIS\Driver\Include\
//        -I
//        C:\GNSS\Software\rJ105\source\GNSS_GW\board\S5U1C31W74T1\IAR\..\..\..\..\..\sePeriphLibrary\
//        -I
//        C:\GNSS\Software\rJ105\source\GNSS_GW\board\S5U1C31W74T1\IAR\..\..\..\..\..\board\S5U1C31W74T1\
//        -I
//        C:\GNSS\Software\rJ105\source\GNSS_GW\board\S5U1C31W74T1\IAR\..\..\..\..\..\USBStack\INC\
//        -I
//        C:\GNSS\Software\rJ105\source\GNSS_GW\board\S5U1C31W74T1\IAR\..\..\..\include\
//        -Ol
//    Locale       =  Japanese_Japan.932
//    List file    =  
//        C:\GNSS\Software\rJ105\source\GNSS_GW\board\S5U1C31W74T1\IAR\DebugFlashBside\List\man_data.s
//
///////////////////////////////////////////////////////////////////////////////

        RTMODEL "__SystemLibrary", "DLib"
        RTMODEL "__dlib_file_descriptor", "0"
        RTMODEL "__dlib_full_locale_support", "0"
        RTMODEL "__iar_require _Printf", ""
        AAPCS BASE,INTERWORK
        PRESERVE8
        REQUIRE8

        #define SHT_PROGBITS 0x1

        EXTERN __aeabi_memcpy
        EXTERN __aeabi_memcpy4
        EXTERN __aeabi_memset
        EXTERN __aeabi_uidiv
        EXTERN __aeabi_uidivmod
        EXTERN abs
        EXTERN flash_end
        EXTERN flash_erase_sector
        EXTERN flash_read
        EXTERN flash_start
        EXTERN flash_write
        EXTERN man_battery_get_data
        EXTERN man_charge_get_data
        EXTERN man_gps_get_nmea_status
        EXTERN man_gyro_get_data
        EXTERN man_http_get_rsrp
        EXTERN man_let_get_data
        EXTERN man_memory_alloc
        EXTERN man_msg_set_type
        EXTERN man_ope_get_switch_pos
        EXTERN man_ota_get_data
        EXTERN man_press_get_data
        EXTERN man_rpt_get_data
        EXTERN man_rpt_req_park_interval
        EXTERN man_rtc_get_clock
        EXTERN man_timer_get_1ms_count
        EXTERN man_timer_get_elapsed_time
        EXTERN man_usb_data_send
        EXTERN man_version_get_data
        EXTERN memcmp
        EXTERN sprintf
        EXTERN strlen

        PUBLIC man_data_1000ms_main
        PUBLIC man_data_chk_program
        PUBLIC man_data_collect_sensor
        PUBLIC man_data_data_write_flash
        PUBLIC man_data_disp_info
        PUBLIC man_data_flash_erase_sector
        PUBLIC man_data_flash_write_sector
        PUBLIC man_data_get_SIM7500_cfotaswitch
        PUBLIC man_data_get_SIM7500_debug_flag
        PUBLIC man_data_get_fixed
        PUBLIC man_data_get_ftp_info
        PUBLIC man_data_get_gnss_no_fix_pos_time
        PUBLIC man_data_get_other
        PUBLIC man_data_get_sensor
        PUBLIC man_data_get_setting_alarmtime
        PUBLIC man_data_get_setting_batalarm
        PUBLIC man_data_get_setting_gprs
        PUBLIC man_data_get_setting_gpsota
        PUBLIC man_data_get_setting_gpssleeptime
        PUBLIC man_data_get_setting_otastart
        PUBLIC man_data_get_setting_other
        PUBLIC man_data_get_setting_sensor
        PUBLIC man_data_get_setting_usbgpsota
        PUBLIC man_data_get_setting_usbota
        PUBLIC man_data_init
        PUBLIC man_data_main
        PUBLIC man_data_program_mrg_set_flash
        PUBLIC man_data_program_write_flash
        PUBLIC man_data_req_factory_reset
        PUBLIC man_data_set_SIM7500_cfotaswitch
        PUBLIC man_data_set_SIM7500_debug_flag
        PUBLIC man_data_set_battery_alarm
        PUBLIC man_data_set_cid
        PUBLIC man_data_set_default_vals_to_extended_area
        PUBLIC man_data_set_ftp_info
        PUBLIC man_data_set_gnss_no_fix_pos_time
        PUBLIC man_data_set_gps_version
        PUBLIC man_data_set_imei
        PUBLIC man_data_set_ipaddr
        PUBLIC man_data_set_nmea
        PUBLIC man_data_set_nmea_fix
        PUBLIC man_data_set_revision
        PUBLIC man_data_set_rssi_sts
        PUBLIC man_data_set_setting_alarmtime
        PUBLIC man_data_set_setting_almtrtime
        PUBLIC man_data_set_setting_batalarm
        PUBLIC man_data_set_setting_gprs
        PUBLIC man_data_set_setting_gpsota
        PUBLIC man_data_set_setting_gpssleeptime
        PUBLIC man_data_set_setting_otastart
        PUBLIC man_data_set_setting_other
        PUBLIC man_data_set_setting_sensor
        PUBLIC man_data_set_setting_usbgpsota
        PUBLIC man_data_set_setting_usbota
        PUBLIC man_data_set_term_version
        PUBLIC man_data_work
        PUBLIC man_data_write_flash
        PUBLIC tmp_tbl
        
          CFI Names cfiNames0
          CFI StackFrame CFA R13 DATA
          CFI Resource R0:32, R1:32, R2:32, R3:32, R4:32, R5:32, R6:32, R7:32
          CFI Resource R8:32, R9:32, R10:32, R11:32, R12:32, R13:32, R14:32
          CFI EndNames cfiNames0
        
          CFI Common cfiCommon0 Using cfiNames0
          CFI CodeAlign 2
          CFI DataAlign 4
          CFI ReturnAddress R14 CODE
          CFI CFA R13+0
          CFI R0 Undefined
          CFI R1 Undefined
          CFI R2 Undefined
          CFI R3 Undefined
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R8 SameValue
          CFI R9 SameValue
          CFI R10 SameValue
          CFI R11 SameValue
          CFI R12 Undefined
          CFI R14 SameValue
          CFI EndCommon cfiCommon0
        
// C:\GNSS\Software\rJ105\source\GNSS_GW\apl\man_data.c
//    1 
//    2 /**
//    3   ******************************************************************************
//    4   * @file    man_data.c
//    5   * @author  コア
//    6   * @version V1.0
//    7   * @date    2017.10.2
//    8   * @brief   データを管理する
//    9   ******************************************************************************
//   10   $Id: man_data.c 258 2018-08-02 06:14:12Z shitaoka $
//   11   * @attention
//   12   *
//   13   *****************************************************************************
//   14 */
//   15 
//   16 #include <string.h>
//   17 #include <stdio.h>
//   18 #include <stdlib.h>
//   19 
//   20 #include "board.h"
//   21 #include "system_manager.h"
//   22 #include "gnss_gw_common.h"
//   23 #include "drv_flash.h"
//   24 #include "man_data.h"
//   25 #include "man_version.h"
//   26 #include "man_press.h"
//   27 #include "man_battery.h"
//   28 #include "man_charge.h"
//   29 #include "man_gps.h"
//   30 #include "man_rtc.h"
//   31 #include "man_http.h"
//   32 #include "man_lte.h"
//   33 #include "man_msg.h"
//   34 #include "man_ope.h"
//   35 #include "man_memory.h"
//   36 #include "man_usb.h"
//   37 #include "man_timer.h"
//   38 
//   39 #pragma section = "APL_PRG_BLOCK"
//   40 
//   41 /************************************************************************/
//   42 /* declaration of structure                                             */
//   43 /************************************************************************/
//   44 
//   45 
//   46 // プログラム格納領域
//   47 #define	MAN_DATA_MAGIC_A_ADDR_TOP	0x0003F000UL			// A面識別コード先頭アドレス
//   48 #define	MAN_DATA_MAGIC_B_ADDR_TOP	0x0006F000UL			// B面識別コード先頭アドレス
//   49 
//   50 
//   51 // 設定値格納領域
//   52 #define	MAN_DATA_SETTING_ADDR_TOP	0x00070000UL		// 設定値 先頭アドレス
//   53 #define	MAN_DATA_BANK_MAX			16					// 16バンク
//   54 #define	MAN_DATA_MAGIC_NUMBER_SIZE	16					// 16文字
//   55 
//   56 #define	MAN_DATA_BUFF_MAX			4096
//   57 #define	MAM_DADA_MAGIC_NUMBER		16
//   58 
//   59 
//   60 #define	MAN_DATA_MSG_CHECK_WAIT		70					// 起動後70秒間はMSGのチェックを行わない
//   61 
//   62 // LTE接続設定(gprs)情報
//   63 // 例) gprs,[cid],cmnet,www.example.co.jp.biz,60010,60010,usernm,passwd#
//   64 
//   65 #define	MAN_DATA_APN_MAX			31		// Simcard apn. MAX:31 byte
//   66 #define	MAN_DATA_IP_MAX				64		// Server ip. Domain MAX: 64 byte. IP MAX:15 byte
//   67 #define	MAN_DATA_TCP_PORT_MAX		5		// TCP port. MAX:65535
//   68 #define	MAN_DATA_UDP_PORT_MAX		5		// UDP port. MAX:65535
//   69 #define	MAN_DATA_USER_NAME_MAX		32		// Simcard username. MAX:32 byte
//   70 #define	MAN_DATA_PASSWORD_MAX		32		// Simcard password. MAX:32 byte
//   71 
//   72 
//   73 // 要求
//   74 #define	MAN_DATA_REQ_CMD_NON			0		// 要求待ち
//   75 #define	MAN_DATA_REQ_CMD_ERASE_SECTOR	1		// ERASE SECTOR
//   76 
//   77 
//   78 // データ管理シーケンス
//   79 typedef enum {
//   80 	MAN_DATA_SEQ_READY,					// 00 : 要求待ち
//   81 
//   82 	MAN_DATA_SEQ_ERASE_REQ,				// 01 : erase sector要求
//   83 	MAN_DATA_SEQ_ERASE_WAIT,			// 02 : erase sector完了待ち
//   84 } man_data_seq_def;
//   85 
//   86 
//   87 
//   88 // 設定データ(FLASHに保存)
//   89 typedef struct _man_data_flash_t {
//   90 	uint8_t				magic_number[MAM_DADA_MAGIC_NUMBER];	// 16 : マジックナンバー
//   91 	man_data_setting_t	setting_info;
//   92 } man_data_flash_t;
//   93 
//   94 // メッセージ情報
//   95 typedef struct _man_data_msg_t {
//   96 	int32_t					counter;
//   97 	int32_t					nmea_msg;			// NMEA系メッセージ出力状態
//   98 	int32_t					accel_msg;			// 加速度系メッセージ出力状態
//   99 	int32_t					temp_msg;			// 温度系メッセージ出力状態
//  100 	int32_t					charge0_msg;		// バッテリ残量0メッセージ出力状態
//  101 	int32_t					low_volt_msg;		// 低電圧メッセージ出力状態
//  102 } man_data_msg_t;
//  103 
//  104 // 要求
//  105 typedef struct _man_data_req_info_t{
//  106 	int32_t						req_cmd;
//  107 
//  108 	uint32_t					top_addr;			// 先頭アドレス
//  109 	int32_t						sector_num;			// セクタ数
//  110 
//  111 	int32_t						id;
//  112 	func_man_data				callback;
//  113 } man_data_req_info_t;
//  114 
//  115 // 作業用
//  116 typedef struct _man_data_tmp_info_t{
//  117 	int32_t						counter;
//  118 	uint32_t					start_time;
//  119 } man_data_tmp_info_t;
//  120 
//  121 
//  122 // 設定データ管理ワーク
//  123 typedef struct _man_data_work_t {
//  124 	int32_t					prg_side;
//  125 	int32_t					set_bank;
//  126 	int32_t					bank;			// 使用するFLASHのバンク
//  127 //	man_data_data_t			data;			// 設定データ
//  128 
//  129 	uint8_t					write[MAN_DATA_BUFF_MAX];		// FLASH 書き込み用ワークエリア
//  130 	uint8_t					read[MAN_DATA_BUFF_MAX];		// FLASH 読み込み用ワークエリア
//  131 	
//  132 	man_data_flash_t		setting;		// FLASH 設定データ
//  133 	man_data_flash_t		buffer;			// FLASH 設定データ(バッファ)
//  134 
//  135 
//  136 	man_data_temp_t			temp_info;		// 一時保管情報
//  137 	man_data_get_other_t	other_info;		// その他の情報
//  138 	man_data_fixed_t		fixed_info;		// 固定値情報
//  139 	man_data_setting_t		setting_info;	// 数字に変換後の設定データ
//  140 	man_data_get_sensor_t	sensor_info;	// センサ情報
//  141 	man_data_msg_t			msg_info;
//  142 
//  143 	man_data_seq_def		sequense;			// シーケンス
//  144 	man_data_req_info_t		request;			// 要求
//  145 	man_data_tmp_info_t		tmp;				// 作業用
//  146 
//  147 } man_data_work_t;
//  148 
//  149 
//  150 /************************************************************************/
//  151 /* definition of variables                                              */
//  152 /************************************************************************/
//  153 

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
        DATA
//  154 man_data_work_t	man_data_work;
man_data_work:
        DS8 14508

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_0:
        DC8 "DATA INFO :: ip addr=%s, lte ver=%s\012"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
?_1:
        DC8 "SENSOR INFO :: rssi=%d, net=%d, nmea=%d\012"
        DC8 0, 0, 0
//  155 
//  156 
//  157 // 出荷時設定

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
//  158 static const man_data_setting_t factory_tbl = {
factory_tbl:
        DC8 "mm9.gnss.ultina"
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 "10.0.0.11"
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 "81"
        DC8 0, 0, 0
        DC8 "3528"
        DC8 0
        DC8 "qzss@mm9.gnss.ultina"
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 "9zss4SB"
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC32 5, 60, 10, 10, 20, 127, 50, 20, 60, 30, 0
        DC8 0, 9, 0, 0
        DC32 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
//  159 	// apn              ip               tcp_port   udp_port    username                 password
//  160 	{"mm9.gnss.ultina",	"10.0.0.11",	"81",		"3528",		"qzss@mm9.gnss.ultina",	 "9zss4SB"},  // gprs
//  161 
//  162 	// park_interval	run_interval	duration_time	duration_time_num
//  163 	{5,					60,			10,				10},	// gpssleeptime
//  164 
//  165 	// alarm_bat_num
//  166 	{20},										// batalarm
//  167 
//  168 	// threshold_num
//  169 	{127},									// sensor
//  170 
//  171 	// time_num
//  172 	{50},										// alarmtime
//  173 
//  174 	// batt_low_error_num   temperature_high_num    alarm_transfer_time
//  175 	{20,					60,     30, {0, 0, MAN_LTE_RETRY_OTA_OFF}},
//  176         {0,{0,0,0,0,0,0,0,0,0,0,0,0}},
//  177         {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
//  178          0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
//  179          0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
//  180          0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
//  181          0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
//  182          0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
//  183          0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
//  184          0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
//  185          0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
//  186          0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
//  187          0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
//  188          0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
//  189          0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
//  190          0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
//  191          0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
//  192 
//  193 
//  194 };
//  195 
//  196 
//  197 // その他の初期化情報

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
//  198 static const man_data_get_other_t other_tbl = {
other_tbl:
        DC8 "000000000000000"
        DC8 "00000000"
        DC8 0, 0, 0
        DC32 20
        DC8 "V1.0"
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 "00000"
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
//  199 	"000000000000000",			// IMEI
//  200 	"00000000",					// CID
//  201 	20,							// バッテリー残量警告しきい値[20%]
//  202 	"V1.0",						// 端末ファームウェアバージョン
//  203 	"00000"						// GPSチップファームウェアバージョン
//  204 };
//  205 
//  206 
//  207 // 固定値の初期化情報

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
//  208 static const man_data_fixed_t fixed_tbl = {
fixed_tbl:
        DC32 10, 10, 5, 5, 5, 20, 10
//  209 	10,							// battery_zero    :: 内部バッテリゼロ閾値[10%]
//  210 	10,							// battery_low_war :: 内部バッテリ低電圧警告閾値[10%]
//  211 	5,							// ext_off_time    :: 外部電源喪失後の測位時間[5分]
//  212 	5,							// alarm_time      :: 定刻起動時の測位時間[5分]
//  213 	5,							// park_max_time   :: バッテリ残量０状態でのpark_intervalの最長時間[5分]
//  214 	20,							// bat_led_flash_num::LED動作におけるの点灯と点滅の閾値[20%]
//  215 	10							// bat_led_off_num ::LED動作におけるの点灯と点滅の閾値[10%]
//  216 };
//  217 
//  218 // マジックナンバー

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
//  219 static const uint8_t magic_number_prg_tbl[MAN_DATA_MAGIC_NUMBER_SIZE] = "GNSS Gateway PRG";
magic_number_prg_tbl:
        DC8 47H, 4EH, 53H, 53H, 20H, 47H, 61H, 74H
        DC8 65H, 77H, 61H, 79H, 20H, 50H, 52H, 47H

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
//  220 static const uint8_t magic_number_set_tbl[MAN_DATA_MAGIC_NUMBER_SIZE] = "GNSS Gateway SET";
magic_number_set_tbl:
        DC8 47H, 4EH, 53H, 53H, 20H, 47H, 61H, 74H
        DC8 65H, 77H, 61H, 79H, 20H, 53H, 45H, 54H
//  221 
//  222 /********************************************************************/
//  223 /*	callback関数                                                    */
//  224 /********************************************************************/
//  225 
//  226 
//  227 /********************************************************************/
//  228 /*	static関数                                                      */
//  229 /********************************************************************/
//  230 
//  231 /********************************************************************/
//  232 /*!
//  233  * \name	man_data_return_callback
//  234  * \brief	callback応答を返す処理
//  235  * \param	status : 通知するステータス
//  236  * \return  なし
//  237  * \note	
//  238  */
//  239 /********************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock0 Using cfiCommon0
          CFI Function man_data_return_callback
        THUMB
//  240 static void man_data_return_callback( int32_t status )
//  241 {
man_data_return_callback:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
//  242 	// callback関数で終了通知
//  243 	if (man_data_work.request.callback != NULL) {
        LDR      R1,??DataTable6
        LDR      R1,[R1, #+0]
        CMP      R1,#+0
        BEQ      ??man_data_return_callback_0
//  244 		man_data_work.request.callback(man_data_work.request.id, status);
        MOVS     R1,R0
        LDR      R0,??DataTable6_1
        LDR      R0,[R0, #+0]
        LDR      R2,??DataTable6
        LDR      R2,[R2, #+0]
          CFI FunCall
        BLX      R2
//  245 		man_data_work.request.callback = NULL;
        MOVS     R0,#+0
        LDR      R1,??DataTable6
        STR      R0,[R1, #+0]
//  246 	}
//  247 	man_data_work.sequense = MAN_DATA_SEQ_READY;
??man_data_return_callback_0:
        MOVS     R0,#+0
        LDR      R1,??DataTable6_2
        STRB     R0,[R1, #+0]
//  248 	man_data_work.request.req_cmd = MAN_DATA_REQ_CMD_NON;
        MOVS     R0,#+0
        LDR      R1,??DataTable14
        STR      R0,[R1, #+0]
//  249 }
        POP      {R0,PC}          ;; return
          CFI EndBlock cfiBlock0
//  250 
//  251 /********************************************************************/
//  252 /*!
//  253  * \name	man_data_program_get_flash
//  254  * \brief	プログラムの動作面を取得する処理
//  255  * \param	
//  256  * \return  0  : A面
//  257  *          1  : B面
//  258 *          16 : 出荷時(A面)
//  259  * \note	必要時に呼ばれること
//  260  */
//  261 /********************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock1 Using cfiCommon0
          CFI Function man_data_program_chk_flash
        THUMB
//  262 static int32_t man_data_program_chk_flash( void  )
//  263 {
man_data_program_chk_flash:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
//  264 	int32_t		ret=MAN_DATA_PRG_F_SIDE;
        MOVS     R4,#+16
//  265 
//  266 	// A面 チェック
//  267 	if (memcmp((void const *)MAN_DATA_MAGIC_A_ADDR_TOP, &magic_number_prg_tbl[0], MAN_DATA_MAGIC_NUMBER_SIZE) == 0) {
        MOVS     R2,#+16
        LDR      R1,??DataTable15
        MOVS     R0,#+252
        LSLS     R0,R0,#+10       ;; #+258048
          CFI FunCall memcmp
        BL       memcmp
        CMP      R0,#+0
        BNE      ??man_data_program_chk_flash_0
//  268 		ret=MAN_DATA_PRG_A_SIDE;
        MOVS     R4,#+0
        B        ??man_data_program_chk_flash_1
//  269 	}
//  270 
//  271 	// B面 チェック
//  272 	else if (memcmp((void const *)MAN_DATA_MAGIC_B_ADDR_TOP, &magic_number_prg_tbl[0], MAN_DATA_MAGIC_NUMBER_SIZE) == 0) {
??man_data_program_chk_flash_0:
        MOVS     R2,#+16
        LDR      R1,??DataTable15
        MOVS     R0,#+222
        LSLS     R0,R0,#+11       ;; #+454656
          CFI FunCall memcmp
        BL       memcmp
        CMP      R0,#+0
        BNE      ??man_data_program_chk_flash_1
//  273 		ret=MAN_DATA_PRG_B_SIDE;
        MOVS     R4,#+1
//  274 	}
//  275 	return ret;
??man_data_program_chk_flash_1:
        MOVS     R0,R4
        POP      {R4,PC}          ;; return
//  276 }
          CFI EndBlock cfiBlock1
//  277 
//  278 
//  279 
//  280 
//  281 
//  282 /********************************************************************/
//  283 /*!
//  284  * \name	man_data_setting_set_flash
//  285  * \brief	設定データをFLASHに登録する処理
//  286  * \param	bank  ; 現在使用しているバンク
//  287  * \return  なし
//  288  * \note	必要時に呼ばれること
//  289  */
//  290 /********************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock2 Using cfiCommon0
          CFI Function man_data_setting_set_flash
        THUMB
//  291 static int32_t man_data_setting_set_flash( int32_t  *bank )
//  292 {
man_data_setting_set_flash:
        PUSH     {R3-R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI R7 Frame(CFA, -8)
          CFI R6 Frame(CFA, -12)
          CFI R5 Frame(CFA, -16)
          CFI R4 Frame(CFA, -20)
          CFI CFA R13+24
        MOVS     R6,R0
//  293 	int32_t			next = *bank;
        LDR      R5,[R6, #+0]
//  294 	uint32_t		flash_top;
//  295 	int32_t			ret;
//  296 
//  297 	// FLASH書き込みフォーマット作成
//  298 	memcpy(&man_data_work.setting.magic_number[0], magic_number_set_tbl, MAN_DATA_MAGIC_NUMBER_SIZE);
        MOVS     R2,#+16
        LDR      R1,??DataTable9
        LDR      R4,??DataTable20
        MOVS     R0,R4
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
//  299 	memcpy(&man_data_work.setting.setting_info, &man_data_work.setting_info, sizeof(man_data_work.setting.setting_info));
        MOVS     R2,#+240
        LSLS     R2,R2,#+1        ;; #+480
        LDR      R1,??DataTable10
        LDR      R4,??DataTable10_1
        MOVS     R0,R4
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
//  300 
//  301 	next++;
        ADDS     R5,R5,#+1
//  302 	if (next >= MAN_DATA_BANK_MAX) next=0;
        CMP      R5,#+16
        BLT      ??man_data_setting_set_flash_0
        MOVS     R5,#+0
//  303 
//  304 	// FLASH消去
//  305 	flash_top = MAN_DATA_SETTING_ADDR_TOP + next * MAN_DATA_FLASH_SIZE;
??man_data_setting_set_flash_0:
        MOVS     R0,#+128
        LSLS     R0,R0,#+5        ;; #+4096
        MULS     R0,R5,R0
        MOVS     R1,#+224
        LSLS     R1,R1,#+11       ;; #+458752
        ADDS     R7,R0,R1
//  306 	ret = flash_erase_sector(flash_top);
        MOVS     R0,R7
          CFI FunCall flash_erase_sector
        BL       flash_erase_sector
        MOVS     R4,R0
//  307 
//  308 	// FLASH書き込み
//  309 	if (ret >= 0) {
        CMP      R4,#+0
        BMI      ??man_data_setting_set_flash_1
//  310 		ret = flash_write(flash_top, &man_data_work.setting, sizeof(man_data_flash_t));
        MOVS     R2,#+248
        LSLS     R2,R2,#+1        ;; #+496
        LDR      R1,??DataTable20
        MOVS     R0,R7
          CFI FunCall flash_write
        BL       flash_write
        MOVS     R4,R0
//  311 	}
//  312 
//  313 	// FLASH読み込み
//  314 	if (ret >= 0) {
??man_data_setting_set_flash_1:
        CMP      R4,#+0
        BMI      ??man_data_setting_set_flash_2
//  315 		flash_read(flash_top, (uint8_t *)&man_data_work.buffer, sizeof(man_data_flash_t));
        MOVS     R2,#+248
        LSLS     R2,R2,#+1        ;; #+496
        LDR      R1,??DataTable14_1
        MOVS     R0,R7
          CFI FunCall flash_read
        BL       flash_read
//  316 	}
//  317 	
//  318 	// 比較
//  319 	if (ret >= 0) {
??man_data_setting_set_flash_2:
        CMP      R4,#+0
        BMI      ??man_data_setting_set_flash_3
//  320 		if (memcmp(&man_data_work.setting, &man_data_work.buffer, sizeof(man_data_flash_t)) != 0) {
        MOVS     R2,#+248
        LSLS     R2,R2,#+1        ;; #+496
        LDR      R1,??DataTable14_1
        LDR      R0,??DataTable20
          CFI FunCall memcmp
        BL       memcmp
        CMP      R0,#+0
        BEQ      ??man_data_setting_set_flash_3
//  321 			ret = -1;
        MOVS     R4,#+0
        MVNS     R4,R4            ;; #-1
//  322 		}
//  323 	}
//  324 
//  325 	// 旧データ消去
//  326 	if (ret >= 0) {
??man_data_setting_set_flash_3:
        CMP      R4,#+0
        BMI      ??man_data_setting_set_flash_4
//  327 		if (*bank < MAN_DATA_BANK_MAX) {
        LDR      R0,[R6, #+0]
        CMP      R0,#+16
        BGE      ??man_data_setting_set_flash_5
//  328 			flash_top = MAN_DATA_SETTING_ADDR_TOP + *bank * MAN_DATA_FLASH_SIZE;
        LDR      R0,[R6, #+0]
        MOVS     R1,#+128
        LSLS     R1,R1,#+5        ;; #+4096
        MULS     R0,R1,R0
        MOVS     R1,#+224
        LSLS     R1,R1,#+11       ;; #+458752
        ADDS     R7,R0,R1
//  329 			ret = flash_erase_sector(flash_top);
        MOVS     R0,R7
          CFI FunCall flash_erase_sector
        BL       flash_erase_sector
        MOVS     R4,R0
//  330 		}
//  331 		*bank = next;
??man_data_setting_set_flash_5:
        STR      R5,[R6, #+0]
//  332 	}
//  333 
//  334 	return ret;
??man_data_setting_set_flash_4:
        MOVS     R0,R4
        POP      {R1,R4-R7,PC}    ;; return
//  335 }
          CFI EndBlock cfiBlock2
//  336 
//  337 /********************************************************************/
//  338 /*!
//  339  * \name	man_data_setting_get_flash
//  340  * \brief	設定データをFLASHから取得する処理
//  341  * \param	bank  ; 0-15 : FLASH上のバンク
//  342  *                : 16   : 出荷時設定
//  343  * \return  なし
//  344  * \note	必要時に呼ばれること
//  345  */
//  346 /********************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock3 Using cfiCommon0
          CFI Function man_data_setting_get_flash
        THUMB
//  347 static int32_t man_data_setting_get_flash( int32_t  *bank )
//  348 {
man_data_setting_get_flash:
        PUSH     {R3-R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI R7 Frame(CFA, -8)
          CFI R6 Frame(CFA, -12)
          CFI R5 Frame(CFA, -16)
          CFI R4 Frame(CFA, -20)
          CFI CFA R13+24
        MOVS     R7,R0
//  349 	int32_t		ret=-1;
        MOVS     R6,#+0
        MVNS     R6,R6            ;; #-1
//  350 	int32_t		bank_work=-1;
        MOVS     R4,#+0
        MVNS     R4,R4            ;; #-1
//  351 	int32_t		i;
//  352 	uint32_t	flash_top;
//  353 
//  354 	for (i=0; i<MAN_DATA_BANK_MAX; i++) {
        MOVS     R5,#+0
        B        ??man_data_setting_get_flash_0
??man_data_setting_get_flash_1:
        ADDS     R5,R5,#+1
??man_data_setting_get_flash_0:
        CMP      R5,#+16
        BGE      ??man_data_setting_get_flash_2
//  355 
//  356 		// FLASH読み込み
//  357 		flash_top = MAN_DATA_SETTING_ADDR_TOP + i * MAN_DATA_FLASH_SIZE;
        MOVS     R0,#+128
        LSLS     R0,R0,#+5        ;; #+4096
        MULS     R0,R5,R0
        MOVS     R1,#+224
        LSLS     R1,R1,#+11       ;; #+458752
        ADDS     R0,R0,R1
//  358 		flash_read(flash_top, (uint8_t *)&man_data_work.buffer, sizeof(man_data_flash_t));
        MOVS     R2,#+248
        LSLS     R2,R2,#+1        ;; #+496
        LDR      R1,??DataTable14_1
          CFI FunCall flash_read
        BL       flash_read
//  359 		if (memcmp(&man_data_work.buffer.magic_number[0], &magic_number_set_tbl[0], MAN_DATA_MAGIC_NUMBER_SIZE) == 0) {
        MOVS     R2,#+16
        LDR      R1,??DataTable9
        LDR      R0,??DataTable14_1
          CFI FunCall memcmp
        BL       memcmp
        CMP      R0,#+0
        BNE      ??man_data_setting_get_flash_1
//  360 			memcpy(&man_data_work.setting_info, &man_data_work.buffer.setting_info, sizeof(man_data_work.setting_info));
        MOVS     R2,#+240
        LSLS     R2,R2,#+1        ;; #+480
        LDR      R1,??DataTable25
        LDR      R4,??DataTable10
        MOVS     R0,R4
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
//  361 			bank_work = i;
        MOVS     R4,R5
//  362 			ret = 0;
        MOVS     R6,#+0
//  363 			break;
//  364 		}
//  365 	}
//  366 
//  367 	// 登録されていない場合
//  368 	if (bank_work < 0) {
??man_data_setting_get_flash_2:
        CMP      R4,#+0
        BPL      ??man_data_setting_get_flash_3
//  369 		memcpy(&man_data_work.setting_info, &factory_tbl, sizeof(man_data_work.setting_info));
        MOVS     R2,#+240
        LSLS     R2,R2,#+1        ;; #+480
        LDR      R1,??DataTable27
        LDR      R4,??DataTable10
        MOVS     R0,R4
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
//  370 		bank_work = MAN_DATA_BANK_MAX;
        MOVS     R4,#+16
//  371 		ret = 0;
        MOVS     R6,#+0
//  372 	}
//  373 
//  374 	*bank = bank_work;
??man_data_setting_get_flash_3:
        STR      R4,[R7, #+0]
//  375 	return ret;
        MOVS     R0,R6
        POP      {R1,R4-R7,PC}    ;; return
//  376 
//  377 }
          CFI EndBlock cfiBlock3
//  378 
//  379 
//  380 
//  381 /********************************************************************/
//  382 /*	extern関数                                                      */
//  383 /********************************************************************/
//  384 
//  385 /********************************************************************/
//  386 /*!
//  387  * \name	man_data_init
//  388  * \brief	設定データ管理の初期化処理
//  389  * \param	なし
//  390  * \return  なし
//  391  * \note	起動時に、呼ばれること
//  392  */
//  393 /********************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock4 Using cfiCommon0
          CFI Function man_data_init
        THUMB
//  394 void man_data_init(void)
//  395 {
man_data_init:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        SUB      SP,SP,#+8
          CFI CFA R13+16
//  396 	int32_t	bank;
//  397 	int32_t	i;
//  398 	
//  399 
//  400 	// 内部変数を初期化する
//  401 	memset(&man_data_work, 0, sizeof(man_data_work_t));
        LDR      R1,??DataTable27_1  ;; 0x38ac
        MOVS     R2,#+0
        LDR      R4,??DataTable27_2
        MOVS     R0,R4
          CFI FunCall __aeabi_memset
        BL       __aeabi_memset
//  402 	man_data_work.msg_info.nmea_msg = MAN_MSG_TYPE_INVALID;
        MOVS     R0,#+43
        LDR      R1,??DataTable27_3
        STR      R0,[R1, #+0]
//  403 
//  404 
//  405 	// flash driver使用開始
//  406 	flash_start();
          CFI FunCall flash_start
        BL       flash_start
//  407 
//  408 	// プログラムの動作面取得
//  409 	man_data_work.prg_side = man_data_program_chk_flash();
          CFI FunCall man_data_program_chk_flash
        BL       man_data_program_chk_flash
        LDR      R1,??DataTable27_2
        STR      R0,[R1, #+0]
//  410 
//  411 	// 出荷時の設定になっていればA面にする
//  412 //	if (man_data_work.prg_side == MAN_DATA_PRG_F_SIDE) {
//  413 //		man_data_program_mrg_set_flash(MAN_DATA_PRG_A_SIDE);
//  414 //		man_data_work.prg_side = MAN_DATA_PRG_A_SIDE;
//  415 //	}
//  416 #if 0
//  417 	// A面(16KB)をB面にコピーする
//  418 	for (i=0; i<4; i++) {
//  419 		memcpy(&man_data_work.write[0], (void const *)(MAN_DATA_PRG_A_ADDR_TOP + i * MAN_DATA_FLASH_SIZE), MAN_DATA_FLASH_SIZE);
//  420 		man_data_data_write_flash((MAN_DATA_PRG_B_ADDR_TOP + i * MAN_DATA_FLASH_SIZE), &man_data_work.write[0], MAN_DATA_FLASH_SIZE);
//  421 	}
//  422 	man_data_program_mrg_set_flash(MAN_DATA_PRG_B_SIDE);
//  423 	man_data_work.prg_side = MAN_DATA_PRG_A_SIDE;
//  424 #endif
//  425 //  強制的にA面に切り替える
//  426 //	man_data_program_mrg_set_flash(MAN_DATA_PRG_A_SIDE);
//  427 
//  428 	// 設定データFLASHから取り出す
//  429 	man_data_setting_get_flash(&bank);
        MOV      R0,SP
          CFI FunCall man_data_setting_get_flash
        BL       man_data_setting_get_flash
//  430 
//  431 	// 設定値バンク情報を保存
//  432 	man_data_work.set_bank = bank;
        LDR      R0,[SP, #+0]
        LDR      R1,??DataTable27_2
        STR      R0,[R1, #+4]
//  433 
//  434 	// 未登録の場合は登録する
//  435 	if (man_data_work.set_bank == MAN_DATA_BANK_MAX) {
        LDR      R0,??DataTable27_2
        LDR      R0,[R0, #+4]
        CMP      R0,#+16
        BNE      ??man_data_init_0
//  436 		man_data_setting_set_flash(&man_data_work.set_bank);
        LDR      R0,??DataTable28
          CFI FunCall man_data_setting_set_flash
        BL       man_data_setting_set_flash
//  437 	}
//  438 
//  439 	// flash driver使用終了
//  440 	flash_end();
??man_data_init_0:
          CFI FunCall flash_end
        BL       flash_end
//  441 
//  442 	// その他情報を初期化する
//  443 	memcpy(&man_data_work.other_info, &other_tbl, sizeof(man_data_work.other_info));
        MOVS     R2,#+120
        LDR      R1,??DataTable29
        LDR      R4,??DataTable29_1
        MOVS     R0,R4
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
//  444 
//  445 	// 固定値情報を初期化する
//  446 	memcpy(&man_data_work.fixed_info, &fixed_tbl, sizeof(man_data_work.fixed_info));
        MOVS     R2,#+28
        LDR      R1,??DataTable30
        LDR      R4,??DataTable30_1
        MOVS     R0,R4
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
//  447 
//  448 	// 端末バージョン情報を更新する
//  449 	man_version_get_data(&man_data_work.other_info.term_version[0]);
        LDR      R0,??DataTable35
          CFI FunCall man_version_get_data
        BL       man_version_get_data
//  450 
//  451 }
        POP      {R0,R1,R4,PC}    ;; return
          CFI EndBlock cfiBlock4
//  452 
//  453 /********************************************************************/
//  454 /*!
//  455  * \name	man_data_1000ms_main
//  456  * \brief	1000ms毎に行う処理
//  457  * \param	なし
//  458  * \return  なし
//  459  * \note	1000ms毎に、呼ばれること
//  460  */
//  461 /********************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock5 Using cfiCommon0
          CFI Function man_data_1000ms_main
        THUMB
//  462 void man_data_1000ms_main( void )
//  463 {
man_data_1000ms_main:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
//  464 	man_data_collect_sensor();
          CFI FunCall man_data_collect_sensor
        BL       man_data_collect_sensor
//  465 }
        POP      {R0,PC}          ;; return
          CFI EndBlock cfiBlock5
//  466 
//  467 
//  468 /********************************************************************/
//  469 /*!
//  470  * \name	man_data_chk_program
//  471  * \brief	プログラムの動作面取得処理
//  472  * \param	なし
//  473  * \return  MAN_DATA_PRG_A_SIDE
//  474  *          MAN_DATA_PRG_B_SIDE
//  475  * \note	必要時に呼ばれること
//  476  */
//  477 /********************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock6 Using cfiCommon0
          CFI Function man_data_chk_program
          CFI NoCalls
        THUMB
//  478 int32_t man_data_chk_program( void )
//  479 {
//  480 	return man_data_work.prg_side;
man_data_chk_program:
        LDR      R0,??DataTable27_2
        LDR      R0,[R0, #+0]
        BX       LR               ;; return
//  481 }
          CFI EndBlock cfiBlock6
//  482 
//  483 
//  484 
//  485 /********************************************************************/
//  486 /*!
//  487  * \name	man_data_program_write_flash
//  488  * \brief	programをFLASHに書き込む処理
//  489  * \param	top      ; 書き込み位置
//  490  *          buff     : 書き込むデータ
//  491  *          length   : データ長 (最大はMAN_DATA_FLASH_SIZE)
//  492  *          callback : 完了を通知するcallback関数
//  493  * \return  0  : 成功
//  494  *          -1 : 失敗
//  495  * \note	FLASH WRITEに30秒程度かかるため分割して書き込む
//  496  */
//  497 /********************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock7 Using cfiCommon0
          CFI Function man_data_program_write_flash
          CFI NoCalls
        THUMB
//  498 int32_t man_data_program_write_flash( uint32_t top, uint8_t *buff, uint32_t  length, func_man_data callback  )
//  499 {
//  500 	int32_t			ret=0;
man_data_program_write_flash:
        MOVS     R0,#+0
//  501 
//  502 	return ret;
        BX       LR               ;; return
//  503 }
          CFI EndBlock cfiBlock7
//  504 
//  505 /********************************************************************/
//  506 /*!
//  507  * \name	man_data_data_write_flash
//  508  * \brief	データをFLASHに書き込む処理
//  509  * \param	top    ; 書き込み位置
//  510  *          buff   : 書き込むデータ
//  511  *          length : データ長 (最大はMAN_DATA_FLASH_SIZE)
//  512  * \return  0  : 成功
//  513  *          -1 : 失敗
//  514  * \note	
//  515  */
//  516 /********************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock8 Using cfiCommon0
          CFI Function man_data_data_write_flash
        THUMB
//  517 int32_t man_data_data_write_flash( uint32_t top, uint8_t *buff, uint32_t  length  )
//  518 {
man_data_data_write_flash:
        PUSH     {R3-R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI R7 Frame(CFA, -8)
          CFI R6 Frame(CFA, -12)
          CFI R5 Frame(CFA, -16)
          CFI R4 Frame(CFA, -20)
          CFI CFA R13+24
        MOVS     R6,R0
        MOVS     R5,R1
        MOVS     R7,R2
//  519 	int32_t			ret=-1;
        MOVS     R4,#+0
        MVNS     R4,R4            ;; #-1
//  520 
//  521 	if ( (buff != NULL) && (length <= MAN_DATA_FLASH_SIZE) ) {
        CMP      R5,#+0
        BEQ      ??man_data_data_write_flash_0
        LDR      R0,??DataTable33  ;; 0x1001
        CMP      R7,R0
        BCS      ??man_data_data_write_flash_0
//  522 
//  523 		// flash driver使用開始
//  524 		flash_start();
          CFI FunCall flash_start
        BL       flash_start
//  525 
//  526 		// FLASH消去
//  527 		ret = flash_erase_sector(top);
        MOVS     R0,R6
          CFI FunCall flash_erase_sector
        BL       flash_erase_sector
        MOVS     R4,R0
//  528 
//  529 		// FLASH書き込み
//  530 		if (ret >= 0) {
        CMP      R4,#+0
        BMI      ??man_data_data_write_flash_1
//  531 			ret = flash_write(top, buff, length);
        MOVS     R2,R7
        MOVS     R1,R5
        MOVS     R0,R6
          CFI FunCall flash_write
        BL       flash_write
        MOVS     R4,R0
//  532 		}
//  533 
//  534 		// FLASH読み込み
//  535 		if (ret >= 0) {
??man_data_data_write_flash_1:
        CMP      R4,#+0
        BMI      ??man_data_data_write_flash_2
//  536 			flash_read(top, &man_data_work.read[0], length);
        MOVS     R2,R7
        LDR      R1,??DataTable41
        MOVS     R0,R6
          CFI FunCall flash_read
        BL       flash_read
//  537 		}
//  538 	
//  539 		// 比較
//  540 		if (ret >= 0) {
??man_data_data_write_flash_2:
        CMP      R4,#+0
        BMI      ??man_data_data_write_flash_3
//  541 			if (memcmp(&man_data_work.read[0], buff, length) != 0) {
        MOVS     R2,R7
        MOVS     R1,R5
        LDR      R0,??DataTable41
          CFI FunCall memcmp
        BL       memcmp
        CMP      R0,#+0
        BEQ      ??man_data_data_write_flash_3
//  542 				ret = -1;
        MOVS     R4,#+0
        MVNS     R4,R4            ;; #-1
//  543 			}
//  544 		}
//  545 
//  546 		// flash driver使用終了
//  547 		flash_end();
??man_data_data_write_flash_3:
          CFI FunCall flash_end
        BL       flash_end
//  548 
//  549 	}
//  550 
//  551 
//  552 	return ret;
??man_data_data_write_flash_0:
        MOVS     R0,R4
        POP      {R1,R4-R7,PC}    ;; return
//  553 }
          CFI EndBlock cfiBlock8

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable6:
        DC32     man_data_work+0x38A0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable6_1:
        DC32     man_data_work+0x389C

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable6_2:
        DC32     man_data_work+0x388C
//  554 
//  555 
//  556 /********************************************************************/
//  557 /*!
//  558  * \name	man_data_program_mrg_set_flash
//  559  * \brief	プログラムの動作面を設定する処理
//  560  * \param	side  ; MAN_DATA_PRG_A_SIDE    : A面
//  561  *                : MAN_DATA_PRG_B_SIDE    : B面
//  562  * \return  0  : 成功
//  563  *          -1 : 失敗
//  564  * \note	
//  565  */
//  566 /********************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock9 Using cfiCommon0
          CFI Function man_data_program_mrg_set_flash
        THUMB
//  567 int32_t man_data_program_mrg_set_flash( int32_t side  )
//  568 {
man_data_program_mrg_set_flash:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
//  569 	uint32_t		write_top;
//  570 	uint32_t		erase_top;
//  571 	int32_t			ret;
//  572 
//  573 	if (side != MAN_DATA_PRG_B_SIDE) {
        CMP      R0,#+1
        BEQ      ??man_data_program_mrg_set_flash_0
//  574 		write_top = MAN_DATA_MAGIC_A_ADDR_TOP;
        MOVS     R5,#+252
        LSLS     R5,R5,#+10       ;; #+258048
//  575 		erase_top = MAN_DATA_MAGIC_B_ADDR_TOP;
        MOVS     R6,#+222
        LSLS     R6,R6,#+11       ;; #+454656
        B        ??man_data_program_mrg_set_flash_1
//  576 	}
//  577 	else {
//  578 		write_top = MAN_DATA_MAGIC_B_ADDR_TOP;
??man_data_program_mrg_set_flash_0:
        MOVS     R5,#+222
        LSLS     R5,R5,#+11       ;; #+454656
//  579 		erase_top = MAN_DATA_MAGIC_A_ADDR_TOP;
        MOVS     R6,#+252
        LSLS     R6,R6,#+10       ;; #+258048
//  580 	}
//  581 
//  582 	// flash driver使用開始
//  583 	flash_start();
??man_data_program_mrg_set_flash_1:
          CFI FunCall flash_start
        BL       flash_start
//  584 
//  585 	memcpy(&man_data_work.write[0], &magic_number_prg_tbl[0], MAN_DATA_MAGIC_NUMBER_SIZE);
        MOVS     R2,#+16
        LDR      R1,??DataTable15
        LDR      R4,??DataTable41_1
        MOVS     R0,R4
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
//  586 
//  587 	// 書き込み面 FLASH消去
//  588 	ret = flash_erase_sector(write_top);
        MOVS     R0,R5
          CFI FunCall flash_erase_sector
        BL       flash_erase_sector
        MOVS     R4,R0
//  589 
//  590 	// 書き込み面 FLASH書き込み
//  591 	if (ret >= 0) {
        CMP      R4,#+0
        BMI      ??man_data_program_mrg_set_flash_2
//  592 		ret = flash_write(write_top, &man_data_work.write[0], MAN_DATA_MAGIC_NUMBER_SIZE);
        MOVS     R2,#+16
        LDR      R1,??DataTable41_1
        MOVS     R0,R5
          CFI FunCall flash_write
        BL       flash_write
        MOVS     R4,R0
//  593 	}
//  594 
//  595 	// FLASH読み込み
//  596 	if (ret >= 0) {
??man_data_program_mrg_set_flash_2:
        CMP      R4,#+0
        BMI      ??man_data_program_mrg_set_flash_3
//  597 		flash_read(write_top, &man_data_work.read[0], MAN_DATA_MAGIC_NUMBER_SIZE);
        MOVS     R2,#+16
        LDR      R1,??DataTable41
        MOVS     R0,R5
          CFI FunCall flash_read
        BL       flash_read
//  598 	}
//  599 	
//  600 	// 比較
//  601 	if (ret >= 0) {
??man_data_program_mrg_set_flash_3:
        CMP      R4,#+0
        BMI      ??man_data_program_mrg_set_flash_4
//  602 		if (memcmp(&man_data_work.read[0], &man_data_work.write[0], MAN_DATA_MAGIC_NUMBER_SIZE) != 0) {
        MOVS     R2,#+16
        LDR      R1,??DataTable41_1
        LDR      R0,??DataTable41
          CFI FunCall memcmp
        BL       memcmp
        CMP      R0,#+0
        BEQ      ??man_data_program_mrg_set_flash_4
//  603 			ret = -1;
        MOVS     R4,#+0
        MVNS     R4,R4            ;; #-1
//  604 		}
//  605 	}
//  606 
//  607 	// 旧データ消去
//  608 	if (ret >= 0) {
??man_data_program_mrg_set_flash_4:
        CMP      R4,#+0
        BMI      ??man_data_program_mrg_set_flash_5
//  609 		ret = flash_erase_sector(erase_top);
        MOVS     R0,R6
          CFI FunCall flash_erase_sector
        BL       flash_erase_sector
        MOVS     R4,R0
//  610 	}
//  611 
//  612 	// flash driver使用終了
//  613 	flash_end();
??man_data_program_mrg_set_flash_5:
          CFI FunCall flash_end
        BL       flash_end
//  614 
//  615 	return ret;
        MOVS     R0,R4
        POP      {R4-R6,PC}       ;; return
//  616 }
          CFI EndBlock cfiBlock9
//  617 
//  618 
//  619 
//  620 
//  621 /********************************************************************/
//  622 /*!
//  623  * \name	man_data_write_flash
//  624  * \brief	設定データをFLASHに書き込む処理
//  625  * \param	なし
//  626  * \return  なし
//  627  * \note	必要時に呼ばれること
//  628  */
//  629 /********************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock10 Using cfiCommon0
          CFI Function man_data_write_flash
        THUMB
//  630 void man_data_write_flash( void )
//  631 {
man_data_write_flash:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
//  632 	// flash driver使用開始
//  633 	flash_start();
          CFI FunCall flash_start
        BL       flash_start
//  634 
//  635 	// FLASHに保存する
//  636 	man_data_setting_set_flash(&man_data_work.set_bank);
        LDR      R0,??DataTable28
          CFI FunCall man_data_setting_set_flash
        BL       man_data_setting_set_flash
//  637 
//  638 	// flash driver使用終了
//  639 	flash_end();
          CFI FunCall flash_end
        BL       flash_end
//  640 }
        POP      {R0,PC}          ;; return
          CFI EndBlock cfiBlock10
//  641 
//  642 /********************************************************************/
//  643 /*!
//  644  * \name	man_data_req_factory_reset
//  645  * \brief	設定データを出荷時状態にリセットする処理
//  646  * \param	なし
//  647  * \return  なし
//  648  * \note	必要時に呼ばれること
//  649  */
//  650 /********************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock11 Using cfiCommon0
          CFI Function man_data_req_factory_reset
        THUMB
//  651 void man_data_req_factory_reset( void )
//  652 {
man_data_req_factory_reset:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
//  653 	// 出荷時設定
//  654 	memcpy(&man_data_work.setting_info, &factory_tbl, sizeof(man_data_work.setting_info));
        MOVS     R2,#+240
        LSLS     R2,R2,#+1        ;; #+480
        LDR      R1,??DataTable27
        LDR      R4,??DataTable10
        MOVS     R0,R4
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
//  655 	// 設定データをFLASHに書き込む
//  656 	man_data_write_flash();
          CFI FunCall man_data_write_flash
        BL       man_data_write_flash
//  657 }
        POP      {R4,PC}          ;; return
          CFI EndBlock cfiBlock11

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable9:
        DC32     magic_number_set_tbl
//  658 
//  659 
//  660 /********************************************************************/
//  661 /*!
//  662  * \name	man_data_set_setting_gprs
//  663  * \brief	LTE接続設定情報を設定する処理
//  664  * \param	gprs  : LTE接続設定情報
//  665  * \return  なし
//  666  * \note	必要時に呼ばれること
//  667  */
//  668 /********************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock12 Using cfiCommon0
          CFI Function man_data_set_setting_gprs
        THUMB
//  669 void man_data_set_setting_gprs(man_data_num_gprs_t gprs)
//  670 {
man_data_set_setting_gprs:
        PUSH     {R0-R3}
          CFI CFA R13+16
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -20)
          CFI CFA R13+24
//  671 	man_data_work.setting_info.gprs_num = gprs;
        LDR      R0,??DataTable10
        ADD      R1,SP,#+8
        MOVS     R2,#+175
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
//  672 }
        LDR      R0,[SP, #+4]
          CFI R14 R0
        ADD      SP,SP,#+24
          CFI CFA R13+0
        BX       R0               ;; return
          CFI EndBlock cfiBlock12

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable10:
        DC32     man_data_work+0x2AB0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable10_1:
        DC32     man_data_work+0x201C
//  673 
//  674 /********************************************************************/
//  675 /*!
//  676  * \name	man_data_get_setting_gprs
//  677  * \brief	LTE接続設定情報を取得する処理
//  678  * \param	なし
//  679  * \return  LTE接続設定情報へのポインタ
//  680  * \note	必要時に呼ばれること
//  681  */
//  682 /********************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock13 Using cfiCommon0
          CFI Function man_data_get_setting_gprs
          CFI NoCalls
        THUMB
//  683 man_data_num_gprs_t * man_data_get_setting_gprs( void )
//  684 {
//  685 	return &man_data_work.setting_info.gprs_num;
man_data_get_setting_gprs:
        LDR      R0,??DataTable43
        BX       LR               ;; return
//  686 }
          CFI EndBlock cfiBlock13
//  687 
//  688 /********************************************************************/
//  689 /*!
//  690  * \name	man_data_set_setting_gpssleeptime
//  691  * \brief	GPS測位結果出力サイクル設定情報を設定する処理
//  692  * \param	gpssleeptime : GPS測位結果出力サイクル設定情報
//  693  * \return  なし
//  694  * \note	必要時に呼ばれること
//  695  */
//  696 /********************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock14 Using cfiCommon0
          CFI Function man_data_set_setting_gpssleeptime
        THUMB
//  697 void man_data_set_setting_gpssleeptime(man_data_num_gpssleeptime_t gpssleeptime)
//  698 {
man_data_set_setting_gpssleeptime:
        PUSH     {R0-R3,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+20
        SUB      SP,SP,#+4
          CFI CFA R13+24
//  699 	man_data_work.setting_info.gpssleeptime_num = gpssleeptime;
        LDR      R0,??DataTable43_1
        ADD      R1,SP,#+4
        MOVS     R2,#+16
          CFI FunCall __aeabi_memcpy4
        BL       __aeabi_memcpy4
//  700 }
        ADD      SP,SP,#+20
          CFI CFA R13+4
        POP      {PC}             ;; return
          CFI EndBlock cfiBlock14
//  701 
//  702 /********************************************************************/
//  703 /*!
//  704  * \name	man_data_get_setting_gpssleeptime
//  705  * \brief	GPS測位結果出力サイクル設定情報を取得する処理
//  706  * \param	なし
//  707  * \return  GPS測位結果出力サイクル設定情報へのポインタ
//  708  * \note	必要時に呼ばれること
//  709  */
//  710 /********************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock15 Using cfiCommon0
          CFI Function man_data_get_setting_gpssleeptime
          CFI NoCalls
        THUMB
//  711 man_data_num_gpssleeptime_t * man_data_get_setting_gpssleeptime( void )
//  712 {
//  713 	return &man_data_work.setting_info.gpssleeptime_num;
man_data_get_setting_gpssleeptime:
        LDR      R0,??DataTable43_1
        BX       LR               ;; return
//  714 }
          CFI EndBlock cfiBlock15
//  715 
//  716 
//  717 /********************************************************************/
//  718 /*!
//  719  * \name	man_data_set_setting_batalarm
//  720  * \brief	バッテリ残量警告閾値設定情報を設定する処理
//  721  * \param	batalarm : バッテリ残量警告閾値設定情報
//  722  * \return  なし
//  723  * \note	必要時に呼ばれること
//  724  */
//  725 /********************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock16 Using cfiCommon0
          CFI Function man_data_set_setting_batalarm
        THUMB
//  726 void man_data_set_setting_batalarm(man_data_num_batalarm_t batalarm)
//  727 {
man_data_set_setting_batalarm:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOVS     R4,R0
//  728 	man_data_work.setting_info.batalarm_num = batalarm;
        LDR      R0,??DataTable43_2
        STR      R4,[R0, #+0]
//  729 	man_data_work.setting_info.other_num.batt_low_error_num = batalarm.alarm_bat_num - (batalarm.alarm_bat_num % 10);
        MOVS     R0,R4
        MOVS     R1,#+10
          CFI FunCall __aeabi_uidivmod
        BL       __aeabi_uidivmod
        SUBS     R0,R4,R1
        LDR      R1,??DataTable43_3
        STR      R0,[R1, #+0]
//  730 }
        POP      {R4,PC}          ;; return
          CFI EndBlock cfiBlock16

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable14:
        DC32     man_data_work+0x3890

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable14_1:
        DC32     man_data_work+0x21FC
//  731 
//  732 /********************************************************************/
//  733 /*!
//  734  * \name	man_data_get_setting_batalarm
//  735  * \brief	バッテリ残量警告閾値設定情報を取得する処理
//  736  * \param	なし
//  737  * \return  バッテリ残量警告閾値設定情報へのポインタ
//  738  * \note	必要時に呼ばれること
//  739  */
//  740 /********************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock17 Using cfiCommon0
          CFI Function man_data_get_setting_batalarm
          CFI NoCalls
        THUMB
//  741 man_data_num_batalarm_t * man_data_get_setting_batalarm( void )
//  742 {
//  743 	return &man_data_work.setting_info.batalarm_num;
man_data_get_setting_batalarm:
        LDR      R0,??DataTable43_2
        BX       LR               ;; return
//  744 }
          CFI EndBlock cfiBlock17

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable15:
        DC32     magic_number_prg_tbl
//  745 
//  746 /********************************************************************/
//  747 /*!
//  748  * \name	man_data_set_setting_sensor
//  749  * \brief	加速度センサー閾値設定情報を設定する処理
//  750  * \param	sensor : 加速度センサー閾値設定情報
//  751  * \return  なし
//  752  * \note	必要時に呼ばれること
//  753  */
//  754 /********************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock18 Using cfiCommon0
          CFI Function man_data_set_setting_sensor
          CFI NoCalls
        THUMB
//  755 void man_data_set_setting_sensor(man_data_num_sensor_t sensor)
//  756 {
//  757 	man_data_work.setting_info.sensor_num = sensor;
man_data_set_setting_sensor:
        LDR      R1,??DataTable43_4
        STR      R0,[R1, #+0]
//  758 }
        BX       LR               ;; return
          CFI EndBlock cfiBlock18
//  759 
//  760 /********************************************************************/
//  761 /*!
//  762  * \name	man_data_get_setting_sensor
//  763  * \brief	加速度センサー閾値設定情報を取得する処理
//  764  * \param	なし
//  765  * \return  加速度センサー閾値設定情報へのポインタ
//  766  * \note	必要時に呼ばれること
//  767  */
//  768 /********************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock19 Using cfiCommon0
          CFI Function man_data_get_setting_sensor
          CFI NoCalls
        THUMB
//  769 man_data_num_sensor_t * man_data_get_setting_sensor( void )
//  770 {
//  771 	return &man_data_work.setting_info.sensor_num;
man_data_get_setting_sensor:
        LDR      R0,??DataTable43_4
        BX       LR               ;; return
//  772 }
          CFI EndBlock cfiBlock19
//  773 
//  774 
//  775 /********************************************************************/
//  776 /*!
//  777  * \name	man_data_set_setting_alarmtime
//  778  * \brief	定刻測位時間帯設定情報を設定する処理
//  779  * \param	alarmtime : 定刻測位時間帯設定情報
//  780  * \return  なし
//  781  * \note	必要時に呼ばれること
//  782  */
//  783 /********************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock20 Using cfiCommon0
          CFI Function man_data_set_setting_alarmtime
          CFI NoCalls
        THUMB
//  784 void man_data_set_setting_alarmtime(man_data_num_alarmtime_t alarmtime)
//  785 {
//  786     man_data_work.setting_info.alarmtime_num = alarmtime;
man_data_set_setting_alarmtime:
        LDR      R1,??DataTable43_5
        STR      R0,[R1, #+0]
//  787 }
        BX       LR               ;; return
          CFI EndBlock cfiBlock20
//  788 
//  789 /********************************************************************/
//  790 /*!
//  791  * \name	man_data_set_setting_alarmtime2
//  792  * \brief	定刻測位時間帯設定情報を設定する処理
//  793  * \param	alarmtime : 定刻測位時間帯設定情報
//  794  * \return  なし
//  795  * \note	必要時に呼ばれること
//  796  */
//  797 /********************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock21 Using cfiCommon0
          CFI Function man_data_set_setting_almtrtime
          CFI NoCalls
        THUMB
//  798 void man_data_set_setting_almtrtime(man_data_num_alarmtime_t alarmtime, int32_t alarm_transfer_time)
//  799 {
//  800   //man_data_work.setting_info.alarmtime_num = alarmtime;
//  801   man_data_work.setting_info.other_num.alarm_transfer_time = alarm_transfer_time;
man_data_set_setting_almtrtime:
        LDR      R0,??DataTable43_6
        STR      R1,[R0, #+0]
//  802 }
        BX       LR               ;; return
          CFI EndBlock cfiBlock21
//  803 
//  804 /********************************************************************/
//  805 /*!
//  806  * \name	man_data_get_setting_alarmtime
//  807  * \brief	定刻測位時間帯設定情報を取得する処理
//  808  * \param	なし
//  809  * \return  定刻測位時間帯設定情報へのポインタ
//  810  * \note	必要時に呼ばれること
//  811  */
//  812 /********************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock22 Using cfiCommon0
          CFI Function man_data_get_setting_alarmtime
          CFI NoCalls
        THUMB
//  813 man_data_num_alarmtime_t * man_data_get_setting_alarmtime( void )
//  814 {
//  815 	return &man_data_work.setting_info.alarmtime_num;
man_data_get_setting_alarmtime:
        LDR      R0,??DataTable43_5
        BX       LR               ;; return
//  816 }
          CFI EndBlock cfiBlock22

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable20:
        DC32     man_data_work+0x200C
//  817 
//  818 
//  819 /********************************************************************/
//  820 /*!
//  821  * \name	man_data_set_setting_other
//  822  * \brief	その他の設定情報を設定する処理
//  823  * \param	other : その他の設定情報
//  824  * \return  なし
//  825  * \note	必要時に呼ばれること
//  826  */
//  827 /********************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock23 Using cfiCommon0
          CFI Function man_data_set_setting_other
        THUMB
//  828 void man_data_set_setting_other(man_data_num_other_t other)
//  829 {
man_data_set_setting_other:
        PUSH     {R0-R3}
          CFI CFA R13+16
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -20)
          CFI CFA R13+24
//  830 	man_data_work.setting_info.other_num = other;
        LDR      R0,??DataTable43_3
        ADD      R1,SP,#+8
        MOVS     R2,#+20
          CFI FunCall __aeabi_memcpy4
        BL       __aeabi_memcpy4
//  831 }
        LDR      R0,[SP, #+4]
          CFI R14 R0
        ADD      SP,SP,#+24
          CFI CFA R13+0
        BX       R0               ;; return
          CFI EndBlock cfiBlock23
//  832 
//  833 /********************************************************************/
//  834 /*!
//  835  * \name	man_data_get_setting_other
//  836  * \brief	その他の設定情報を取得する処理
//  837  * \param	なし
//  838  * \return  その他の設定情報へのポインタ
//  839  * \note	必要時に呼ばれること
//  840  */
//  841 /********************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock24 Using cfiCommon0
          CFI Function man_data_get_setting_other
          CFI NoCalls
        THUMB
//  842 man_data_num_other_t * man_data_get_setting_other( void )
//  843 {
//  844 	return &man_data_work.setting_info.other_num;
man_data_get_setting_other:
        LDR      R0,??DataTable43_3
        BX       LR               ;; return
//  845 }
          CFI EndBlock cfiBlock24
//  846 
//  847 
//  848 /********************************************************************/
//  849 /*!
//  850  * \name	man_data_set_imei
//  851  * \brief	IMEI設定情報を設定する処理
//  852  * \param	imei  : 設定するIMEI
//  853  * \return  なし
//  854  * \note	必要時に呼ばれること
//  855  */
//  856 /********************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock25 Using cfiCommon0
          CFI Function man_data_set_imei
        THUMB
//  857 void man_data_set_imei( uint8_t *imei )
//  858 {
man_data_set_imei:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
//  859 	memcpy(&man_data_work.other_info.imei[0], imei, MAN_DATA_IMEI_LENGTH);
        MOVS     R2,#+15
        LDR      R4,??DataTable29_1
        MOVS     R1,R0
        MOVS     R0,R4
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
//  860 }
        POP      {R4,PC}          ;; return
          CFI EndBlock cfiBlock25
//  861 
//  862 /********************************************************************/
//  863 /*!
//  864  * \name	man_data_set_revision
//  865  * \brief	revision情報を設定する処理
//  866  * \param	revision  : 設定するrevision
//  867  * \return  なし
//  868  * \note	必要時に呼ばれること
//  869  */
//  870 /********************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock26 Using cfiCommon0
          CFI Function man_data_set_revision
        THUMB
//  871 void man_data_set_revision( uint8_t *revision )
//  872 {
man_data_set_revision:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
//  873 	memcpy(&man_data_work.other_info.revision[0], revision, MAN_DATA_REVISION_LENGTH);
        MOVS     R2,#+16
        LDR      R4,??DataTable44
        MOVS     R1,R0
        MOVS     R0,R4
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
//  874 }
        POP      {R4,PC}          ;; return
          CFI EndBlock cfiBlock26
//  875 
//  876 /********************************************************************/
//  877 /*!
//  878  * \name	man_data_set_ipaddr
//  879  * \brief	ip address情報を設定する処理
//  880  * \param	ipaddr  : 設定するip address
//  881  * \return  なし
//  882  * \note	必要時に呼ばれること
//  883  */
//  884 /********************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock27 Using cfiCommon0
          CFI Function man_data_set_ipaddr
        THUMB
//  885 void man_data_set_ipaddr( uint8_t *ipaddr )
//  886 {
man_data_set_ipaddr:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
//  887 	memcpy(&man_data_work.other_info.ipaddr[0], ipaddr, MAN_DATA_IP_LENGTH);
        MOVS     R2,#+15
        LDR      R4,??DataTable44_1
        MOVS     R1,R0
        MOVS     R0,R4
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
//  888 }
        POP      {R4,PC}          ;; return
          CFI EndBlock cfiBlock27

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable25:
        DC32     man_data_work+0x220C
//  889 
//  890 /********************************************************************/
//  891 /*!
//  892  * \name	man_data_set_cid
//  893  * \brief	CID設定情報を設定する処理
//  894  * \param	cid  : 設定するCID
//  895  * \return  なし
//  896  * \note	必要時に呼ばれること
//  897  */
//  898 /********************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock28 Using cfiCommon0
          CFI Function man_data_set_cid
        THUMB
//  899 void man_data_set_cid( uint8_t *cid )
//  900 {
man_data_set_cid:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
//  901 	memcpy(&man_data_work.other_info.cid[0], cid, MAN_DATA_CID_LENGTH);
        MOVS     R2,#+8
        LDR      R4,??DataTable44_2
        MOVS     R1,R0
        MOVS     R0,R4
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
//  902 }
        POP      {R4,PC}          ;; return
          CFI EndBlock cfiBlock28
//  903 
//  904 /********************************************************************/
//  905 /*!
//  906  * \name	man_data_set_battery_alarm
//  907  * \brief	CID設定情報を設定する処理
//  908  * \param	battery_alarm  : バッテリー残量警告しきい値[0%-100%]
//  909  * \return  なし
//  910  * \note	必要時に呼ばれること
//  911  */
//  912 /********************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock29 Using cfiCommon0
          CFI Function man_data_set_battery_alarm
          CFI NoCalls
        THUMB
//  913 void man_data_set_battery_alarm( uint32_t battery_alarm )
//  914 {
//  915 	man_data_work.other_info.battery_alarm = battery_alarm;
man_data_set_battery_alarm:
        LDR      R1,??DataTable44_3
        STR      R0,[R1, #+0]
//  916 }
        BX       LR               ;; return
          CFI EndBlock cfiBlock29

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable27:
        DC32     factory_tbl

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable27_1:
        DC32     0x38ac

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable27_2:
        DC32     man_data_work

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable27_3:
        DC32     man_data_work+0x3878
//  917 
//  918 
//  919 /********************************************************************/
//  920 /*!
//  921  * \name	man_data_set_term_version
//  922  * \brief	端末バージョン情報を設定する処理
//  923  * \param	data  : 端末バージョン情報
//  924  * \return  なし
//  925  * \note	必要時に呼ばれること
//  926  */
//  927 /********************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock30 Using cfiCommon0
          CFI Function man_data_set_term_version
        THUMB
//  928 void man_data_set_term_version( uint8_t *data, int32_t length )
//  929 {
man_data_set_term_version:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        MOVS     R4,R1
//  930 	if (length <= MAN_DATA_TERM_VER_LENGTH) {
        CMP      R4,#+49
        BGE      ??man_data_set_term_version_0
//  931 		memcpy(&man_data_work.other_info.term_version, data, length);
        LDR      R5,??DataTable35
        MOVS     R2,R4
        MOVS     R1,R0
        MOVS     R0,R5
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
//  932 		man_data_work.other_info.term_version[length] = NULL;
        MOVS     R0,#+0
        LDR      R1,??DataTable44_4
        ADDS     R1,R1,R4
        LDR      R2,??DataTable44_5  ;; 0x2a3c
        STRB     R0,[R1, R2]
//  933 	}
//  934 }
??man_data_set_term_version_0:
        POP      {R0,R4,R5,PC}    ;; return
          CFI EndBlock cfiBlock30

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable28:
        DC32     man_data_work+0x4
//  935 
//  936 
//  937 /********************************************************************/
//  938 /*!
//  939  * \name	man_data_set_gps_version
//  940  * \brief	GPSバージョン情報を設定する処理
//  941  * \param	data  : 端末バージョン情報
//  942  * \return  なし
//  943  * \note	必要時に呼ばれること
//  944  */
//  945 /********************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock31 Using cfiCommon0
          CFI Function man_data_set_gps_version
        THUMB
//  946 void man_data_set_gps_version( uint8_t *data, int32_t length )
//  947 {
man_data_set_gps_version:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        MOVS     R4,R1
//  948 	if (length <= MAN_DATA_GPS_VER_LENGTH) {
        CMP      R4,#+6
        BGE      ??man_data_set_gps_version_0
//  949 		memcpy(&man_data_work.other_info.gps_version, data, length);
        LDR      R5,??DataTable44_6
        MOVS     R2,R4
        MOVS     R1,R0
        MOVS     R0,R5
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
//  950 		man_data_work.other_info.gps_version[length] = NULL;
        MOVS     R0,#+0
        LDR      R1,??DataTable44_4
        ADDS     R1,R1,R4
        LDR      R2,??DataTable44_7  ;; 0x2a6d
        STRB     R0,[R1, R2]
//  951 	}
//  952 }
??man_data_set_gps_version_0:
        POP      {R0,R4,R5,PC}    ;; return
          CFI EndBlock cfiBlock31

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable29:
        DC32     other_tbl

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable29_1:
        DC32     man_data_work+0x2A1C
//  953 
//  954 /********************************************************************/
//  955 /*!
//  956  * \name	man_data_set_setting_otastart
//  957  * \brief	otastart情報を設定する処理
//  958  * \param	otastart  : otastart情報
//  959  * \return  なし
//  960  * \note	必要時に呼ばれること
//  961  */
//  962 /********************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock32 Using cfiCommon0
          CFI Function man_data_set_setting_otastart
        THUMB
//  963 void man_data_set_setting_otastart(man_data_num_otastart_t otastart)
//  964 {
man_data_set_setting_otastart:
        PUSH     {R0-R3}
          CFI CFA R13+16
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -20)
          CFI CFA R13+24
//  965 	man_data_work.temp_info.otastart_num = otastart;
        LDR      R0,??DataTable44_8
        ADD      R1,SP,#+8
        MOVS     R2,#+255
        ADDS     R2,R2,#+12       ;; #+267
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
//  966 }
        LDR      R0,[SP, #+4]
          CFI R14 R0
        ADD      SP,SP,#+24
          CFI CFA R13+0
        BX       R0               ;; return
          CFI EndBlock cfiBlock32

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable30:
        DC32     fixed_tbl

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable30_1:
        DC32     man_data_work+0x2A94
//  967 
//  968 /********************************************************************/
//  969 /*!
//  970  * \name	man_data_get_setting_otastart
//  971  * \brief	otastart情報を取得する処理
//  972  * \param	なし
//  973  * \return  otastart情報へのポインタ
//  974  * \note	必要時に呼ばれること
//  975  */
//  976 /********************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock33 Using cfiCommon0
          CFI Function man_data_get_setting_otastart
          CFI NoCalls
        THUMB
//  977 man_data_num_otastart_t * man_data_get_setting_otastart( void )
//  978 {
//  979 	return &man_data_work.temp_info.otastart_num;
man_data_get_setting_otastart:
        LDR      R0,??DataTable44_8
        BX       LR               ;; return
//  980 }
          CFI EndBlock cfiBlock33
//  981 
//  982 /********************************************************************/
//  983 /*!
//  984  * \name	man_data_set_setting_gpsota
//  985  * \brief	gpsota情報を設定する処理
//  986  * \param	gpsota  : gpsota情報
//  987  * \return  なし
//  988  * \note	必要時に呼ばれること
//  989  */
//  990 /********************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock34 Using cfiCommon0
          CFI Function man_data_set_setting_gpsota
        THUMB
//  991 void man_data_set_setting_gpsota(man_data_num_gpsota_t gpsota)
//  992 {
man_data_set_setting_gpsota:
        PUSH     {R0-R3}
          CFI CFA R13+16
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -20)
          CFI CFA R13+24
//  993 	man_data_work.temp_info.gpsota_num = gpsota;
        LDR      R0,??DataTable44_9
        ADD      R1,SP,#+8
        LDR      R2,??DataTable44_10  ;; 0x20f
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
//  994 }
        LDR      R0,[SP, #+4]
          CFI R14 R0
        ADD      SP,SP,#+24
          CFI CFA R13+0
        BX       R0               ;; return
          CFI EndBlock cfiBlock34
//  995 
//  996 /********************************************************************/
//  997 /*!
//  998  * \name	man_data_get_setting_gpsota
//  999  * \brief	gpsota情報を取得する処理
// 1000  * \param	なし
// 1001  * \return  gpsota情報へのポインタ
// 1002  * \note	必要時に呼ばれること
// 1003  */
// 1004 /********************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock35 Using cfiCommon0
          CFI Function man_data_get_setting_gpsota
          CFI NoCalls
        THUMB
// 1005 man_data_num_gpsota_t * man_data_get_setting_gpsota( void )
// 1006 {
// 1007 	return &man_data_work.temp_info.gpsota_num;
man_data_get_setting_gpsota:
        LDR      R0,??DataTable44_9
        BX       LR               ;; return
// 1008 }
          CFI EndBlock cfiBlock35

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable33:
        DC32     0x1001
// 1009 
// 1010 /********************************************************************/
// 1011 /*!
// 1012  * \name	man_data_set_setting_usbota
// 1013  * \brief	usbota情報を設定する処理
// 1014  * \param	usbota  : usbota情報
// 1015  * \return  なし
// 1016  * \note	必要時に呼ばれること
// 1017  */
// 1018 /********************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock36 Using cfiCommon0
          CFI Function man_data_set_setting_usbota
        THUMB
// 1019 void man_data_set_setting_usbota(man_data_num_usbota_t usbota)
// 1020 {
man_data_set_setting_usbota:
        PUSH     {R0-R3}
          CFI CFA R13+16
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -20)
          CFI CFA R13+24
// 1021 	man_data_work.temp_info.usbota_num = usbota;
        LDR      R0,??DataTable44_11
        ADD      R1,SP,#+8
        MOVS     R2,#+130
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
// 1022 }
        LDR      R0,[SP, #+4]
          CFI R14 R0
        ADD      SP,SP,#+24
          CFI CFA R13+0
        BX       R0               ;; return
          CFI EndBlock cfiBlock36
// 1023 
// 1024 /********************************************************************/
// 1025 /*!
// 1026  * \name	man_data_get_setting_usbota
// 1027  * \brief	usbota情報を取得する処理
// 1028  * \param	なし
// 1029  * \return  usbota情報へのポインタ
// 1030  * \note	必要時に呼ばれること
// 1031  */
// 1032 /********************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock37 Using cfiCommon0
          CFI Function man_data_get_setting_usbota
          CFI NoCalls
        THUMB
// 1033 man_data_num_usbota_t * man_data_get_setting_usbota( void )
// 1034 {
// 1035 	return &man_data_work.temp_info.usbota_num;
man_data_get_setting_usbota:
        LDR      R0,??DataTable44_11
        BX       LR               ;; return
// 1036 }
          CFI EndBlock cfiBlock37

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable35:
        DC32     man_data_work+0x2A3C
// 1037 
// 1038 /********************************************************************/
// 1039 /*!
// 1040  * \name	man_data_set_setting_usbgpsota
// 1041  * \brief	usbgpsota情報を設定する処理
// 1042  * \param	usbgpsota  : usbgpsota情報
// 1043  * \return  なし
// 1044  * \note	必要時に呼ばれること
// 1045  */
// 1046 /********************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock38 Using cfiCommon0
          CFI Function man_data_set_setting_usbgpsota
        THUMB
// 1047 void man_data_set_setting_usbgpsota(man_data_num_usbgpsota_t usbgpsota)
// 1048 {
man_data_set_setting_usbgpsota:
        PUSH     {R0-R3}
          CFI CFA R13+16
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -20)
          CFI CFA R13+24
// 1049 	man_data_work.temp_info.usbgpsota_num = usbgpsota;
        LDR      R0,??DataTable44_12
        ADD      R1,SP,#+8
        MOVS     R2,#+195
        LSLS     R2,R2,#+1        ;; #+390
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
// 1050 }
        LDR      R0,[SP, #+4]
          CFI R14 R0
        ADD      SP,SP,#+24
          CFI CFA R13+0
        BX       R0               ;; return
          CFI EndBlock cfiBlock38
// 1051 
// 1052 /********************************************************************/
// 1053 /*!
// 1054  * \name	man_data_get_setting_usbgpsota
// 1055  * \brief	usbgpsota情報を取得する処理
// 1056  * \param	なし
// 1057  * \return  usbgpsota情報へのポインタ
// 1058  * \note	必要時に呼ばれること
// 1059  */
// 1060 /********************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock39 Using cfiCommon0
          CFI Function man_data_get_setting_usbgpsota
          CFI NoCalls
        THUMB
// 1061 man_data_num_usbgpsota_t * man_data_get_setting_usbgpsota( void )
// 1062 {
// 1063 	return &man_data_work.temp_info.usbgpsota_num;
man_data_get_setting_usbgpsota:
        LDR      R0,??DataTable44_12
        BX       LR               ;; return
// 1064 }
          CFI EndBlock cfiBlock39
// 1065 
// 1066 /********************************************************************/
// 1067 /*!
// 1068  * \name	man_data_set_ftp_info
// 1069  * \brief	FTP情報を設定する処理
// 1070  * \param	ftp_info  : FTP情報
// 1071  * \return  なし
// 1072  * \note	必要時に呼ばれること
// 1073  */
// 1074 /********************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock40 Using cfiCommon0
          CFI Function man_data_set_ftp_info
        THUMB
// 1075 void man_data_set_ftp_info(man_data_num_ftp_t ftp_info)
// 1076 {
man_data_set_ftp_info:
        PUSH     {R0-R3}
          CFI CFA R13+16
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -20)
          CFI CFA R13+24
// 1077 	man_data_work.temp_info.ftp_info = ftp_info;
        LDR      R0,??DataTable44_13
        ADD      R1,SP,#+8
        MOVS     R2,#+255
        ADDS     R2,R2,#+12       ;; #+267
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
// 1078 }
        LDR      R0,[SP, #+4]
          CFI R14 R0
        ADD      SP,SP,#+24
          CFI CFA R13+0
        BX       R0               ;; return
          CFI EndBlock cfiBlock40
// 1079 
// 1080 /********************************************************************/
// 1081 /*!
// 1082  * \name	man_data_get_ftp_info
// 1083  * \brief	FTP情報を取得する処理
// 1084  * \param	なし
// 1085  * \return  FTP情報へのポインタ
// 1086  * \note	必要時に呼ばれること
// 1087  */
// 1088 /********************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock41 Using cfiCommon0
          CFI Function man_data_get_ftp_info
          CFI NoCalls
        THUMB
// 1089 man_data_num_ftp_t * man_data_get_ftp_info( void )
// 1090 {
// 1091 	return &man_data_work.temp_info.ftp_info;
man_data_get_ftp_info:
        LDR      R0,??DataTable44_13
        BX       LR               ;; return
// 1092 }
          CFI EndBlock cfiBlock41
// 1093 
// 1094 /********************************************************************/
// 1095 /*!
// 1096  * \name	man_data_get_other
// 1097  * \brief	その他情報を取得する処理
// 1098  * \param	なし
// 1099  * \return  その他情報へのポインタ
// 1100  * \note	必要時に呼ばれること
// 1101  */
// 1102 /********************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock42 Using cfiCommon0
          CFI Function man_data_get_other
          CFI NoCalls
        THUMB
// 1103 man_data_get_other_t * man_data_get_other( void )
// 1104 {
// 1105 	return &man_data_work.other_info;
man_data_get_other:
        LDR      R0,??DataTable44_14
        BX       LR               ;; return
// 1106 }
          CFI EndBlock cfiBlock42
// 1107 
// 1108 /********************************************************************/
// 1109 /*!
// 1110  * \name	man_data_get_fixed
// 1111  * \brief	固定情報を取得する処理
// 1112  * \param	なし
// 1113  * \return  固定情報へのポインタ
// 1114  * \note	必要時に呼ばれること
// 1115  */
// 1116 /********************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock43 Using cfiCommon0
          CFI Function man_data_get_fixed
          CFI NoCalls
        THUMB
// 1117 man_data_fixed_t * man_data_get_fixed( void )
// 1118 {
// 1119 	return &man_data_work.fixed_info;
man_data_get_fixed:
        LDR      R0,??DataTable44_15
        BX       LR               ;; return
// 1120 }
          CFI EndBlock cfiBlock43

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable41:
        DC32     man_data_work+0x100C

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable41_1:
        DC32     man_data_work+0xC
// 1121 
// 1122 
// 1123 
// 1124 /********************************************************************/
// 1125 /*!
// 1126  * \name	man_data_flash_erase_sector
// 1127  * \brief	内蔵FLASHのSECTOR消去を実施する処理
// 1128  * \param	top_addr    : 消去する先頭アドレス
// 1129  *          sector_num  : 消去するセクタ数
// 1130  *          id          : ユニーク番号
// 1131  *          callback    : 完了を通知するcallback関数
// 1132  * \return   0: 成功
// 1133  *          -1:失敗
// 1134  * \note	必要時に、呼ばれる
// 1135  *          全消去完了後にcallback関数が呼ばれます
// 1136  */
// 1137 /********************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock44 Using cfiCommon0
          CFI Function man_data_flash_erase_sector
          CFI NoCalls
        THUMB
// 1138 int32_t  man_data_flash_erase_sector(uint32_t top_addr, int32_t sector_num, int32_t id, func_man_data callback)
// 1139 {
man_data_flash_erase_sector:
        PUSH     {R4,R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+12
        MOVS     R4,R0
// 1140 	int32_t	ret = -1;
        MOVS     R0,#+0
        MVNS     R0,R0            ;; #-1
// 1141 
// 1142 	// 要求を保存する
// 1143 	if (sector_num != 0) {
        CMP      R1,#+0
        BEQ      ??man_data_flash_erase_sector_0
// 1144 		man_data_work.request.req_cmd = MAN_DATA_REQ_CMD_ERASE_SECTOR;
        MOVS     R0,#+1
        LDR      R5,??DataTable44_16
        STR      R0,[R5, #+0]
// 1145 		man_data_work.request.top_addr = top_addr;
        LDR      R0,??DataTable44_17
        STR      R4,[R0, #+0]
// 1146 		man_data_work.request.sector_num = sector_num;
        LDR      R0,??DataTable44_18
        STR      R1,[R0, #+0]
// 1147 		man_data_work.request.id = id;
        LDR      R0,??DataTable44_19
        STR      R2,[R0, #+0]
// 1148 		man_data_work.request.callback = callback;
        LDR      R0,??DataTable44_20
        STR      R3,[R0, #+0]
// 1149 		ret = 0;
        MOVS     R0,#+0
// 1150 	}
// 1151 
// 1152 	return ret;
??man_data_flash_erase_sector_0:
        POP      {R4,R5,PC}       ;; return
// 1153 }
          CFI EndBlock cfiBlock44
// 1154 
// 1155 
// 1156 /********************************************************************/
// 1157 /*!
// 1158  * \name	man_data_flash_write_sector
// 1159  * \brief	内蔵FLASHのSECTOR書き込みを実施する処理
// 1160  * \param	top_addr    : 書き込む先頭アドレス
// 1161  *          data        : 書き込むデータ
// 1162  *          length      : 書き込むサイズ(最大値はMAN_DATA_FLASH_SIZE)
// 1163  * \return   0: 成功
// 1164  *          -1:失敗
// 1165  * \note	man_data_flash_erase_sector()実施後に呼ばれること
// 1166  */
// 1167 /********************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock45 Using cfiCommon0
          CFI Function man_data_flash_write_sector
        THUMB
// 1168 int32_t  man_data_flash_write_sector(uint32_t top_addr, uint8_t *data, int32_t length)
// 1169 {
man_data_flash_write_sector:
        PUSH     {R3-R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI R7 Frame(CFA, -8)
          CFI R6 Frame(CFA, -12)
          CFI R5 Frame(CFA, -16)
          CFI R4 Frame(CFA, -20)
          CFI CFA R13+24
        MOVS     R6,R0
        MOVS     R5,R1
        MOVS     R7,R2
// 1170 	int32_t			ret=-1;
        MOVS     R4,#+0
        MVNS     R4,R4            ;; #-1
// 1171 
// 1172 
// 1173 	if ( (data != NULL) && (length <= MAN_DATA_FLASH_SIZE) ) {
        CMP      R5,#+0
        BEQ      ??man_data_flash_write_sector_0
        LDR      R0,??DataTable44_21  ;; 0x1001
        CMP      R7,R0
        BGE      ??man_data_flash_write_sector_0
// 1174 
// 1175 		// flash driver使用開始
// 1176 		flash_start();
          CFI FunCall flash_start
        BL       flash_start
// 1177 
// 1178 		// FLASH書き込み
// 1179 		ret = flash_write(top_addr, data, length);
        MOVS     R2,R7
        MOVS     R1,R5
        MOVS     R0,R6
          CFI FunCall flash_write
        BL       flash_write
        MOVS     R4,R0
// 1180 
// 1181 		// FLASH読み込み
// 1182 		if (ret >= 0) {
        CMP      R4,#+0
        BMI      ??man_data_flash_write_sector_1
// 1183 			flash_read(top_addr, &man_data_work.read[0], length);
        MOVS     R2,R7
        LDR      R1,??DataTable45
        MOVS     R0,R6
          CFI FunCall flash_read
        BL       flash_read
// 1184 		}
// 1185 
// 1186 		// 比較
// 1187 		if (ret >= 0) {
??man_data_flash_write_sector_1:
        CMP      R4,#+0
        BMI      ??man_data_flash_write_sector_2
// 1188 			if (memcmp(&man_data_work.read[0], data, length) != 0) {
        MOVS     R2,R7
        MOVS     R1,R5
        LDR      R0,??DataTable45
          CFI FunCall memcmp
        BL       memcmp
        CMP      R0,#+0
        BEQ      ??man_data_flash_write_sector_2
// 1189 				ret = -1;
        MOVS     R4,#+0
        MVNS     R4,R4            ;; #-1
// 1190 			}
// 1191 		}
// 1192 
// 1193 		// flash driver使用終了
// 1194 		flash_end();
??man_data_flash_write_sector_2:
          CFI FunCall flash_end
        BL       flash_end
// 1195 	}
// 1196 	
// 1197 	return ret;
??man_data_flash_write_sector_0:
        MOVS     R0,R4
        POP      {R1,R4-R7,PC}    ;; return
// 1198 }
          CFI EndBlock cfiBlock45

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable43:
        DC32     man_data_work+0x2AB0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable43_1:
        DC32     man_data_work+0x2B60

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable43_2:
        DC32     man_data_work+0x2B70

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable43_3:
        DC32     man_data_work+0x2B7C

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable43_4:
        DC32     man_data_work+0x2B74

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable43_5:
        DC32     man_data_work+0x2B78

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable43_6:
        DC32     man_data_work+0x2B84
// 1199 
// 1200 
// 1201 /********************************************************************/
// 1202 /*!
// 1203  * \name	man_data_main
// 1204  * \brief	データ管理のメイン処理
// 1205  * \param	なし
// 1206  * \return  なし
// 1207  * \note	毎回、呼ばれること
// 1208  */
// 1209 /********************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock46 Using cfiCommon0
          CFI Function man_data_main
        THUMB
// 1210 void man_data_main( void )
// 1211 {
man_data_main:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
// 1212 	int32_t		ret;
// 1213 	uint32_t	delay;
// 1214 	uint32_t	top_addr;
// 1215 
// 1216 
// 1217 	// ******************************
// 1218 	//    要求処理
// 1219 	// ******************************
// 1220 	switch (man_data_work.request.req_cmd) {
        LDR      R0,??DataTable44_16
        LDR      R0,[R0, #+0]
        CMP      R0,#+0
        BEQ      ??man_data_main_0
        CMP      R0,#+1
        BEQ      ??man_data_main_1
        B        ??man_data_main_2
// 1221 	case MAN_DATA_REQ_CMD_NON:
// 1222 		break;
??man_data_main_0:
        B        ??man_data_main_2
// 1223 	case MAN_DATA_REQ_CMD_ERASE_SECTOR:
// 1224 		if (man_data_work.sequense == MAN_DATA_SEQ_READY) {
??man_data_main_1:
        LDR      R0,??DataTable47
        LDRB     R0,[R0, #+0]
        CMP      R0,#+0
        BNE      ??man_data_main_3
// 1225 			man_data_work.sequense = MAN_DATA_SEQ_ERASE_REQ;
        MOVS     R0,#+1
        LDR      R1,??DataTable47
        STRB     R0,[R1, #+0]
// 1226 			man_data_work.tmp.counter = 0;
        MOVS     R0,#+0
        LDR      R1,??DataTable46
        STR      R0,[R1, #+0]
// 1227 		}
// 1228 		break;
// 1229 	}
// 1230 
// 1231 
// 1232 
// 1233 	// ******************************
// 1234 	//    シーケンス処理
// 1235 	// ******************************
// 1236 	switch (man_data_work.sequense) {
??man_data_main_3:
??man_data_main_2:
        LDR      R0,??DataTable47
        LDRB     R0,[R0, #+0]
        CMP      R0,#+0
        BEQ      ??man_data_main_4
        CMP      R0,#+2
        BEQ      ??man_data_main_5
        BCC      ??man_data_main_6
        B        ??man_data_main_7
// 1237 	case MAN_DATA_SEQ_READY:
// 1238 		break;
??man_data_main_4:
        B        ??man_data_main_7
// 1239 	case MAN_DATA_SEQ_ERASE_REQ:
// 1240 		top_addr = man_data_work.request.top_addr + MAN_DATA_FLASH_SIZE * man_data_work.tmp.counter;
??man_data_main_6:
        LDR      R0,??DataTable44_17
        LDR      R0,[R0, #+0]
        LDR      R1,??DataTable46
        LDR      R1,[R1, #+0]
        MOVS     R2,#+128
        LSLS     R2,R2,#+5        ;; #+4096
        MULS     R1,R2,R1
        ADDS     R4,R0,R1
// 1241 		// flash driver使用開始
// 1242 		flash_start();
          CFI FunCall flash_start
        BL       flash_start
// 1243 		// FLASH消去
// 1244 		ret = flash_erase_sector(top_addr);
        MOVS     R0,R4
          CFI FunCall flash_erase_sector
        BL       flash_erase_sector
        MOVS     R4,R0
// 1245 		// flash driver使用終了
// 1246 		flash_end();
          CFI FunCall flash_end
        BL       flash_end
// 1247 		
// 1248 		// FLASH消去成功時
// 1249 		if (ret >= 0) {
        CMP      R4,#+0
        BMI      ??man_data_main_8
// 1250 			man_data_work.tmp.counter++;
        LDR      R0,??DataTable46
        LDR      R0,[R0, #+0]
        ADDS     R0,R0,#+1
        LDR      R1,??DataTable46
        STR      R0,[R1, #+0]
// 1251 			if (man_data_work.request.sector_num <= man_data_work.tmp.counter) {
        LDR      R0,??DataTable46
        LDR      R0,[R0, #+0]
        LDR      R1,??DataTable44_18
        LDR      R1,[R1, #+0]
        CMP      R0,R1
        BLT      ??man_data_main_9
// 1252 				// 完了を通知する
// 1253 				man_data_return_callback(MAN_DATA_STATUS_OK);
        MOVS     R0,#+0
          CFI FunCall man_data_return_callback
        BL       man_data_return_callback
        B        ??man_data_main_10
// 1254 			}
// 1255 			else {
// 1256 				man_data_work.sequense = MAN_DATA_SEQ_ERASE_WAIT;
??man_data_main_9:
        MOVS     R0,#+2
        LDR      R1,??DataTable47
        STRB     R0,[R1, #+0]
// 1257 				man_data_work.tmp.start_time = man_timer_get_1ms_count();
          CFI FunCall man_timer_get_1ms_count
        BL       man_timer_get_1ms_count
        LDR      R1,??DataTable46_1
        STR      R0,[R1, #+0]
        B        ??man_data_main_10
// 1258 			}
// 1259 		}
// 1260 		
// 1261 		// FLASH消去失敗時
// 1262 		else {
// 1263 			// 失敗を通知する
// 1264 			man_data_return_callback(MAN_DATA_STATUS_NG);
??man_data_main_8:
        MOVS     R0,#+0
        MVNS     R0,R0            ;; #-1
          CFI FunCall man_data_return_callback
        BL       man_data_return_callback
// 1265 		}
// 1266 		break;
??man_data_main_10:
        B        ??man_data_main_7
// 1267 	case MAN_DATA_SEQ_ERASE_WAIT:
// 1268 		delay = man_timer_get_elapsed_time(man_data_work.tmp.start_time, man_timer_get_1ms_count());
??man_data_main_5:
          CFI FunCall man_timer_get_1ms_count
        BL       man_timer_get_1ms_count
        MOVS     R1,R0
        LDR      R0,??DataTable46_1
        LDR      R0,[R0, #+0]
          CFI FunCall man_timer_get_elapsed_time
        BL       man_timer_get_elapsed_time
// 1269 		if (delay >= 100) {
        CMP      R0,#+100
        BCC      ??man_data_main_11
// 1270 			man_data_work.sequense = MAN_DATA_SEQ_ERASE_REQ;
        MOVS     R0,#+1
        LDR      R1,??DataTable47
        STRB     R0,[R1, #+0]
// 1271 		}
// 1272 		break;
// 1273 	}
// 1274 }
??man_data_main_11:
??man_data_main_7:
        POP      {R4,PC}          ;; return
          CFI EndBlock cfiBlock46

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable44:
        DC32     man_data_work+0x2A73

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable44_1:
        DC32     man_data_work+0x2A84

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable44_2:
        DC32     man_data_work+0x2A2C

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable44_3:
        DC32     man_data_work+0x2A38

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable44_4:
        DC32     man_data_work

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable44_5:
        DC32     0x2a3c

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable44_6:
        DC32     man_data_work+0x2A6D

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable44_7:
        DC32     0x2a6d

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable44_8:
        DC32     man_data_work+0x23EC

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable44_9:
        DC32     man_data_work+0x24F7

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable44_10:
        DC32     0x20f

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable44_11:
        DC32     man_data_work+0x2706

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable44_12:
        DC32     man_data_work+0x2788

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable44_13:
        DC32     man_data_work+0x290E

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable44_14:
        DC32     man_data_work+0x2A1C

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable44_15:
        DC32     man_data_work+0x2A94

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable44_16:
        DC32     man_data_work+0x3890

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable44_17:
        DC32     man_data_work+0x3894

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable44_18:
        DC32     man_data_work+0x3898

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable44_19:
        DC32     man_data_work+0x389C

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable44_20:
        DC32     man_data_work+0x38A0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable44_21:
        DC32     0x1001
// 1275 
// 1276 
// 1277 
// 1278 
// 1279 

        SECTION `.data`:DATA:REORDER:NOROOT(2)
        DATA
// 1280 int32_t	tmp_tbl[] = {-20, -4, 42, 44, 46, 48, 60, 70, 80};
tmp_tbl:
        DC32 -20, -4, 42, 44, 46, 48, 60, 70, 80
// 1281 
// 1282 
// 1283 /********************************************************************/
// 1284 /*!
// 1285  * \name	man_data_collect_sensor
// 1286  * \brief	センサ情報を収集する処理
// 1287  * \param	なし
// 1288  * \return  なし
// 1289  * \note	1000ms毎に更新する
// 1290  */
// 1291 /********************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock47 Using cfiCommon0
          CFI Function man_data_collect_sensor
        THUMB
// 1292 void man_data_collect_sensor( void )
// 1293 {
man_data_collect_sensor:
        PUSH     {R4-R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI R7 Frame(CFA, -8)
          CFI R6 Frame(CFA, -12)
          CFI R5 Frame(CFA, -16)
          CFI R4 Frame(CFA, -20)
          CFI CFA R13+20
        SUB      SP,SP,#+76
          CFI CFA R13+96
// 1294 	man_data_get_sensor_t	*sensor_info = &man_data_work.sensor_info;
        LDR      R4,??DataTable49
// 1295 	man_data_num_sensor_t	*num_sensor = man_data_get_setting_sensor();
          CFI FunCall man_data_get_setting_sensor
        BL       man_data_get_setting_sensor
        MOVS     R6,R0
// 1296 	man_data_num_other_t	*num_other = man_data_get_setting_other();
          CFI FunCall man_data_get_setting_other
        BL       man_data_get_setting_other
        MOVS     R7,R0
// 1297 	man_data_fixed_t		*fixed = man_data_get_fixed();
          CFI FunCall man_data_get_fixed
        BL       man_data_get_fixed
        MOVS     R5,R0
// 1298 	
// 1299 	int32_t					accel_threshold;	// 単位 : uG
// 1300 	man_gyro_data_t			gyro;				// 角速度・加速度データ
// 1301 	int32_t					i;
// 1302 	int32_t					temperature;
// 1303 
// 1304 
// 1305 	// 角速度・加速度取得
// 1306 	man_gyro_get_data(&sensor_info->gyro);
        MOVS     R0,R4
        ADDS     R0,R0,#+12
          CFI FunCall man_gyro_get_data
        BL       man_gyro_get_data
// 1307 
// 1308 	// 気圧・高度・温度取得
// 1309 	man_press_get_data(&sensor_info->temperature, &sensor_info->pressure, &sensor_info->altitude);
        MOVS     R2,R4
        ADDS     R2,R2,#+96
        MOVS     R1,R4
        ADDS     R1,R1,#+92
        MOVS     R0,R4
        ADDS     R0,R0,#+84
          CFI FunCall man_press_get_data
        BL       man_press_get_data
// 1310 
// 1311 	temperature = sensor_info->temperature;
        LDR      R0,[R4, #+84]
// 1312 	// 端末の内部温度を示すコードに変換
// 1313 	for (i=0; i<9; i++) {
        MOVS     R1,#+0
        B        ??man_data_collect_sensor_0
??man_data_collect_sensor_1:
        ADDS     R1,R1,#+1
??man_data_collect_sensor_0:
        CMP      R1,#+9
        BGE      ??man_data_collect_sensor_2
// 1314 		if (temperature < tmp_tbl[i]) {
        LDR      R2,??DataTable51
        MOVS     R3,#+4
        MULS     R3,R1,R3
        LDR      R2,[R2, R3]
        CMP      R0,R2
        BGE      ??man_data_collect_sensor_1
// 1315 			break;
// 1316 		}
// 1317 	}
// 1318 	if (temperature <= -30) {
??man_data_collect_sensor_2:
        MOVS     R2,#+28
        MVNS     R2,R2            ;; #-29
        CMP      R0,R2
        BGE      ??man_data_collect_sensor_3
// 1319 		i=9;
        MOVS     R1,#+9
// 1320 	}
// 1321 	sensor_info->type_num = i;
??man_data_collect_sensor_3:
        STR      R1,[R4, #+88]
// 1322 
// 1323 	// 電波状況を取得
// 1324 	man_http_get_rsrp(&sensor_info->rsrp, &sensor_info->rssi);
        MOVS     R0,#+190
        LSLS     R0,R0,#+4        ;; #+3040
        ADDS     R1,R4,R0
        LDR      R0,??DataTable51_1  ;; 0xbdc
        ADDS     R0,R4,R0
          CFI FunCall man_http_get_rsrp
        BL       man_http_get_rsrp
// 1325 
// 1326 	// NMEAの状態取得
// 1327 	man_gps_get_nmea_status(&sensor_info->nmea_status, &sensor_info->nmea_select);
        LDR      R0,??DataTable53  ;; 0xbcc
        ADDS     R1,R4,R0
        LDR      R0,??DataTable54  ;; 0xbc8
        ADDS     R0,R4,R0
          CFI FunCall man_gps_get_nmea_status
        BL       man_gps_get_nmea_status
// 1328 
// 1329 	// バッテリー情報取得
// 1330 	man_battery_get_data(&sensor_info->voltage, &sensor_info->charge);
        MOVS     R1,R4
        ADDS     R1,R1,#+104
        MOVS     R0,R4
        ADDS     R0,R0,#+100
          CFI FunCall man_battery_get_data
        BL       man_battery_get_data
// 1331 
// 1332 	// 充電情報取得
// 1333 	man_charge_get_data(&sensor_info->charge_state, &sensor_info->ext_state);
        MOVS     R1,R4
        ADDS     R1,R1,#+112
        MOVS     R0,R4
        ADDS     R0,R0,#+108
          CFI FunCall man_charge_get_data
        BL       man_charge_get_data
// 1334 
// 1335 	// 現在時刻取得
// 1336 	man_rtc_get_clock(&sensor_info->clock);
        MOVS     R0,R4
          CFI FunCall man_rtc_get_clock
        BL       man_rtc_get_clock
// 1337 
// 1338 	// LTE状態取得
// 1339 	man_let_get_data(&sensor_info->net_mode);
        MOVS     R0,#+189
        LSLS     R0,R0,#+4        ;; #+3024
        ADDS     R0,R4,R0
          CFI FunCall man_let_get_data
        BL       man_let_get_data
// 1340 	
// 1341 	// 通信中状態取得
// 1342 	man_rpt_get_data(&sensor_info->trans_mode);
        LDR      R0,??DataTable54_1  ;; 0xbd4
        ADDS     R0,R4,R0
          CFI FunCall man_rpt_get_data
        BL       man_rpt_get_data
// 1343 	
// 1344 	// OTA状態取得
// 1345 	man_ota_get_data(&sensor_info->ota_mode);
        LDR      R0,??DataTable55  ;; 0xbd9
        ADDS     R0,R4,R0
          CFI FunCall man_ota_get_data
        BL       man_ota_get_data
// 1346 
// 1347 
// 1348 	// 起動後70秒間 or NET OPENまではセンサー値が安定していないため、メッセージの判定は行わない
// 1349 	if ( (man_data_work.msg_info.counter >= MAN_DATA_MSG_CHECK_WAIT) || (sensor_info->net_mode == MAN_LTE_MODE_OPEN) )  {
        LDR      R0,??DataTable57
        LDR      R0,[R0, #+0]
        CMP      R0,#+70
        BGE      ??man_data_collect_sensor_4
        MOVS     R0,#+189
        LSLS     R0,R0,#+4        ;; #+3024
        LDRB     R0,[R4, R0]
        CMP      R0,#+1
        BNE      ??man_data_collect_sensor_5
// 1350 	
// 1351 		// 加速度系のメッセージ出力処理
// 1352 		accel_threshold = (num_sensor->threshold_num * (int32_t)MAV_DATA_SENSOR_UNIT_UG) / 1000;	// [mG]
??man_data_collect_sensor_4:
        LDR      R0,[R6, #+0]
        LDR      R1,??DataTable56  ;; 0xf424
        MULS     R0,R1,R0
        MOVS     R1,#+250
        LSLS     R1,R1,#+2        ;; #+1000
          CFI FunCall __aeabi_uidiv
        BL       __aeabi_uidiv
        MOVS     R6,R0
// 1353 		gyro.accel_x = abs(sensor_info->nmea_sensor.gyro.accel_x);		// [mG]
        MOVS     R0,#+186
        LSLS     R0,R0,#+4        ;; #+2976
        LDR      R0,[R4, R0]
          CFI FunCall abs
        BL       abs
        STR      R0,[SP, #+48]
// 1354 		gyro.accel_y = abs(sensor_info->nmea_sensor.gyro.accel_y);		// [mG]
        LDR      R0,??DataTable56_1  ;; 0xba4
        LDR      R0,[R4, R0]
          CFI FunCall abs
        BL       abs
        STR      R0,[SP, #+52]
// 1355 		gyro.accel_z = abs(sensor_info->nmea_sensor.gyro.accel_z);		// [mG]
        LDR      R0,??DataTable56_2  ;; 0xba8
        LDR      R0,[R4, R0]
          CFI FunCall abs
        BL       abs
        STR      R0,[SP, #+56]
// 1356 
// 1357 #ifdef ADLINK_DEBUG  //Matsushita
// 1358                  sprintf(print_buf," sensor_info->nmea_sensor.gyro.accel x:%d y:%d z:%d\r\n",
// 1359                                                   gyro.accel_x,
// 1360                                                   gyro.accel_y,
// 1361                                                   gyro.accel_z);
// 1362                  sysmgr_log(print_buf,strlen(print_buf));
// 1363 #endif
// 1364 		if ( (accel_threshold <= gyro.accel_x) || (accel_threshold <= gyro.accel_y) || (accel_threshold <= gyro.accel_z) ) {
        LDR      R0,[SP, #+48]
        CMP      R0,R6
        BGE      ??man_data_collect_sensor_6
        LDR      R0,[SP, #+52]
        CMP      R0,R6
        BGE      ??man_data_collect_sensor_6
        LDR      R0,[SP, #+56]
        CMP      R0,R6
        BLT      ??man_data_collect_sensor_7
// 1365 			if (man_data_work.msg_info.accel_msg != MAN_MSG_TYPE_SHOCK) {
??man_data_collect_sensor_6:
        LDR      R0,??DataTable56_3
        LDR      R0,[R0, #+0]
        CMP      R0,#+46
        BEQ      ??man_data_collect_sensor_8
// 1366 				man_data_work.msg_info.accel_msg = MAN_MSG_TYPE_SHOCK;
        MOVS     R0,#+46
        LDR      R1,??DataTable56_3
        STR      R0,[R1, #+0]
// 1367 				// 有効位置が取得できている場合のみ登録する。
// 1368 				if (sensor_info->nmea_status == MAN_GPS_NMEA_STATUS_EFFECTIVE) {
        LDR      R0,??DataTable54  ;; 0xbc8
        LDR      R0,[R4, R0]
        CMP      R0,#+2
        BNE      ??man_data_collect_sensor_8
// 1369 					man_msg_set_type(MAN_MSG_TYPE_SHOCK);
        MOVS     R0,#+46
          CFI FunCall man_msg_set_type
        BL       man_msg_set_type
        B        ??man_data_collect_sensor_8
// 1370 #ifdef ADLINK_DEBUG
// 1371                                         sprintf(print_buf," Sending Message 46\r\n");
// 1372                                         sysmgr_log(print_buf,strlen(print_buf));
// 1373 #endif
// 1374 				}
// 1375 			}
// 1376 		}
// 1377 		else {
// 1378 			man_data_work.msg_info.accel_msg = MAN_MSG_TYPE_NON;
??man_data_collect_sensor_7:
        MOVS     R0,#+0
        LDR      R1,??DataTable56_3
        STR      R0,[R1, #+0]
// 1379 		}
// 1380 
// 1381 		// 温度系のメッセージ出力処理
// 1382 //		if (sensor_info->temperature >= num_other->temperature_high_num) {
// 1383 		if (
// 1384                     (( sensor_info->temperature > MAN_DATA_TEMP_BAT_MAX) && (man_ope_get_switch_pos() == MAN_OPE_SWITCH_BATTERY))
// 1385                  || (( sensor_info->temperature > MAN_DATA_TEMP_EXT_MAX) && (man_ope_get_switch_pos() != MAN_OPE_SWITCH_BATTERY))
// 1386                 )
??man_data_collect_sensor_8:
        LDR      R0,[R4, #+84]
        CMP      R0,#+61
        BLT      ??man_data_collect_sensor_9
          CFI FunCall man_ope_get_switch_pos
        BL       man_ope_get_switch_pos
        CMP      R0,#+5
        BEQ      ??man_data_collect_sensor_10
??man_data_collect_sensor_9:
        LDR      R0,[R4, #+84]
        CMP      R0,#+71
        BLT      ??man_data_collect_sensor_11
          CFI FunCall man_ope_get_switch_pos
        BL       man_ope_get_switch_pos
        CMP      R0,#+5
        BEQ      ??man_data_collect_sensor_11
// 1387                 {
// 1388  			if (man_data_work.msg_info.temp_msg != MAN_MSG_TYPE_TMP_H) {
??man_data_collect_sensor_10:
        LDR      R0,??DataTable57_1
        LDR      R0,[R0, #+0]
        CMP      R0,#+48
        BEQ      ??man_data_collect_sensor_12
// 1389 				man_data_work.msg_info.temp_msg = MAN_MSG_TYPE_TMP_H;
        MOVS     R0,#+48
        LDR      R1,??DataTable57_1
        STR      R0,[R1, #+0]
// 1390 				man_msg_set_type(MAN_MSG_TYPE_TMP_H);
        MOVS     R0,#+48
          CFI FunCall man_msg_set_type
        BL       man_msg_set_type
        B        ??man_data_collect_sensor_12
// 1391 #if 0 //ADLINK
// 1392                                 sysmgr_set_error( SYSTEM_ERROR_TEMP_OVER_TEMP );
// 1393 #endif
// 1394 			}
// 1395 		}
// 1396 		else {
// 1397 			man_data_work.msg_info.temp_msg = MAN_MSG_TYPE_NON;
??man_data_collect_sensor_11:
        MOVS     R0,#+0
        LDR      R1,??DataTable57_1
        STR      R0,[R1, #+0]
// 1398 		}
// 1399 
// 1400 		// 低電圧系のメッセージ出力処理
// 1401 		if ( sensor_info->charge < num_other->batt_low_error_num) {
??man_data_collect_sensor_12:
        LDR      R0,[R4, #+104]
        LDR      R1,[R7, #+0]
        CMP      R0,R1
        BCS      ??man_data_collect_sensor_13
// 1402 			if (man_data_work.msg_info.low_volt_msg != MAN_MSG_TYPE_BATALARM) {
        LDR      R0,??DataTable57_2
        LDR      R0,[R0, #+0]
        CMP      R0,#+30
        BEQ      ??man_data_collect_sensor_14
// 1403 				man_data_work.msg_info.low_volt_msg = MAN_MSG_TYPE_BATALARM;
        MOVS     R0,#+30
        LDR      R1,??DataTable57_2
        STR      R0,[R1, #+0]
// 1404 				man_msg_set_type(MAN_MSG_TYPE_BATALARM);
        MOVS     R0,#+30
          CFI FunCall man_msg_set_type
        BL       man_msg_set_type
        B        ??man_data_collect_sensor_14
// 1405 			}
// 1406 		}
// 1407 		else {
// 1408 			man_data_work.msg_info.low_volt_msg = MAN_MSG_TYPE_NON;
??man_data_collect_sensor_13:
        MOVS     R0,#+0
        LDR      R1,??DataTable57_2
        STR      R0,[R1, #+0]
// 1409 		}
// 1410 
// 1411 		// バッテリ残量が0系のメッセージ出力処理
// 1412 		// バッテリ残量が内部バッテリ低電圧警告閾値以下の場合
// 1413 		if (sensor_info->charge < fixed->battery_low_war) {
??man_data_collect_sensor_14:
        LDR      R0,[R4, #+104]
        LDR      R1,[R5, #+4]
        CMP      R0,R1
        BCS      ??man_data_collect_sensor_15
// 1414 			if (man_data_work.msg_info.charge0_msg != MAN_MSG_TYPE_0_BATT) {
        LDR      R0,??DataTable57_3
        LDR      R0,[R0, #+0]
        CMP      R0,#+24
        BEQ      ??man_data_collect_sensor_16
// 1415 				man_data_work.msg_info.charge0_msg = MAN_MSG_TYPE_0_BATT;
        MOVS     R0,#+24
        LDR      R1,??DataTable57_3
        STR      R0,[R1, #+0]
// 1416 				man_msg_set_type(MAN_MSG_TYPE_0_BATT);
        MOVS     R0,#+24
          CFI FunCall man_msg_set_type
        BL       man_msg_set_type
// 1417 				sensor_info->charge0_mode = 1;			// 0V状態
        MOVS     R0,#+1
        STR      R0,[R4, #+116]
// 1418 				// park_interval測位開始
// 1419 				man_rpt_req_park_interval();
          CFI FunCall man_rpt_req_park_interval
        BL       man_rpt_req_park_interval
        B        ??man_data_collect_sensor_16
// 1420 			}
// 1421 		}
// 1422 		else {
// 1423 			man_data_work.msg_info.charge0_msg = MAN_MSG_TYPE_NON;
??man_data_collect_sensor_15:
        MOVS     R0,#+0
        LDR      R1,??DataTable57_3
        STR      R0,[R1, #+0]
// 1424 			sensor_info->charge0_mode = 0;
        MOVS     R0,#+0
        STR      R0,[R4, #+116]
        B        ??man_data_collect_sensor_16
// 1425 		}
// 1426 
// 1427 	}
// 1428 	else {
// 1429 		man_data_work.msg_info.counter++;
??man_data_collect_sensor_5:
        LDR      R0,??DataTable57
        LDR      R0,[R0, #+0]
        ADDS     R0,R0,#+1
        LDR      R1,??DataTable57
        STR      R0,[R1, #+0]
// 1430 	}
// 1431 }
??man_data_collect_sensor_16:
        ADD      SP,SP,#+76
          CFI CFA R13+20
        POP      {R4-R7,PC}       ;; return
          CFI EndBlock cfiBlock47

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable45:
        DC32     man_data_work+0x100C
// 1432 
// 1433 
// 1434 
// 1435 /********************************************************************/
// 1436 /*!
// 1437  * \name	man_data_set_nmea
// 1438  * \brief	nmea情報を設定する処理
// 1439  * \param	data   : 設定するNMEAデータ
// 1440  *          length : NMEAデータ長
// 1441  * \return  なし
// 1442  * \note	必要時に呼ばれること
// 1443  */
// 1444 /********************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock48 Using cfiCommon0
          CFI Function man_data_set_nmea
        THUMB
// 1445 void man_data_set_nmea( uint8_t *data, int32_t length )
// 1446 { 
man_data_set_nmea:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        MOVS     R4,R1
// 1447 	if (length < GPS_NMEA_DATA_MAX) {
        MOVS     R1,#+175
        LSLS     R1,R1,#+3        ;; #+1400
        CMP      R4,R1
        BGE      ??man_data_set_nmea_0
// 1448 		memcpy(&man_data_work.sensor_info.nmea[0], data, length);
        LDR      R5,??DataTable57_4
        MOVS     R2,R4
        MOVS     R1,R0
        MOVS     R0,R5
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
// 1449 		man_data_work.sensor_info.nmea_len = length;
        LDR      R0,??DataTable57_5
        STR      R4,[R0, #+0]
// 1450 	}
// 1451 }
??man_data_set_nmea_0:
        POP      {R0,R4,R5,PC}    ;; return
          CFI EndBlock cfiBlock48

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable46:
        DC32     man_data_work+0x38A4

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable46_1:
        DC32     man_data_work+0x38A8
// 1452 
// 1453 /********************************************************************/
// 1454 /*!
// 1455  * \name	man_data_set_nmea_fix
// 1456  * \brief	fixしたnmea情報を設定する処理
// 1457  * \param	data   : 設定するfixしたNMEAデータ
// 1458  *          length : NMEAデータ長
// 1459  * \return  なし
// 1460  * \note	必要時に呼ばれること
// 1461  */
// 1462 /********************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock49 Using cfiCommon0
          CFI Function man_data_set_nmea_fix
        THUMB
// 1463 void man_data_set_nmea_fix( uint8_t *data, int32_t length )
// 1464 { 
man_data_set_nmea_fix:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        MOVS     R4,R1
// 1465 	if (length < GPS_NMEA_DATA_MAX) {
        MOVS     R1,#+175
        LSLS     R1,R1,#+3        ;; #+1400
        CMP      R4,R1
        BGE      ??man_data_set_nmea_fix_0
// 1466 		memcpy(&man_data_work.sensor_info.nmea_fix[0], data, length);
        LDR      R5,??DataTable57_6
        MOVS     R2,R4
        MOVS     R1,R0
        MOVS     R0,R5
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
// 1467 		man_data_work.sensor_info.nmea_fix_len = length;
        LDR      R0,??DataTable57_7
        STR      R4,[R0, #+0]
// 1468 		
// 1469 		// NMEAと関連するセンサ情報を保存する
// 1470 		man_data_work.sensor_info.nmea_sensor.gyro		 = man_data_work.sensor_info.gyro;
        LDR      R0,??DataTable57_8
        LDR      R1,??DataTable57_9
        MOVS     R2,#+72
          CFI FunCall __aeabi_memcpy4
        BL       __aeabi_memcpy4
// 1471 		man_data_work.sensor_info.nmea_sensor.pressure	 = man_data_work.sensor_info.pressure;
        LDR      R0,??DataTable57_10
        LDR      R0,[R0, #+0]
        LDR      R1,??DataTable57_11
        STR      R0,[R1, #+0]
// 1472 		man_data_work.sensor_info.nmea_sensor.altitude	 = man_data_work.sensor_info.altitude;
        LDR      R0,??DataTable57_12
        LDR      R0,[R0, #+0]
        LDR      R1,??DataTable57_13
        STR      R0,[R1, #+0]
// 1473 		man_data_work.sensor_info.nmea_sensor.rsrp		 = man_data_work.sensor_info.rsrp;
        LDR      R0,??DataTable57_14
        LDR      R0,[R0, #+0]
        LDR      R1,??DataTable57_15
        STR      R0,[R1, #+0]
// 1474 		man_data_work.sensor_info.nmea_sensor.rssi		 = man_data_work.sensor_info.rssi;
        LDR      R0,??DataTable57_16
        LDR      R0,[R0, #+0]
        LDR      R1,??DataTable57_17
        STR      R0,[R1, #+0]
// 1475 	}
// 1476 }
??man_data_set_nmea_fix_0:
        POP      {R0,R4,R5,PC}    ;; return
          CFI EndBlock cfiBlock49

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable47:
        DC32     man_data_work+0x388C
// 1477 
// 1478 /********************************************************************/
// 1479 /*!
// 1480  * \name	man_data_set_SIM7500_cfotaswitch
// 1481  * \brief	SIM7500　at+cfotaswitch発行有無を設定する処理
// 1482 * \param	flag : 0-コマンド発行　1-コマンド発行しない　"AT"を発行
// 1483  * \return  なし
// 1484  * \note	必要時に呼ばれること
// 1485  */
// 1486 /********************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock50 Using cfiCommon0
          CFI Function man_data_set_SIM7500_cfotaswitch
          CFI NoCalls
        THUMB
// 1487 void man_data_set_SIM7500_cfotaswitch(int8_t flag, int8_t retry)
// 1488 {
// 1489   man_data_work.setting_info.other_num.SIM7500_config.cfotaswitch_flag  = flag;
man_data_set_SIM7500_cfotaswitch:
        LDR      R2,??DataTable57_18
        STRB     R0,[R2, #+0]
// 1490   man_data_work.setting_info.other_num.SIM7500_config.cfotaswitch_retry = retry;
        LDR      R0,??DataTable57_19
        STRB     R1,[R0, #+0]
// 1491 }
        BX       LR               ;; return
          CFI EndBlock cfiBlock50
// 1492 
// 1493 /********************************************************************/
// 1494 /*!
// 1495  * \name	man_data_set_SIM7500_cfotaswitch
// 1496  * \brief	SIM7500　at+cfotaswitch発行有無設定を取得する処理
// 1497 * \param	flag : 0-コマンド発行　1-コマンド発行しない　"AT"を発行
// 1498  * \return  なし
// 1499  * \note	必要時に呼ばれること
// 1500  */
// 1501 /********************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock51 Using cfiCommon0
          CFI Function man_data_get_SIM7500_cfotaswitch
          CFI NoCalls
        THUMB
// 1502 void man_data_get_SIM7500_cfotaswitch(int8_t *flag, int8_t *retry)
// 1503 {
// 1504   *flag = man_data_work.setting_info.other_num.SIM7500_config.cfotaswitch_flag;
man_data_get_SIM7500_cfotaswitch:
        LDR      R2,??DataTable57_18
        LDRB     R2,[R2, #+0]
        STRB     R2,[R0, #+0]
// 1505   *retry = man_data_work.setting_info.other_num.SIM7500_config.cfotaswitch_retry;
        LDR      R0,??DataTable57_19
        LDRB     R0,[R0, #+0]
        STRB     R0,[R1, #+0]
// 1506 }
        BX       LR               ;; return
          CFI EndBlock cfiBlock51

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable49:
        DC32     man_data_work+0x2C90
// 1507 
// 1508 /********************************************************************/
// 1509 /*!
// 1510  * \name	man_data_set_SIM7500_cfotaswitch
// 1511  * \brief	SIM7500　at+cfotaswitch発行有無設定を取得する処理
// 1512 * \param	flag : 0-コマンド発行　1-コマンド発行しない　"AT"を発行
// 1513  * \return  なし
// 1514  * \note	必要時に呼ばれること
// 1515  */
// 1516 /********************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock52 Using cfiCommon0
          CFI Function man_data_set_SIM7500_debug_flag
          CFI NoCalls
        THUMB
// 1517 void man_data_set_SIM7500_debug_flag(uint32_t flag)
// 1518 {
// 1519  man_data_work.setting_info.other_num.SIM7500_config.debug_flag=flag;
man_data_set_SIM7500_debug_flag:
        LDR      R1,??DataTable57_20
        STR      R0,[R1, #+0]
// 1520 }
        BX       LR               ;; return
          CFI EndBlock cfiBlock52
// 1521 
// 1522 /********************************************************************/
// 1523 /*!
// 1524  * \name	man_data_get_SIM7500_cfotaswitch
// 1525  * \brief	SIM7500　at+cfotaswitch発行有無設定を取得する処理
// 1526 * \param	flag : 0-コマンド発行　1-コマンド発行しない　"AT"を発行
// 1527  * \return  なし
// 1528  * \note	必要時に呼ばれること
// 1529  */
// 1530 /********************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock53 Using cfiCommon0
          CFI Function man_data_get_SIM7500_debug_flag
          CFI NoCalls
        THUMB
// 1531 uint32_t man_data_get_SIM7500_debug_flag()
// 1532 {
// 1533   return man_data_work.setting_info.other_num.SIM7500_config.debug_flag;
man_data_get_SIM7500_debug_flag:
        LDR      R0,??DataTable57_20
        LDR      R0,[R0, #+0]
        BX       LR               ;; return
// 1534 }
          CFI EndBlock cfiBlock53

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable51:
        DC32     tmp_tbl

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable51_1:
        DC32     0xbdc
// 1535 
// 1536 /********************************************************************/
// 1537 /*!
// 1538  * \name	man_data_config_update
// 1539 * \brief	rJ103でフラッシュ領域上の設定領域で拡張された部分を初期化するコマンド
// 1540 * \param	なし
// 1541  * \return  なし
// 1542  * \note	必要時に呼ばれること
// 1543  */
// 1544 /********************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock54 Using cfiCommon0
          CFI Function man_data_set_default_vals_to_extended_area
        THUMB
// 1545 void man_data_set_default_vals_to_extended_area()
// 1546 {
man_data_set_default_vals_to_extended_area:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
// 1547   man_data_work.setting_info.other_num.alarm_transfer_time  = factory_tbl.other_num.alarm_transfer_time;
        LDR      R0,??DataTable57_21
        LDR      R0,[R0, #+0]
        LDR      R1,??DataTable57_22
        STR      R0,[R1, #+0]
// 1548   memset(&man_data_work.setting_info.other_num.SIM7500_config,0,sizeof(man_data_SIM7500_config_t));
        MOVS     R1,#+8
        MOVS     R2,#+0
        LDR      R4,??DataTable57_20
        MOVS     R0,R4
          CFI FunCall __aeabi_memset
        BL       __aeabi_memset
// 1549   memset(&man_data_work.setting_info.debug_num,0,sizeof(man_data_num_debug_t));
        MOVS     R1,#+16
        MOVS     R2,#+0
        LDR      R4,??DataTable57_23
        MOVS     R0,R4
          CFI FunCall __aeabi_memset
        BL       __aeabi_memset
// 1550   memset(man_data_work.setting_info.reserved,0,MAN_DATA_SETTING_T_RESERVED_SIZE);
        MOVS     R1,#+240
        MOVS     R2,#+0
        LDR      R4,??DataTable57_24
        MOVS     R0,R4
          CFI FunCall __aeabi_memset
        BL       __aeabi_memset
// 1551 }
        POP      {R4,PC}          ;; return
          CFI EndBlock cfiBlock54
// 1552 
// 1553 /********************************************************************/
// 1554 /*!
// 1555  * \name	man_data_set_gnss_no_fix_wait_time
// 1556  * \brief	GNSSがFIXしていないときの待機時間設定処理
// 1557 * \param	時間
// 1558  * \return  なし
// 1559  * \note	必要時に呼ばれること
// 1560  */
// 1561 /********************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock55 Using cfiCommon0
          CFI Function man_data_set_gnss_no_fix_pos_time
          CFI NoCalls
        THUMB
// 1562 void man_data_set_gnss_no_fix_pos_time(uint32_t time)
// 1563 {
// 1564  man_data_work.setting_info.debug_num.gnss_no_fix_post_time=time;
man_data_set_gnss_no_fix_pos_time:
        LDR      R1,??DataTable57_23
        STR      R0,[R1, #+0]
// 1565 }
        BX       LR               ;; return
          CFI EndBlock cfiBlock55

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable53:
        DC32     0xbcc
// 1566 
// 1567 /********************************************************************/
// 1568 /*!
// 1569  * \name	man_data_set_gnss_no_fix_wait_time
// 1570  * \brief	GNSSがFIXしていないときの待機時間を取得する処理
// 1571 * \param	なし
// 1572  * \return  時間
// 1573  * \note	必要時に呼ばれること
// 1574  */
// 1575 /********************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock56 Using cfiCommon0
          CFI Function man_data_get_gnss_no_fix_pos_time
          CFI NoCalls
        THUMB
// 1576 uint32_t man_data_get_gnss_no_fix_pos_time()
// 1577 {
// 1578   return man_data_work.setting_info.debug_num.gnss_no_fix_post_time;
man_data_get_gnss_no_fix_pos_time:
        LDR      R0,??DataTable57_23
        LDR      R0,[R0, #+0]
        BX       LR               ;; return
// 1579 }
          CFI EndBlock cfiBlock56

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable54:
        DC32     0xbc8

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable54_1:
        DC32     0xbd4
// 1580 
// 1581 
// 1582 /********************************************************************/
// 1583 /*!
// 1584  * \name	man_data_set_rssi_sts
// 1585  * \brief	電波状況(圏内/圏外)を設定する処理
// 1586  * \param	rssi_sts   : 電波状況(圏内/圏外)
// 1587  * \return  なし
// 1588  * \note	必要時に呼ばれること
// 1589  */
// 1590 /********************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock57 Using cfiCommon0
          CFI Function man_data_set_rssi_sts
        THUMB
// 1591 void man_data_set_rssi_sts( man_data_rssi_sts_def rssi_sts )
// 1592 {
man_data_set_rssi_sts:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
// 1593 	if (man_data_work.sensor_info.rssi_sts != rssi_sts) {
        LDR      R1,??DataTable57_25
        LDRB     R1,[R1, #+0]
        MOVS     R2,R0
        UXTB     R2,R2
        CMP      R1,R2
        BEQ      ??man_data_set_rssi_sts_0
// 1594 		man_data_work.sensor_info.rssi_sts = rssi_sts;
        LDR      R1,??DataTable57_25
        STRB     R0,[R1, #+0]
// 1595 
// 1596 		// 電波状況を更新する
// 1597 		man_http_get_rsrp(&man_data_work.sensor_info.rsrp, &man_data_work.sensor_info.rssi);
        LDR      R1,??DataTable57_16
        LDR      R0,??DataTable57_14
          CFI FunCall man_http_get_rsrp
        BL       man_http_get_rsrp
// 1598 	}
// 1599 }
??man_data_set_rssi_sts_0:
        POP      {R0,PC}          ;; return
          CFI EndBlock cfiBlock57

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable55:
        DC32     0xbd9
// 1600 
// 1601 /********************************************************************/
// 1602 /*!
// 1603  * \name	man_data_get_sensor
// 1604  * \brief	センサ情報のポインタを返す処理
// 1605  * \param	なし
// 1606  * \return  なし
// 1607  * \note	読み出し専用で使用すること
// 1608  */
// 1609 /********************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock58 Using cfiCommon0
          CFI Function man_data_get_sensor
          CFI NoCalls
        THUMB
// 1610 man_data_get_sensor_t *man_data_get_sensor( void )
// 1611 {
// 1612 	return &man_data_work.sensor_info;
man_data_get_sensor:
        LDR      R0,??DataTable57_26
        BX       LR               ;; return
// 1613 }
          CFI EndBlock cfiBlock58

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable56:
        DC32     0xf424

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable56_1:
        DC32     0xba4

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable56_2:
        DC32     0xba8

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable56_3:
        DC32     man_data_work+0x387C
// 1614 
// 1615 
// 1616 /********************************************************************/
// 1617 /*!
// 1618  * \name	man_data_disp_info
// 1619  * \brief	データ管理情報を表示する処理
// 1620  * \param	なし
// 1621  * \return  なし
// 1622  * \note	必要時に、呼ばれること
// 1623  */
// 1624 /********************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock59 Using cfiCommon0
          CFI Function man_data_disp_info
        THUMB
// 1625 void man_data_disp_info( void )
// 1626 {
man_data_disp_info:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
        SUB      SP,SP,#+8
          CFI CFA R13+24
// 1627 	int32_t					length;
// 1628 	man_data_get_other_t	*other = man_data_get_other();
          CFI FunCall man_data_get_other
        BL       man_data_get_other
        MOVS     R5,R0
// 1629 	man_data_get_sensor_t	*sensor = man_data_get_sensor();
          CFI FunCall man_data_get_sensor
        BL       man_data_get_sensor
        MOVS     R4,R0
// 1630 	uint8_t					*usb_buff = man_memory_alloc();
          CFI FunCall man_memory_alloc
        BL       man_memory_alloc
        MOVS     R6,R0
// 1631 	
// 1632 	sprintf((char *)&usb_buff[0], "DATA INFO :: ip addr=%s, lte ver=%s\n", &other->ipaddr[0], &other->revision[0]);
        MOVS     R3,R5
        ADDS     R3,R3,#+87
        MOVS     R2,R5
        ADDS     R2,R2,#+104
        LDR      R1,??DataTable57_27
        MOVS     R0,R6
          CFI FunCall sprintf
        BL       sprintf
// 1633 	length = strlen((char const *)&usb_buff[0]);
        MOVS     R0,R6
          CFI FunCall strlen
        BL       strlen
// 1634 	man_usb_data_send(&usb_buff[0], length);
        MOVS     R1,R0
        MOVS     R0,R6
          CFI FunCall man_usb_data_send
        BL       man_usb_data_send
// 1635 
// 1636 	sprintf((char *)&usb_buff[0], "SENSOR INFO :: rssi=%d, net=%d, nmea=%d\n", sensor->rssi_sts, sensor->net_mode, sensor->nmea_status);
        LDR      R0,??DataTable57_28  ;; 0xbc8
        LDR      R0,[R4, R0]
        STR      R0,[SP, #+0]
        MOVS     R0,#+189
        LSLS     R0,R0,#+4        ;; #+3024
        LDRB     R3,[R4, R0]
        LDR      R0,??DataTable57_29  ;; 0xbd8
        LDRB     R2,[R4, R0]
        LDR      R1,??DataTable57_30
        MOVS     R0,R6
          CFI FunCall sprintf
        BL       sprintf
// 1637 	length = strlen((char const *)&usb_buff[0]);
        MOVS     R0,R6
          CFI FunCall strlen
        BL       strlen
// 1638 	man_usb_data_send(&usb_buff[0], length);
        MOVS     R1,R0
        MOVS     R0,R6
          CFI FunCall man_usb_data_send
        BL       man_usb_data_send
// 1639 	
// 1640 
// 1641 
// 1642 }
        POP      {R0,R1,R4-R6,PC}  ;; return
          CFI EndBlock cfiBlock59

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable57:
        DC32     man_data_work+0x3874

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable57_1:
        DC32     man_data_work+0x3880

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable57_2:
        DC32     man_data_work+0x3888

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable57_3:
        DC32     man_data_work+0x3884

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable57_4:
        DC32     man_data_work+0x2D08

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable57_5:
        DC32     man_data_work+0x3280

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable57_6:
        DC32     man_data_work+0x3284

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable57_7:
        DC32     man_data_work+0x37FC

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable57_8:
        DC32     man_data_work+0x3800

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable57_9:
        DC32     man_data_work+0x2C9C

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable57_10:
        DC32     man_data_work+0x2CEC

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable57_11:
        DC32     man_data_work+0x3848

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable57_12:
        DC32     man_data_work+0x2CF0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable57_13:
        DC32     man_data_work+0x384C

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable57_14:
        DC32     man_data_work+0x386C

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable57_15:
        DC32     man_data_work+0x3850

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable57_16:
        DC32     man_data_work+0x3870

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable57_17:
        DC32     man_data_work+0x3854

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable57_18:
        DC32     man_data_work+0x2B8C

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable57_19:
        DC32     man_data_work+0x2B8D

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable57_20:
        DC32     man_data_work+0x2B88

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable57_21:
        DC32     factory_tbl+0xD4

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable57_22:
        DC32     man_data_work+0x2B84

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable57_23:
        DC32     man_data_work+0x2B90

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable57_24:
        DC32     man_data_work+0x2BA0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable57_25:
        DC32     man_data_work+0x3868

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable57_26:
        DC32     man_data_work+0x2C90

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable57_27:
        DC32     ?_0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable57_28:
        DC32     0xbc8

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable57_29:
        DC32     0xbd8

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable57_30:
        DC32     ?_1

        SECTION `.iar_vfe_header`:DATA:NOALLOC:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
        DC32 0

        SECTION APL_PRG_BLOCK:DATA:REORDER:NOROOT(0)
        SECTION_TYPE SHT_PROGBITS, 0

        SECTION __DLIB_PERTHREAD:DATA:REORDER:NOROOT(0)
        SECTION_TYPE SHT_PROGBITS, 0

        SECTION __DLIB_PERTHREAD_init:DATA:REORDER:NOROOT(0)
        SECTION_TYPE SHT_PROGBITS, 0

        END
// 
// 14 508 bytes in section .bss
//     36 bytes in section .data
//    744 bytes in section .rodata
//  2 562 bytes in section .text
// 
//  2 562 bytes of CODE  memory
//    744 bytes of CONST memory
// 14 544 bytes of DATA  memory
//
//Errors: none
//Warnings: none
