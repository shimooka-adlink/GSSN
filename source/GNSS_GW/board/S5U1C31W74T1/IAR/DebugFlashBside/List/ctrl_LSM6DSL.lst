###############################################################################
#
# IAR ANSI C/C++ Compiler V7.80.4.12462/W32 for ARM       21/May/2019  17:01:17
# Copyright 1999-2017 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  C:\GNSS\Software\rJ105\source\GNSS_GW\hal\ctrl_LSM6DSL.c
#    Command line =  
#        C:\GNSS\Software\rJ105\source\GNSS_GW\hal\ctrl_LSM6DSL.c -D
#        __TARGET_ARCH_7_M -D S1C31W74 -D GNSS_GW_SIDE_B -lCN
#        C:\GNSS\Software\rJ105\source\GNSS_GW\board\S5U1C31W74T1\IAR\DebugFlashBside\List
#        -lA
#        C:\GNSS\Software\rJ105\source\GNSS_GW\board\S5U1C31W74T1\IAR\DebugFlashBside\List
#        --diag_suppress Pe177,Pe111,Pa082 -o
#        C:\GNSS\Software\rJ105\source\GNSS_GW\board\S5U1C31W74T1\IAR\DebugFlashBside\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M0+ -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.5\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\GNSS\Software\rJ105\source\GNSS_GW\board\S5U1C31W74T1\IAR\ -I
#        C:\GNSS\Software\rJ105\source\GNSS_GW\board\S5U1C31W74T1\IAR\..\..\..\
#        -I "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.5\arm\CMSIS\Include\" -I "C:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 7.5\arm\inc\Epson\" -I
#        C:\GNSS\Software\rJ105\source\GNSS_GW\board\S5U1C31W74T1\IAR\..\..\..\..\..\CMSIS\Device\S1C31W74\Include\
#        -I
#        C:\GNSS\Software\rJ105\source\GNSS_GW\board\S5U1C31W74T1\IAR\..\..\..\..\..\CMSIS\Driver\Include\
#        -I
#        C:\GNSS\Software\rJ105\source\GNSS_GW\board\S5U1C31W74T1\IAR\..\..\..\..\..\sePeriphLibrary\
#        -I
#        C:\GNSS\Software\rJ105\source\GNSS_GW\board\S5U1C31W74T1\IAR\..\..\..\..\..\board\S5U1C31W74T1\
#        -I
#        C:\GNSS\Software\rJ105\source\GNSS_GW\board\S5U1C31W74T1\IAR\..\..\..\..\..\USBStack\INC\
#        -I
#        C:\GNSS\Software\rJ105\source\GNSS_GW\board\S5U1C31W74T1\IAR\..\..\..\include\
#        -Ol
#    Locale       =  Japanese_Japan.932
#    List file    =  
#        C:\GNSS\Software\rJ105\source\GNSS_GW\board\S5U1C31W74T1\IAR\DebugFlashBside\List\ctrl_LSM6DSL.lst
#    Object file  =  
#        C:\GNSS\Software\rJ105\source\GNSS_GW\board\S5U1C31W74T1\IAR\DebugFlashBside\Obj\ctrl_LSM6DSL.o
#
###############################################################################

C:\GNSS\Software\rJ105\source\GNSS_GW\hal\ctrl_LSM6DSL.c
      1          /**
      2            ******************************************************************************
      3            * @file    ctrl_LSM6DSL.c
      4            * @author  コア
      5            * @version V1.0
      6            * @date    2017.10.2
      7            * @brief   このファイルはI2C CH1を使用してデバイス(LSM6DSL)を制御するソフトウェアです。
      8            ******************************************************************************
      9            $Id: ctrl_LSM6DSL.c 182 2018-05-25 04:55:18Z shitaoka $
     10            * @attention
     11            *
     12            *****************************************************************************
     13          */ 
     14          
     15          
     16          #include <string.h>
     17          #include <stdio.h>
     18          #include <stdlib.h>
     19          #include "board.h"
     20          #include "drv_i2c_0.h"
     21          
     22          #pragma section = "CTRL_PRG_BLOCK"
     23          
     24          
     25          /************************************************************************/
     26          /* declaration of structure                                             */
     27          /************************************************************************/
     28          
     29          
     30          #define	CTRL_LSM6DSL_RETRY	(1+1)		// リトライ回数  1回
     31          
     32          #define	CTRL_LSM6DSL_STS_GDA_MASK		0x02		// 新しい角速度取得
     33          #define	CTRL_LSM6DSL_STS_XLDA_MASK		0x01		// 新しい加速度取得
     34          
     35          
     36          
     37          /************************************************************************/
     38          /* definition of variables                                              */
     39          /************************************************************************/
     40          

   \                                 In section .data, align 1
     41          static uint8_t slave_addr = 0x6a;
   \                     slave_addr:
   \   00000000   0x6A               DC8 106
     42          
     43          /********************************************************************/
     44          /*	static関数                                                      */
     45          /********************************************************************/
     46          
     47          
     48          /********************************************************************/
     49          /*!
     50           * \name	LSM6DSL_ctrl1_standby
     51           * \brief	加速度センサスタンバイ処理
     52           * \return   0: 成功
     53           *          -1:失敗
     54           * \note	CTRL1_XL(10h) 
     55           *			  ODR_XL[3:0] = 0000  : パワーダウン
     56           *			  FS_XL[1:0]  = 00    : 加速度計のフルスケール選択(±2 g)
     57           *			  LPF1_BW_SEL = 0     : 帯域幅(ODR/2)
     58           */
     59          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
     60          static int32_t LSM6DSL_ctrl1_standby(void)
     61          {
   \                     LSM6DSL_ctrl1_standby: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
     62          	int32_t	status=0;
   \   00000004   0x2000             MOVS     R0,#+0
     63          	uint8_t cmd[] = {0x10, 0x00};
   \   00000006   0x4669             MOV      R1,SP
   \   00000008   0x....             LDR      R2,??DataTable6
   \   0000000A   0x8813             LDRH     R3,[R2, #0]
   \   0000000C   0x800B             STRH     R3,[R1, #0]
     64          	int32_t	i;
     65          	
     66          	for (i=0; i<CTRL_LSM6DSL_RETRY; i++) {
   \   0000000E   0x2400             MOVS     R4,#+0
   \   00000010   0xE000             B        ??LSM6DSL_ctrl1_standby_0
   \                     ??LSM6DSL_ctrl1_standby_1: (+1)
   \   00000012   0x1C64             ADDS     R4,R4,#+1
   \                     ??LSM6DSL_ctrl1_standby_0: (+1)
   \   00000014   0x2C02             CMP      R4,#+2
   \   00000016   0xDA0C             BGE      ??LSM6DSL_ctrl1_standby_2
     67          		seSysSleepMS(5);
   \   00000018   0x2005             MOVS     R0,#+5
   \   0000001A   0x.... 0x....      BL       seSysSleepMS
     68          		status = i2c0_SendData(slave_addr, &cmd[0], 2, seDISABLE);
   \   0000001E   0x2300             MOVS     R3,#+0
   \   00000020   0x2202             MOVS     R2,#+2
   \   00000022   0x4669             MOV      R1,SP
   \   00000024   0x....             LDR      R0,??DataTable6_1
   \   00000026   0x7800             LDRB     R0,[R0, #+0]
   \   00000028   0xB280             UXTH     R0,R0
   \   0000002A   0x.... 0x....      BL       i2c0_SendData
     69          		if (status == 0) break;
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD1EF             BNE      ??LSM6DSL_ctrl1_standby_1
     70          	}
     71          	return status;
   \                     ??LSM6DSL_ctrl1_standby_2: (+1)
   \   00000032   0xBD16             POP      {R1,R2,R4,PC}    ;; return
     72          }
     73          
     74          /********************************************************************/
     75          /*!
     76           * \name	LSM6DSL_ctrl2_standby
     77           * \brief	角速度センサスタンバイ処理
     78           * \return   0: 成功
     79           *          -1:失敗
     80           * \note	CTRL1_XL(10h) 
     81           *			  ODR_G[3:0]  = 0000  : ジャイロスコープ出力データレート選択 : パワーダウン
     82           *			  FS_G[1:0]   = 00    : ジャイロスコープのフルスケール選択(245 dps)
     83           *			  FS_125      = 0     : 125 dpsフルスケールのジャイロスコープ デフォルト値(無効)
     84           */
     85          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
     86          static int32_t LSM6DSL_ctrl2_standby(void)
     87          {
   \                     LSM6DSL_ctrl2_standby: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
     88          	int32_t	status=0;
   \   00000004   0x2000             MOVS     R0,#+0
     89          	uint8_t cmd[] = {0x11, 0x00};
   \   00000006   0x4669             MOV      R1,SP
   \   00000008   0x....             LDR      R2,??DataTable6_2
   \   0000000A   0x8813             LDRH     R3,[R2, #0]
   \   0000000C   0x800B             STRH     R3,[R1, #0]
     90          	int32_t	i;
     91          	
     92          	for (i=0; i<CTRL_LSM6DSL_RETRY; i++) {
   \   0000000E   0x2400             MOVS     R4,#+0
   \   00000010   0xE000             B        ??LSM6DSL_ctrl2_standby_0
   \                     ??LSM6DSL_ctrl2_standby_1: (+1)
   \   00000012   0x1C64             ADDS     R4,R4,#+1
   \                     ??LSM6DSL_ctrl2_standby_0: (+1)
   \   00000014   0x2C02             CMP      R4,#+2
   \   00000016   0xDA0C             BGE      ??LSM6DSL_ctrl2_standby_2
     93          		seSysSleepMS(5);
   \   00000018   0x2005             MOVS     R0,#+5
   \   0000001A   0x.... 0x....      BL       seSysSleepMS
     94          		status = i2c0_SendData(slave_addr, &cmd[0], 2, seDISABLE);
   \   0000001E   0x2300             MOVS     R3,#+0
   \   00000020   0x2202             MOVS     R2,#+2
   \   00000022   0x4669             MOV      R1,SP
   \   00000024   0x....             LDR      R0,??DataTable6_1
   \   00000026   0x7800             LDRB     R0,[R0, #+0]
   \   00000028   0xB280             UXTH     R0,R0
   \   0000002A   0x.... 0x....      BL       i2c0_SendData
     95          		if (status == 0) break;
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD1EF             BNE      ??LSM6DSL_ctrl2_standby_1
     96          	}
     97          	return status;
   \                     ??LSM6DSL_ctrl2_standby_2: (+1)
   \   00000032   0xBD16             POP      {R1,R2,R4,PC}    ;; return
     98          }
     99          
    100          /********************************************************************/
    101          /*!
    102           * \name	LSM6DSL_ctrl1
    103           * \brief	加速度センサ設定処理
    104           * \return   0: 成功
    105           *          -1:失敗
    106           * \note	CTRL1_XL(10h) 
    107           *			  ODR_XL[3:0] = 0010  : 出力データレートとパワーモードの選択 : 26 Hz (high performance) 38ms
    108           *			  FS_XL[1:0]  = 11    : 加速度計のフルスケール選択(±8G)
    109           *			  LPF1_BW_SEL = 0     : 帯域幅(ODR/2)
    110           */
    111          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    112          static int32_t LSM6DSL_ctrl1(void)
    113          {
   \                     LSM6DSL_ctrl1: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
    114          	int32_t	status=0;
   \   00000004   0x2000             MOVS     R0,#+0
    115          	uint8_t cmd[] = {0x10, 0x2c};
   \   00000006   0x4669             MOV      R1,SP
   \   00000008   0x....             LDR      R2,??DataTable6_3
   \   0000000A   0x8813             LDRH     R3,[R2, #0]
   \   0000000C   0x800B             STRH     R3,[R1, #0]
    116          	int32_t	i;
    117          	
    118          	for (i=0; i<CTRL_LSM6DSL_RETRY; i++) {
   \   0000000E   0x2400             MOVS     R4,#+0
   \   00000010   0xE000             B        ??LSM6DSL_ctrl1_0
   \                     ??LSM6DSL_ctrl1_1: (+1)
   \   00000012   0x1C64             ADDS     R4,R4,#+1
   \                     ??LSM6DSL_ctrl1_0: (+1)
   \   00000014   0x2C02             CMP      R4,#+2
   \   00000016   0xDA0C             BGE      ??LSM6DSL_ctrl1_2
    119          		seSysSleepMS(5);
   \   00000018   0x2005             MOVS     R0,#+5
   \   0000001A   0x.... 0x....      BL       seSysSleepMS
    120          		status = i2c0_SendData(slave_addr, &cmd[0], 2, seDISABLE);
   \   0000001E   0x2300             MOVS     R3,#+0
   \   00000020   0x2202             MOVS     R2,#+2
   \   00000022   0x4669             MOV      R1,SP
   \   00000024   0x....             LDR      R0,??DataTable6_1
   \   00000026   0x7800             LDRB     R0,[R0, #+0]
   \   00000028   0xB280             UXTH     R0,R0
   \   0000002A   0x.... 0x....      BL       i2c0_SendData
    121          		if (status == 0) break;
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD1EF             BNE      ??LSM6DSL_ctrl1_1
    122          	}
    123          	return status;
   \                     ??LSM6DSL_ctrl1_2: (+1)
   \   00000032   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    124          }
    125          
    126          
    127          /********************************************************************/
    128          /*!
    129           * \name	LSM6DSL_ctrl2
    130           * \brief	角速度センサ設定処理
    131           * \return   0: 成功
    132           *          -1:失敗
    133           * \note	CTRL1_XL(10h) 
    134           *			  ODR_G[3:0]  = 0010  : ジャイロスコープ出力データレート選択 : 26 Hz (high performance) 38ms
    135           *			  FS_G[1:0]   = 11    : ジャイロスコープのフルスケール選択(2000 dps)
    136           *			  FS_125      = 0     : 125 dpsフルスケールのジャイロスコープ デフォルト値(無効)
    137           */
    138          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    139          static int32_t LSM6DSL_ctrl2(void)
    140          {
   \                     LSM6DSL_ctrl2: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
    141          	int32_t	status=0;
   \   00000004   0x2000             MOVS     R0,#+0
    142          	uint8_t cmd[] = {0x11, 0x2c};
   \   00000006   0x4669             MOV      R1,SP
   \   00000008   0x....             LDR      R2,??DataTable6_4
   \   0000000A   0x8813             LDRH     R3,[R2, #0]
   \   0000000C   0x800B             STRH     R3,[R1, #0]
    143          	int32_t	i;
    144          	
    145          	for (i=0; i<CTRL_LSM6DSL_RETRY; i++) {
   \   0000000E   0x2400             MOVS     R4,#+0
   \   00000010   0xE000             B        ??LSM6DSL_ctrl2_0
   \                     ??LSM6DSL_ctrl2_1: (+1)
   \   00000012   0x1C64             ADDS     R4,R4,#+1
   \                     ??LSM6DSL_ctrl2_0: (+1)
   \   00000014   0x2C02             CMP      R4,#+2
   \   00000016   0xDA0C             BGE      ??LSM6DSL_ctrl2_2
    146          		seSysSleepMS(5);
   \   00000018   0x2005             MOVS     R0,#+5
   \   0000001A   0x.... 0x....      BL       seSysSleepMS
    147          		status = i2c0_SendData(slave_addr, &cmd[0], 2, seDISABLE);
   \   0000001E   0x2300             MOVS     R3,#+0
   \   00000020   0x2202             MOVS     R2,#+2
   \   00000022   0x4669             MOV      R1,SP
   \   00000024   0x....             LDR      R0,??DataTable6_1
   \   00000026   0x7800             LDRB     R0,[R0, #+0]
   \   00000028   0xB280             UXTH     R0,R0
   \   0000002A   0x.... 0x....      BL       i2c0_SendData
    148          		if (status == 0) break;
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD1EF             BNE      ??LSM6DSL_ctrl2_1
    149          	}
    150          	return status;
   \                     ??LSM6DSL_ctrl2_2: (+1)
   \   00000032   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    151          }
    152          
    153          
    154          /********************************************************************/
    155          /*!
    156           * \name	LSM6DSL_int1_ctrl
    157           * \brief	信号がINT1を介して伝送
    158           * \return   0: 成功
    159           *          -1:失敗
    160           * \note	INT1_CTRL(0Dh) 
    161           *            INT1_STEP_DETECTOR  = 0 : 
    162           *            INT1_SIGN_MOT       = 0 :
    163           *            INT1_FULL_FLAG      = 0 :
    164           *            INT1_FIFO_OVR       = 0 :
    165           *            INT1_FTH            = 0 :
    166           *            INT1_BOOT           = 0 :
    167           *            INT1_DRDY_G         = 1 : ジャイロスコープのデータ準備完了をINT1に割り当てる
    168           *            INT1_DRDY_XL        = 1 : 加速度計データ準備完了をINT1に割り当てる
    169           */
    170          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    171          static int32_t LSM6DSL_int1_ctrl(void)
    172          {
   \                     LSM6DSL_int1_ctrl: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
    173          	int32_t	status=0;
   \   00000004   0x2000             MOVS     R0,#+0
    174          	uint8_t cmd[] = {0x0D, 0x03};
   \   00000006   0x4669             MOV      R1,SP
   \   00000008   0x....             LDR      R2,??DataTable6_5
   \   0000000A   0x8813             LDRH     R3,[R2, #0]
   \   0000000C   0x800B             STRH     R3,[R1, #0]
    175          	int32_t	i;
    176          	
    177          	for (i=0; i<CTRL_LSM6DSL_RETRY; i++) {
   \   0000000E   0x2400             MOVS     R4,#+0
   \   00000010   0xE000             B        ??LSM6DSL_int1_ctrl_0
   \                     ??LSM6DSL_int1_ctrl_1: (+1)
   \   00000012   0x1C64             ADDS     R4,R4,#+1
   \                     ??LSM6DSL_int1_ctrl_0: (+1)
   \   00000014   0x2C02             CMP      R4,#+2
   \   00000016   0xDA0C             BGE      ??LSM6DSL_int1_ctrl_2
    178          		seSysSleepMS(5);
   \   00000018   0x2005             MOVS     R0,#+5
   \   0000001A   0x.... 0x....      BL       seSysSleepMS
    179          		status = i2c0_SendData(slave_addr, &cmd[0], 2, seDISABLE);
   \   0000001E   0x2300             MOVS     R3,#+0
   \   00000020   0x2202             MOVS     R2,#+2
   \   00000022   0x4669             MOV      R1,SP
   \   00000024   0x....             LDR      R0,??DataTable6_1
   \   00000026   0x7800             LDRB     R0,[R0, #+0]
   \   00000028   0xB280             UXTH     R0,R0
   \   0000002A   0x.... 0x....      BL       i2c0_SendData
    180          		if (status == 0) break;
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD1EF             BNE      ??LSM6DSL_int1_ctrl_1
    181          	}
    182          	return status;
   \                     ??LSM6DSL_int1_ctrl_2: (+1)
   \   00000032   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    183          }
    184          
    185          
    186          
    187          /********************************************************************/
    188          /*!
    189           * \name	LSM6DSL_read_data_status
    190           * \brief	ステータスレジスタ取得処理
    191           * \param	reg  : 取得したレジスタ値
    192           * \return  0  : 成功
    193           *          -1 : 失敗
    194           * \note	STATUS_REG
    195           *			  GDA(bit1)  : 新しい角速度取得
    196           *			  XLDA(bit0) : 新しい加速度取得
    197           */
    198          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    199          static int32_t LSM6DSL_read_data_status( uint8_t *reg )
    200          {
   \                     LSM6DSL_read_data_status: (+1)
   \   00000000   0xB57F             PUSH     {R0-R6,LR}
   \   00000002   0x0006             MOVS     R6,R0
    201          	uint8_t buf[10] = {0};
   \   00000004   0xA801             ADD      R0,SP,#+4
   \   00000006   0x210C             MOVS     R1,#+12
   \   00000008   0x.... 0x....      BL       __aeabi_memclr4
    202          	int32_t	status;
    203          	int32_t	ret=-1;
   \   0000000C   0x2500             MOVS     R5,#+0
   \   0000000E   0x43ED             MVNS     R5,R5            ;; #-1
    204          	uint8_t cmd[] = {0x1E};			// ステータスレジスタ
   \   00000010   0x4668             MOV      R0,SP
   \   00000012   0x....             LDR      R1,??DataTable6_6
   \   00000014   0x780A             LDRB     R2,[R1, #0]
   \   00000016   0x7002             STRB     R2,[R0, #0]
    205          	int32_t	i;
    206          
    207          
    208          	for (i=0; i<CTRL_LSM6DSL_RETRY; i++) {
   \   00000018   0x2400             MOVS     R4,#+0
   \   0000001A   0xE000             B        ??LSM6DSL_read_data_status_0
   \                     ??LSM6DSL_read_data_status_1: (+1)
   \   0000001C   0x1C64             ADDS     R4,R4,#+1
   \                     ??LSM6DSL_read_data_status_0: (+1)
   \   0000001E   0x2C02             CMP      R4,#+2
   \   00000020   0xDA1A             BGE      ??LSM6DSL_read_data_status_2
    209          		// ステータスレジスタ取得
    210          		seSysSleepMS(5);
   \   00000022   0x2005             MOVS     R0,#+5
   \   00000024   0x.... 0x....      BL       seSysSleepMS
    211          		status = i2c0_SendData(slave_addr, &cmd[0], 1, seENABLE);
   \   00000028   0x2301             MOVS     R3,#+1
   \   0000002A   0x2201             MOVS     R2,#+1
   \   0000002C   0x4669             MOV      R1,SP
   \   0000002E   0x....             LDR      R0,??DataTable6_1
   \   00000030   0x7800             LDRB     R0,[R0, #+0]
   \   00000032   0xB280             UXTH     R0,R0
   \   00000034   0x.... 0x....      BL       i2c0_SendData
    212          		if (status >= 0) {
   \   00000038   0x2800             CMP      R0,#+0
   \   0000003A   0xD4EF             BMI      ??LSM6DSL_read_data_status_1
    213          			status = i2c0_ReceiveData(slave_addr, &buf[0], 1, seDISABLE);
   \   0000003C   0x2300             MOVS     R3,#+0
   \   0000003E   0x2201             MOVS     R2,#+1
   \   00000040   0xA901             ADD      R1,SP,#+4
   \   00000042   0x....             LDR      R0,??DataTable6_1
   \   00000044   0x7800             LDRB     R0,[R0, #+0]
   \   00000046   0xB280             UXTH     R0,R0
   \   00000048   0x.... 0x....      BL       i2c0_ReceiveData
    214          			if (status >= 0) {
   \   0000004C   0x2800             CMP      R0,#+0
   \   0000004E   0xD4E5             BMI      ??LSM6DSL_read_data_status_1
    215          				*reg = buf[0];
   \   00000050   0x4668             MOV      R0,SP
   \   00000052   0x7900             LDRB     R0,[R0, #+4]
   \   00000054   0x7030             STRB     R0,[R6, #+0]
    216          				ret=0;				// 成功
   \   00000056   0x2500             MOVS     R5,#+0
    217          				break;
    218          			}
    219          		}
    220          	}
    221          
    222          	return ret;
   \                     ??LSM6DSL_read_data_status_2: (+1)
   \   00000058   0x0028             MOVS     R0,R5
   \   0000005A   0xB004             ADD      SP,SP,#+16
   \   0000005C   0xBD70             POP      {R4-R6,PC}       ;; return
    223          }
    224          
    225          
    226          
    227          /********************************************************************/
    228          /*	extern関数                                                      */
    229          /********************************************************************/
    230          
    231          /********************************************************************/
    232          /*!
    233           * \name	ctrc_LSM6DSL_start
    234           * \brief	LSM6DSL開始処理
    235           * \return   0: 成功
    236           *          -1:失敗
    237           * \note	なし
    238           */
    239          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    240          int32_t ctrc_LSM6DSL_start(void)
    241          {
   \                     ctrc_LSM6DSL_start: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    242          	int32_t	status;
    243          
    244          	// 加速度センサ初期化
    245          	status = LSM6DSL_ctrl1();
   \   00000002   0x.... 0x....      BL       LSM6DSL_ctrl1
    246          
    247          	// 角速度センサ初期化
    248          	if (status >= 0) {
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD401             BMI      ??ctrc_LSM6DSL_start_0
    249          		status = LSM6DSL_ctrl2();
   \   0000000A   0x.... 0x....      BL       LSM6DSL_ctrl2
    250          	}
    251          
    252          	// 加速度・角速度をiNT1に割付
    253          	if (status >= 0) {
   \                     ??ctrc_LSM6DSL_start_0: (+1)
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD401             BMI      ??ctrc_LSM6DSL_start_1
    254          		status = LSM6DSL_int1_ctrl();
   \   00000012   0x.... 0x....      BL       LSM6DSL_int1_ctrl
    255          	}
    256          
    257          	return status;
   \                     ??ctrc_LSM6DSL_start_1: (+1)
   \   00000016   0xBD02             POP      {R1,PC}          ;; return
    258          }
    259          
    260          
    261          
    262          /********************************************************************/
    263          /*!
    264           * \name	ctrc_LSM6DSL_get_gyro
    265           * \brief	角速度データを取得する
    266           * \param	gyro_x  : 角速度(X軸)
    267           *          gyro_y  : 角速度(Y軸)
    268           *          gyro_z  : 角速度(Z軸)
    269           *          accel_x : 加速度(X軸)
    270           *          accel_y : 加速度(Y軸)
    271           *          accel_z : 加速度(Z軸)
    272           * \return   0: 成功
    273           *          -1: 失敗
    274           * \note	失敗の場合、100ms後に再度呼び出してください
    275           */
    276          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    277          int32_t ctrc_LSM6DSL_get_gyro(int32_t *gyro_x, int32_t *gyro_y, int32_t *gyro_z, int32_t *accel_x, int32_t *accel_y, int32_t *accel_z)
    278          {
   \                     ctrc_LSM6DSL_get_gyro: (+1)
   \   00000000   0xB5F3             PUSH     {R0,R1,R4-R7,LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
   \   00000004   0x0017             MOVS     R7,R2
   \   00000006   0x001E             MOVS     R6,R3
    279          	int32_t		ret=0;
   \   00000008   0x2400             MOVS     R4,#+0
    280          	int32_t		status;
    281          	uint8_t 	buf[16] = {0};
   \   0000000A   0xA801             ADD      R0,SP,#+4
   \   0000000C   0x2110             MOVS     R1,#+16
   \   0000000E   0x.... 0x....      BL       __aeabi_memclr4
    282          	uint8_t 	cmd[] = {0x22};				// 角速度データレジスタ
   \   00000012   0xA800             ADD      R0,SP,#+0
   \   00000014   0x1C40             ADDS     R0,R0,#+1
   \   00000016   0x....             LDR      R1,??DataTable6_7
   \   00000018   0x780A             LDRB     R2,[R1, #0]
   \   0000001A   0x7002             STRB     R2,[R0, #0]
    283          	int32_t		gyro_raw=0;
   \   0000001C   0x2000             MOVS     R0,#+0
    284          	int32_t		accel_raw=0;
   \   0000001E   0x2000             MOVS     R0,#+0
    285          	int32_t		i;
    286          	uint8_t		reg;
    287          
    288          	// 新しいデータセットの準備完了確認
    289          	status = LSM6DSL_read_data_status(&reg);
   \   00000020   0x4668             MOV      R0,SP
   \   00000022   0x.... 0x....      BL       LSM6DSL_read_data_status
    290          
    291          	// 取得成功の場合
    292          	if (status >= 0) {
   \   00000026   0x2800             CMP      R0,#+0
   \   00000028   0xD500             BPL      .+4
   \   0000002A   0xE07E             B        ??ctrc_LSM6DSL_get_gyro_0
    293          
    294          		// 新しい角速度取得済みか？
    295          		if ( ( reg & (CTRL_LSM6DSL_STS_GDA_MASK | CTRL_LSM6DSL_STS_XLDA_MASK) ) == (CTRL_LSM6DSL_STS_GDA_MASK | CTRL_LSM6DSL_STS_XLDA_MASK) ) {
   \   0000002C   0x4668             MOV      R0,SP
   \   0000002E   0x7800             LDRB     R0,[R0, #+0]
   \   00000030   0x0780             LSLS     R0,R0,#+30       ;; ZeroExtS R0,R0,#+30,#+30
   \   00000032   0x0F80             LSRS     R0,R0,#+30
   \   00000034   0x2803             CMP      R0,#+3
   \   00000036   0xD17A             BNE      ??ctrc_LSM6DSL_get_gyro_1
    296          			// 角速度データ取得
    297          			ret = -1;
   \   00000038   0x2400             MOVS     R4,#+0
   \   0000003A   0x43E4             MVNS     R4,R4            ;; #-1
    298          			for (i=0; i<CTRL_LSM6DSL_RETRY; i++) {
   \   0000003C   0x2500             MOVS     R5,#+0
   \   0000003E   0xE000             B        ??ctrc_LSM6DSL_get_gyro_2
   \                     ??ctrc_LSM6DSL_get_gyro_3: (+1)
   \   00000040   0x1C6D             ADDS     R5,R5,#+1
   \                     ??ctrc_LSM6DSL_get_gyro_2: (+1)
   \   00000042   0x2D02             CMP      R5,#+2
   \   00000044   0xDA73             BGE      ??ctrc_LSM6DSL_get_gyro_1
    299          				seSysSleepMS(2);
   \   00000046   0x2002             MOVS     R0,#+2
   \   00000048   0x.... 0x....      BL       seSysSleepMS
    300          				status = i2c0_SendData(slave_addr, &cmd[0], 1, seENABLE);
   \   0000004C   0x2301             MOVS     R3,#+1
   \   0000004E   0x2201             MOVS     R2,#+1
   \   00000050   0xA900             ADD      R1,SP,#+0
   \   00000052   0x1C49             ADDS     R1,R1,#+1
   \   00000054   0x....             LDR      R0,??DataTable6_1
   \   00000056   0x7800             LDRB     R0,[R0, #+0]
   \   00000058   0xB280             UXTH     R0,R0
   \   0000005A   0x.... 0x....      BL       i2c0_SendData
    301          				if (status >= 0) {
   \   0000005E   0x2800             CMP      R0,#+0
   \   00000060   0xD4EE             BMI      ??ctrc_LSM6DSL_get_gyro_3
    302          					status = i2c0_ReceiveData(slave_addr, &buf[0], 12, seDISABLE);
   \   00000062   0x2300             MOVS     R3,#+0
   \   00000064   0x220C             MOVS     R2,#+12
   \   00000066   0xA901             ADD      R1,SP,#+4
   \   00000068   0x....             LDR      R0,??DataTable6_1
   \   0000006A   0x7800             LDRB     R0,[R0, #+0]
   \   0000006C   0xB280             UXTH     R0,R0
   \   0000006E   0x.... 0x....      BL       i2c0_ReceiveData
    303          					if (status >= 0) {
   \   00000072   0x2800             CMP      R0,#+0
   \   00000074   0xD4E4             BMI      ??ctrc_LSM6DSL_get_gyro_3
    304          						// 角速度(X軸)
    305          						gyro_raw = buf[1];
   \   00000076   0xA801             ADD      R0,SP,#+4
   \   00000078   0x7840             LDRB     R0,[R0, #+1]
    306          						gyro_raw <<= 8;
   \   0000007A   0x0200             LSLS     R0,R0,#+8
    307          						gyro_raw |= buf[0];
   \   0000007C   0x0001             MOVS     R1,R0
   \   0000007E   0x4668             MOV      R0,SP
   \   00000080   0x7900             LDRB     R0,[R0, #+4]
   \   00000082   0x4308             ORRS     R0,R0,R1
    308          						if ( (buf[1] & 0x80) != 0 ) {
   \   00000084   0xA901             ADD      R1,SP,#+4
   \   00000086   0x7849             LDRB     R1,[R1, #+1]
   \   00000088   0x0609             LSLS     R1,R1,#+24
   \   0000008A   0xD501             BPL      ??ctrc_LSM6DSL_get_gyro_4
    309          							gyro_raw -= 65536;
   \   0000008C   0x....             LDR      R1,??DataTable6_8  ;; 0xffff0000
   \   0000008E   0x1840             ADDS     R0,R0,R1
    310          						}
    311          						*gyro_x = gyro_raw;
   \                     ??ctrc_LSM6DSL_get_gyro_4: (+1)
   \   00000090   0x9905             LDR      R1,[SP, #+20]
   \   00000092   0x6008             STR      R0,[R1, #+0]
    312          
    313          						// 角速度(Y軸)
    314          						gyro_raw = buf[3];
   \   00000094   0xA801             ADD      R0,SP,#+4
   \   00000096   0x78C0             LDRB     R0,[R0, #+3]
    315          						gyro_raw <<= 8;
   \   00000098   0x0200             LSLS     R0,R0,#+8
    316          						gyro_raw |= buf[2];
   \   0000009A   0x0001             MOVS     R1,R0
   \   0000009C   0xA801             ADD      R0,SP,#+4
   \   0000009E   0x7880             LDRB     R0,[R0, #+2]
   \   000000A0   0x4308             ORRS     R0,R0,R1
    317          						if ( (buf[3] & 0x80) != 0 ) {
   \   000000A2   0xA901             ADD      R1,SP,#+4
   \   000000A4   0x78C9             LDRB     R1,[R1, #+3]
   \   000000A6   0x0609             LSLS     R1,R1,#+24
   \   000000A8   0xD501             BPL      ??ctrc_LSM6DSL_get_gyro_5
    318          							gyro_raw -= 65536;
   \   000000AA   0x....             LDR      R1,??DataTable6_8  ;; 0xffff0000
   \   000000AC   0x1840             ADDS     R0,R0,R1
    319          						}
    320          						*gyro_y = gyro_raw;
   \                     ??ctrc_LSM6DSL_get_gyro_5: (+1)
   \   000000AE   0x9906             LDR      R1,[SP, #+24]
   \   000000B0   0x6008             STR      R0,[R1, #+0]
    321          
    322          						// 角速度(Z軸)
    323          						gyro_raw = buf[5];
   \   000000B2   0xA801             ADD      R0,SP,#+4
   \   000000B4   0x7940             LDRB     R0,[R0, #+5]
    324          						gyro_raw <<= 8;
   \   000000B6   0x0200             LSLS     R0,R0,#+8
    325          						gyro_raw |= buf[4];
   \   000000B8   0x0001             MOVS     R1,R0
   \   000000BA   0xA801             ADD      R0,SP,#+4
   \   000000BC   0x7900             LDRB     R0,[R0, #+4]
   \   000000BE   0x4308             ORRS     R0,R0,R1
    326          						if ( (buf[5] & 0x80) != 0 ) {
   \   000000C0   0xA901             ADD      R1,SP,#+4
   \   000000C2   0x7949             LDRB     R1,[R1, #+5]
   \   000000C4   0x0609             LSLS     R1,R1,#+24
   \   000000C6   0xD501             BPL      ??ctrc_LSM6DSL_get_gyro_6
    327          							gyro_raw -= 65536;
   \   000000C8   0x....             LDR      R1,??DataTable6_8  ;; 0xffff0000
   \   000000CA   0x1840             ADDS     R0,R0,R1
    328          						}
    329          						*gyro_z = gyro_raw;
   \                     ??ctrc_LSM6DSL_get_gyro_6: (+1)
   \   000000CC   0x6038             STR      R0,[R7, #+0]
    330          
    331          						// 加速度(X軸)
    332          						accel_raw = buf[7];
   \   000000CE   0xA801             ADD      R0,SP,#+4
   \   000000D0   0x79C0             LDRB     R0,[R0, #+7]
    333          						accel_raw <<= 8;
   \   000000D2   0x0200             LSLS     R0,R0,#+8
    334          						accel_raw |= buf[6];
   \   000000D4   0x0001             MOVS     R1,R0
   \   000000D6   0xA801             ADD      R0,SP,#+4
   \   000000D8   0x7980             LDRB     R0,[R0, #+6]
   \   000000DA   0x4308             ORRS     R0,R0,R1
    335          						if ( (buf[7] & 0x80) != 0 ) {
   \   000000DC   0xA901             ADD      R1,SP,#+4
   \   000000DE   0x79C9             LDRB     R1,[R1, #+7]
   \   000000E0   0x0609             LSLS     R1,R1,#+24
   \   000000E2   0xD501             BPL      ??ctrc_LSM6DSL_get_gyro_7
    336          							accel_raw -= 65536;
   \   000000E4   0x....             LDR      R1,??DataTable6_8  ;; 0xffff0000
   \   000000E6   0x1840             ADDS     R0,R0,R1
    337          						}
    338          						*accel_x = accel_raw;
   \                     ??ctrc_LSM6DSL_get_gyro_7: (+1)
   \   000000E8   0x6030             STR      R0,[R6, #+0]
    339          
    340          						// 加速度(Y軸)
    341          						accel_raw = buf[9];
   \   000000EA   0xA801             ADD      R0,SP,#+4
   \   000000EC   0x7A40             LDRB     R0,[R0, #+9]
    342          						accel_raw <<= 8;
   \   000000EE   0x0200             LSLS     R0,R0,#+8
    343          						accel_raw |= buf[8];
   \   000000F0   0x0001             MOVS     R1,R0
   \   000000F2   0xA801             ADD      R0,SP,#+4
   \   000000F4   0x7A00             LDRB     R0,[R0, #+8]
   \   000000F6   0x4308             ORRS     R0,R0,R1
    344          						if ( (buf[9] & 0x80) != 0 ) {
   \   000000F8   0xA901             ADD      R1,SP,#+4
   \   000000FA   0x7A49             LDRB     R1,[R1, #+9]
   \   000000FC   0x0609             LSLS     R1,R1,#+24
   \   000000FE   0xD501             BPL      ??ctrc_LSM6DSL_get_gyro_8
    345          							accel_raw -= 65536;
   \   00000100   0x....             LDR      R1,??DataTable6_8  ;; 0xffff0000
   \   00000102   0x1840             ADDS     R0,R0,R1
    346          						}
    347          						*accel_y = accel_raw;
   \                     ??ctrc_LSM6DSL_get_gyro_8: (+1)
   \   00000104   0x990C             LDR      R1,[SP, #+48]
   \   00000106   0x6008             STR      R0,[R1, #+0]
    348          
    349          						// 加速度(Z軸)
    350          						accel_raw = buf[11];
   \   00000108   0xA801             ADD      R0,SP,#+4
   \   0000010A   0x7AC0             LDRB     R0,[R0, #+11]
    351          						accel_raw <<= 8;
   \   0000010C   0x0200             LSLS     R0,R0,#+8
    352          						accel_raw |= buf[10];
   \   0000010E   0x0001             MOVS     R1,R0
   \   00000110   0xA801             ADD      R0,SP,#+4
   \   00000112   0x7A80             LDRB     R0,[R0, #+10]
   \   00000114   0x4308             ORRS     R0,R0,R1
    353          						if ( (buf[11] & 0x80) != 0 ) {
   \   00000116   0xA901             ADD      R1,SP,#+4
   \   00000118   0x7AC9             LDRB     R1,[R1, #+11]
   \   0000011A   0x0609             LSLS     R1,R1,#+24
   \   0000011C   0xD501             BPL      ??ctrc_LSM6DSL_get_gyro_9
    354          							accel_raw -= 65536;
   \   0000011E   0x....             LDR      R1,??DataTable6_8  ;; 0xffff0000
   \   00000120   0x1840             ADDS     R0,R0,R1
    355          						}
    356          						*accel_z = accel_raw;
   \                     ??ctrc_LSM6DSL_get_gyro_9: (+1)
   \   00000122   0x990D             LDR      R1,[SP, #+52]
   \   00000124   0x6008             STR      R0,[R1, #+0]
    357          
    358          						ret = 0;
   \   00000126   0x2400             MOVS     R4,#+0
    359          						break;
   \   00000128   0xE001             B        ??ctrc_LSM6DSL_get_gyro_1
    360          					}
    361          				}
    362          			}
    363          		}
    364          	}
    365          
    366          	// 準備中の場合
    367          	else {
    368          		ret = -1;
   \                     ??ctrc_LSM6DSL_get_gyro_0: (+1)
   \   0000012A   0x2400             MOVS     R4,#+0
   \   0000012C   0x43E4             MVNS     R4,R4            ;; #-1
    369          	}
    370          
    371          	return ret;
   \                     ??ctrc_LSM6DSL_get_gyro_1: (+1)
   \   0000012E   0x0020             MOVS     R0,R4
   \   00000130   0xB007             ADD      SP,SP,#+28
   \   00000132   0xBDF0             POP      {R4-R7,PC}       ;; return
    372          }
    373          
    374          
    375          
    376          /********************************************************************/
    377          /*!
    378           * \name	ctrc_LSM6DSL_set_standby
    379           * \brief	スタンバイモードに移行する
    380           * \param	
    381           * \return   0: 成功
    382           *          -1: 失敗
    383           * \note	
    384           */
    385          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    386          int32_t ctrc_LSM6DSL_set_standby( void )
    387          {
   \                     ctrc_LSM6DSL_set_standby: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    388          	int32_t	ret;
    389          
    390          	ret = LSM6DSL_ctrl1_standby();
   \   00000002   0x.... 0x....      BL       LSM6DSL_ctrl1_standby
    391          	if (ret >= 0) {
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD401             BMI      ??ctrc_LSM6DSL_set_standby_0
    392          		ret = LSM6DSL_ctrl2_standby();
   \   0000000A   0x.... 0x....      BL       LSM6DSL_ctrl2_standby
    393          	}
    394          	
    395          	return ret;
   \                     ??ctrc_LSM6DSL_set_standby_0: (+1)
   \   0000000E   0xBD02             POP      {R1,PC}          ;; return
    396          }
    397          
    398          /********************************************************************/
    399          /*!
    400           * \name	ctrc_LSM6DSL_set_standby
    401           * \brief	アクティブモードに移行する
    402           * \param	
    403           * \return   0: 成功
    404           *          -1: 失敗
    405           * \note	
    406           */
    407          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    408          int32_t ctrc_LSM6DSL_set_active( void )
    409          {
   \                     ctrc_LSM6DSL_set_active: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    410          	int32_t	ret;
    411          
    412          	// 加速度センサ初期化
    413          	ret = LSM6DSL_ctrl1();
   \   00000002   0x.... 0x....      BL       LSM6DSL_ctrl1
    414          
    415          
    416          	// 角速度センサ初期化
    417          	if (ret >= 0) {
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD401             BMI      ??ctrc_LSM6DSL_set_active_0
    418          		ret = LSM6DSL_ctrl2();
   \   0000000A   0x.... 0x....      BL       LSM6DSL_ctrl2
    419          	}
    420          
    421          	return ret;
   \                     ??ctrc_LSM6DSL_set_active_0: (+1)
   \   0000000E   0xBD02             POP      {R1,PC}          ;; return
    422          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_1:
   \   00000000   0x........         DC32     slave_addr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_2:
   \   00000000   0x........         DC32     ?_1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_3:
   \   00000000   0x........         DC32     ?_2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_4:
   \   00000000   0x........         DC32     ?_3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_5:
   \   00000000   0x........         DC32     ?_4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_6:
   \   00000000   0x........         DC32     ?_6

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_7:
   \   00000000   0x........         DC32     ?_8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_8:
   \   00000000   0xFFFF0000         DC32     0xffff0000

   \                                 In section .rodata, align 2
   \                     ?_0:
   \   00000000   0x10 0x00          DC8 16, 0

   \                                 In section .rodata, align 2
   \                     ?_1:
   \   00000000   0x11 0x00          DC8 17, 0

   \                                 In section .rodata, align 2
   \                     ?_2:
   \   00000000   0x10 0x2C          DC8 16, 44

   \                                 In section .rodata, align 2
   \                     ?_3:
   \   00000000   0x11 0x2C          DC8 17, 44

   \                                 In section .rodata, align 2
   \                     ?_4:
   \   00000000   0x0D 0x03          DC8 13, 3

   \                                 In section .rodata, align 4
   \   00000000   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    

   \                                 In section .rodata, align 1
   \                     ?_6:
   \   00000000   0x1E               DC8 30

   \                                 In section .rodata, align 4
   \   00000000   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    

   \                                 In section .rodata, align 1
   \                     ?_8:
   \   00000000   0x22               DC8 34
    423          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   LSM6DSL_ctrl1
        16   -> i2c0_SendData
        16   -> seSysSleepMS
      16   LSM6DSL_ctrl1_standby
        16   -> i2c0_SendData
        16   -> seSysSleepMS
      16   LSM6DSL_ctrl2
        16   -> i2c0_SendData
        16   -> seSysSleepMS
      16   LSM6DSL_ctrl2_standby
        16   -> i2c0_SendData
        16   -> seSysSleepMS
      16   LSM6DSL_int1_ctrl
        16   -> i2c0_SendData
        16   -> seSysSleepMS
      32   LSM6DSL_read_data_status
        32   -> __aeabi_memclr4
        32   -> i2c0_ReceiveData
        32   -> i2c0_SendData
        32   -> seSysSleepMS
      48   ctrc_LSM6DSL_get_gyro
        48   -> LSM6DSL_read_data_status
        48   -> __aeabi_memclr4
        48   -> i2c0_ReceiveData
        48   -> i2c0_SendData
        48   -> seSysSleepMS
       8   ctrc_LSM6DSL_set_active
         8   -> LSM6DSL_ctrl1
         8   -> LSM6DSL_ctrl2
       8   ctrc_LSM6DSL_set_standby
         8   -> LSM6DSL_ctrl1_standby
         8   -> LSM6DSL_ctrl2_standby
       8   ctrc_LSM6DSL_start
         8   -> LSM6DSL_ctrl1
         8   -> LSM6DSL_ctrl2
         8   -> LSM6DSL_int1_ctrl


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable6
       4  ??DataTable6_1
       4  ??DataTable6_2
       4  ??DataTable6_3
       4  ??DataTable6_4
       4  ??DataTable6_5
       4  ??DataTable6_6
       4  ??DataTable6_7
       4  ??DataTable6_8
       2  ?_0
       2  ?_1
       2  ?_2
       2  ?_3
       2  ?_4
      12  ?_5
       1  ?_6
      16  ?_7
       1  ?_8
      52  LSM6DSL_ctrl1
      52  LSM6DSL_ctrl1_standby
      52  LSM6DSL_ctrl2
      52  LSM6DSL_ctrl2_standby
      52  LSM6DSL_int1_ctrl
      94  LSM6DSL_read_data_status
     308  ctrc_LSM6DSL_get_gyro
      16  ctrc_LSM6DSL_set_active
      16  ctrc_LSM6DSL_set_standby
      24  ctrc_LSM6DSL_start
       1  slave_addr

 
   1 byte  in section .data
  40 bytes in section .rodata
 754 bytes in section .text
 
 754 bytes of CODE  memory
  40 bytes of CONST memory
   1 byte  of DATA  memory

Errors: none
Warnings: none
