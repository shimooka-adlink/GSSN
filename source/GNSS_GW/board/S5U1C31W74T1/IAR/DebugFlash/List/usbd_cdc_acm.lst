###############################################################################
#
# IAR ANSI C/C++ Compiler V7.80.4.12462/W32 for ARM       21/May/2019  17:01:05
# Copyright 1999-2017 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  C:\GNSS\Software\rJ105\USBStack\SRC\usbd_cdc_acm.c
#    Command line =  
#        C:\GNSS\Software\rJ105\USBStack\SRC\usbd_cdc_acm.c -D
#        __TARGET_ARCH_7_M -D S1C31W74 -D GNSS_GW_SIDE_A -lCN
#        C:\GNSS\Software\rJ105\source\GNSS_GW\board\S5U1C31W74T1\IAR\DebugFlash\List
#        -lA
#        C:\GNSS\Software\rJ105\source\GNSS_GW\board\S5U1C31W74T1\IAR\DebugFlash\List
#        --diag_suppress Pe177,Pe111,Pa082 -o
#        C:\GNSS\Software\rJ105\source\GNSS_GW\board\S5U1C31W74T1\IAR\DebugFlash\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M0+ -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.5\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\GNSS\Software\rJ105\source\GNSS_GW\board\S5U1C31W74T1\IAR\ -I
#        C:\GNSS\Software\rJ105\source\GNSS_GW\board\S5U1C31W74T1\IAR\..\..\..\
#        -I "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.5\arm\CMSIS\Include\" -I "C:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 7.5\arm\inc\Epson\" -I
#        C:\GNSS\Software\rJ105\source\GNSS_GW\board\S5U1C31W74T1\IAR\..\..\..\..\..\CMSIS\Device\S1C31W74\Include\
#        -I
#        C:\GNSS\Software\rJ105\source\GNSS_GW\board\S5U1C31W74T1\IAR\..\..\..\..\..\CMSIS\Driver\Include\
#        -I
#        C:\GNSS\Software\rJ105\source\GNSS_GW\board\S5U1C31W74T1\IAR\..\..\..\..\..\sePeriphLibrary\
#        -I
#        C:\GNSS\Software\rJ105\source\GNSS_GW\board\S5U1C31W74T1\IAR\..\..\..\..\..\board\S5U1C31W74T1\
#        -I
#        C:\GNSS\Software\rJ105\source\GNSS_GW\board\S5U1C31W74T1\IAR\..\..\..\..\..\USBStack\INC\
#        -I
#        C:\GNSS\Software\rJ105\source\GNSS_GW\board\S5U1C31W74T1\IAR\..\..\..\include\
#        -Ol
#    Locale       =  Japanese_Japan.932
#    List file    =  
#        C:\GNSS\Software\rJ105\source\GNSS_GW\board\S5U1C31W74T1\IAR\DebugFlash\List\usbd_cdc_acm.lst
#    Object file  =  
#        C:\GNSS\Software\rJ105\source\GNSS_GW\board\S5U1C31W74T1\IAR\DebugFlash\Obj\usbd_cdc_acm.o
#
###############################################################################

C:\GNSS\Software\rJ105\USBStack\SRC\usbd_cdc_acm.c
      1          /* CMSIS-DAP Interface Firmware
      2           * Copyright (c) 2009-2013 ARM Limited
      3           *
      4           * Licensed under the Apache License, Version 2.0 (the "License");
      5           * you may not use this file except in compliance with the License.
      6           * You may obtain a copy of the License at
      7           *
      8           *     http://www.apache.org/licenses/LICENSE-2.0
      9           *
     10           * Unless required by applicable law or agreed to in writing, software
     11           * distributed under the License is distributed on an "AS IS" BASIS,
     12           * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     13           * See the License for the specific language governing permissions and
     14           * limitations under the License.
     15           */
     16          #include <RTL.h>
     17          #include <rl_usb.h>
     18          #include <string.h>
     19          #include "usb_for_lib.h"
     20          
     21          
     22          /* Module global variables                                                    */
     23          
     24          /** \ingroup  USBD_CDC_ACM_global_variables
     25              \defgroup USBD_CDC_ACM_GLOBAL_VAR  Global Variables (GLOBAL_VAR)
     26              \brief      Global variables used in USBD CDC ACM module
     27           */

   \                                 In section .bss, align 4
     28          int32_t  data_send_access;              /*!< Flag active while send data (in the send intermediate buffer) is being accessed */
   \                     data_send_access:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     29          int32_t  data_send_active;              /*!< Flag active while data is being sent */
   \                     data_send_active:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     30          int32_t  data_send_zlp;                 /*!< Flag active when ZLP needs to be sent */
   \                     data_send_zlp:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     31          int32_t  data_to_send_wr;               /*!< Number of bytes written to the send intermediate buffer */
   \                     data_to_send_wr:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     32          int32_t  data_to_send_rd;               /*!< Number of bytes read from the send intermediate buffer */
   \                     data_to_send_rd:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     33          uint8_t *ptr_data_to_send;              /*!< Pointer to the send intermediate buffer to the data to be sent */
   \                     ptr_data_to_send:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     34          uint8_t *ptr_data_sent;                 /*!< Pointer to the send intermediate buffer to the data already sent */
   \                     ptr_data_sent:
   \   00000000                      DS8 4

   \                                 In section .bss, align 1
     35          uint8_t  data_send_ACK_rev;             /*!< Flag active while IN ACK recived */
   \                     data_send_ACK_rev:
   \   00000000                      DS8 1
     36          

   \                                 In section .bss, align 4
     37          int32_t  data_read_access;              /*!< Flag active while read data (in the receive intermediate buffer) is being accessed */
   \                     data_read_access:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     38          int32_t  data_receive_int_access;       /*!< Flag active while read data (in the receive intermediate buffer) is being accessed from the IRQ function*/
   \                     data_receive_int_access:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     39          int32_t  data_received_pending_pckts;   /*!< Number of packets received but not handled (pending) */
   \                     data_received_pending_pckts:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     40          int32_t  data_no_space_for_receive;     /*!< Flag active while there is no more space for reception */
   \                     data_no_space_for_receive:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     41          uint8_t *ptr_data_received;             /*!< Pointer to the receive intermediate buffer to the received unread data */
   \                     ptr_data_received:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     42          uint8_t *ptr_data_read;                 /*!< Pointer to the receive intermediate buffer to the received read data */
   \                     ptr_data_read:
   \   00000000                      DS8 4
     43          

   \                                 In section .bss, align 2
     44          uint16_t control_line_state;            /*!< Control line state settings bitmap (0. bit - DTR state, 1. bit - RTS state) */
   \                     control_line_state:
   \   00000000                      DS8 2
     45          

   \                                 In section .bss, align 4
     46          CDC_LINE_CODING line_coding;            /*!< Communication settings */
   \                     line_coding:
   \   00000000                      DS8 8
     47          
     48          /* end of group USBD_CDC_ACM_GLOBAL_VAR */
     49          
     50          
     51          /* Functions that should be provided by user to use standard Virtual COM port
     52             functionality                                                              */

   \                                 In section .text, align 2
     53          __weak int32_t USBD_CDC_ACM_PortInitialize          (void)                             { return (0); };
   \                     USBD_CDC_ACM_PortInitialize: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2
     54          __weak int32_t USBD_CDC_ACM_PortUninitialize        (void)                             { return (0); };
   \                     USBD_CDC_ACM_PortUninitialize: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2
     55          __weak int32_t USBD_CDC_ACM_PortReset               (void)                             { return (0); };
   \                     USBD_CDC_ACM_PortReset: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2
     56          __weak int32_t USBD_CDC_ACM_PortSetLineCoding       (CDC_LINE_CODING *line_coding)     { return (0); };
   \                     USBD_CDC_ACM_PortSetLineCoding: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2
     57          __weak int32_t USBD_CDC_ACM_PortGetLineCoding       (CDC_LINE_CODING *line_coding)     { return (0); };
   \                     USBD_CDC_ACM_PortGetLineCoding: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2
     58          __weak int32_t USBD_CDC_ACM_PortSetControlLineState (uint16_t ctrl_bmp)                { return (0); };
   \                     USBD_CDC_ACM_PortSetControlLineState: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x4770             BX       LR               ;; return
     59          
     60          /* Functions that can be used by user to use standard Virtual COM port
     61             functionality                                                              */
     62                 int32_t USBD_CDC_ACM_DataSend                (const uint8_t *buf, int32_t len);
     63                 int32_t USBD_CDC_ACM_PutChar                 (const uint8_t  ch);
     64                 int32_t USBD_CDC_ACM_DataRead                (      uint8_t *buf, int32_t len);
     65                 int32_t USBD_CDC_ACM_GetChar                 (void);

   \                                 In section .text, align 2
     66          __weak int32_t USBD_CDC_ACM_DataReceived            (                    int32_t len)  { return (0); };
   \                     USBD_CDC_ACM_DataReceived: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x4770             BX       LR               ;; return
     67                 int32_t USBD_CDC_ACM_DataAvailable           (void);
     68                 int32_t USBD_CDC_ACM_Notify                  (uint16_t stat);
     69          
     70          /* Functions handling CDC ACM requests (can be overridden to provide custom
     71             handling of CDC ACM requests)                                              */

   \                                 In section .text, align 2
     72          __weak int32_t USBD_CDC_ACM_SendEncapsulatedCommand (void)                             { return (0); }
   \                     USBD_CDC_ACM_SendEncapsulatedCommand: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2
     73          __weak int32_t USBD_CDC_ACM_GetEncapsulatedResponse (void)                             { return (0); }
   \                     USBD_CDC_ACM_GetEncapsulatedResponse: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2
     74          __weak int32_t USBD_CDC_ACM_SetCommFeature          (uint16_t feat)                    { return (0); }
   \                     USBD_CDC_ACM_SetCommFeature: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2
     75          __weak int32_t USBD_CDC_ACM_GetCommFeature          (uint16_t feat)                    { return (0); }
   \                     USBD_CDC_ACM_GetCommFeature: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2
     76          __weak int32_t USBD_CDC_ACM_ClearCommFeature        (uint16_t feat)                    { return (0); }
   \                     USBD_CDC_ACM_ClearCommFeature: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2
     77          __weak int32_t USBD_CDC_ACM_SendBreak               (uint16_t dur)                     { return (0); }
   \                     USBD_CDC_ACM_SendBreak: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x4770             BX       LR               ;; return
     78          
     79          
     80          /* Local function prototypes                                                  */
     81          static void    USBD_CDC_ACM_EP_BULKOUT_HandleData   (void);
     82          //-- static void    USBD_CDC_ACM_EP_BULKIN_HandleData    (void);
     83          static int32_t    USBD_CDC_ACM_EP_BULKIN_HandleData    (void);
     84          
     85          
     86          /*----------------- USB CDC ACM class handling functions ---------------------*/
     87          
     88          /** \brief  Initialization of the USB CDC class (ACM)
     89          
     90              The function calls USBD_CDC_ACM_PortInitialize function which
     91              initializes Virtual COM Port.
     92          
     93              \return             0        Function failed.
     94              \return             1        Function succeeded.
     95           */
     96          

   \                                 In section .text, align 2
     97          __weak int32_t USBD_CDC_ACM_Initialize (void) {
   \                     USBD_CDC_ACM_Initialize: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
     98          
     99            return (USBD_CDC_ACM_PortInitialize ());
   \   00000002   0x.... 0x....      BL       USBD_CDC_ACM_PortInitialize
   \   00000006   0xBD02             POP      {R1,PC}          ;; return
    100          }
    101          
    102          
    103          /** \brief  Uninitialization of the USB CDC class (ACM)
    104          
    105              The function calls USBD_CDC_ACM_PortUninitialize function which
    106              uninitializes Virtual COM Port.
    107          
    108              \return             0        Function failed.
    109              \return             1        Function succeeded.
    110           */
    111          

   \                                 In section .text, align 2
    112          __weak int32_t USBD_CDC_ACM_Uninitialization (void) {
   \                     USBD_CDC_ACM_Uninitialization: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    113          
    114            return (USBD_CDC_ACM_PortUninitialize ());
   \   00000002   0x.... 0x....      BL       USBD_CDC_ACM_PortUninitialize
   \   00000006   0xBD02             POP      {R1,PC}          ;; return
    115          }
    116          
    117          
    118          /** \brief  Reset of the USB CDC class (ACM) variables and states
    119          
    120              The function resets class variables and states, it calls
    121              USBD_CDC_ACM_PortReset function which resets Virtual COM Port variables
    122              and states and calls USBD_CDC_ACM_PortSetLineCoding function with
    123              default parameters to set default communication settings for the
    124              Virtual COM Port.
    125          
    126              \return             0        Function failed.
    127              \return             1        Function succeeded.
    128           */
    129          

   \                                 In section .text, align 4
    130          __weak int32_t USBD_CDC_ACM_Reset (void) {
   \                     USBD_CDC_ACM_Reset: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    131          
    132            data_send_access            = 0;
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x491F             LDR      R1,??USBD_CDC_ACM_Reset_0
   \   00000006   0x6008             STR      R0,[R1, #+0]
    133            data_send_active            = 0;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x491F             LDR      R1,??USBD_CDC_ACM_Reset_0+0x4
   \   0000000C   0x6008             STR      R0,[R1, #+0]
    134            data_send_zlp               = 0;
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0x491E             LDR      R1,??USBD_CDC_ACM_Reset_0+0x8
   \   00000012   0x6008             STR      R0,[R1, #+0]
    135            data_to_send_wr             = 0;
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x491E             LDR      R1,??USBD_CDC_ACM_Reset_0+0xC
   \   00000018   0x6008             STR      R0,[R1, #+0]
    136            data_to_send_rd             = 0;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x491D             LDR      R1,??USBD_CDC_ACM_Reset_0+0x10
   \   0000001E   0x6008             STR      R0,[R1, #+0]
    137            ptr_data_to_send            = USBD_CDC_ACM_SendBuf;
   \   00000020   0x481D             LDR      R0,??USBD_CDC_ACM_Reset_0+0x14
   \   00000022   0x491E             LDR      R1,??USBD_CDC_ACM_Reset_0+0x18
   \   00000024   0x6008             STR      R0,[R1, #+0]
    138            ptr_data_sent               = USBD_CDC_ACM_SendBuf;
   \   00000026   0x481C             LDR      R0,??USBD_CDC_ACM_Reset_0+0x14
   \   00000028   0x491D             LDR      R1,??USBD_CDC_ACM_Reset_0+0x1C
   \   0000002A   0x6008             STR      R0,[R1, #+0]
    139            data_send_ACK_rev           = 0;
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0x491D             LDR      R1,??USBD_CDC_ACM_Reset_0+0x20
   \   00000030   0x7008             STRB     R0,[R1, #+0]
    140          
    141            data_read_access            = 0;
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0x491C             LDR      R1,??USBD_CDC_ACM_Reset_0+0x24
   \   00000036   0x6008             STR      R0,[R1, #+0]
    142            data_receive_int_access     = 0;
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0x491C             LDR      R1,??USBD_CDC_ACM_Reset_0+0x28
   \   0000003C   0x6008             STR      R0,[R1, #+0]
    143            data_received_pending_pckts = 0;
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0x491B             LDR      R1,??USBD_CDC_ACM_Reset_0+0x2C
   \   00000042   0x6008             STR      R0,[R1, #+0]
    144            data_no_space_for_receive   = 0;
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0x491B             LDR      R1,??USBD_CDC_ACM_Reset_0+0x30
   \   00000048   0x6008             STR      R0,[R1, #+0]
    145            ptr_data_received           = USBD_CDC_ACM_ReceiveBuf;
   \   0000004A   0x481B             LDR      R0,??USBD_CDC_ACM_Reset_0+0x34
   \   0000004C   0x491B             LDR      R1,??USBD_CDC_ACM_Reset_0+0x38
   \   0000004E   0x6008             STR      R0,[R1, #+0]
    146            ptr_data_read               = USBD_CDC_ACM_ReceiveBuf;
   \   00000050   0x4819             LDR      R0,??USBD_CDC_ACM_Reset_0+0x34
   \   00000052   0x491B             LDR      R1,??USBD_CDC_ACM_Reset_0+0x3C
   \   00000054   0x6008             STR      R0,[R1, #+0]
    147          
    148            control_line_state          = 0;
   \   00000056   0x2000             MOVS     R0,#+0
   \   00000058   0x491A             LDR      R1,??USBD_CDC_ACM_Reset_0+0x40
   \   0000005A   0x8008             STRH     R0,[R1, #+0]
    149          
    150            USBD_CDC_ACM_PortReset ();
   \   0000005C   0x.... 0x....      BL       USBD_CDC_ACM_PortReset
    151          
    152            line_coding.dwDTERate       = 9600;
   \   00000060   0x2096             MOVS     R0,#+150
   \   00000062   0x0180             LSLS     R0,R0,#+6        ;; #+9600
   \   00000064   0x4918             LDR      R1,??USBD_CDC_ACM_Reset_0+0x44
   \   00000066   0x6008             STR      R0,[R1, #+0]
    153            line_coding.bCharFormat     = 0;
   \   00000068   0x2000             MOVS     R0,#+0
   \   0000006A   0x4917             LDR      R1,??USBD_CDC_ACM_Reset_0+0x44
   \   0000006C   0x7108             STRB     R0,[R1, #+4]
    154            line_coding.bParityType     = 0;
   \   0000006E   0x2000             MOVS     R0,#+0
   \   00000070   0x4915             LDR      R1,??USBD_CDC_ACM_Reset_0+0x44
   \   00000072   0x7148             STRB     R0,[R1, #+5]
    155            line_coding.bDataBits       = 8;
   \   00000074   0x2008             MOVS     R0,#+8
   \   00000076   0x4914             LDR      R1,??USBD_CDC_ACM_Reset_0+0x44
   \   00000078   0x7188             STRB     R0,[R1, #+6]
    156          
    157            return (USBD_CDC_ACM_PortSetLineCoding (&line_coding));
   \   0000007A   0x4813             LDR      R0,??USBD_CDC_ACM_Reset_0+0x44
   \   0000007C   0x.... 0x....      BL       USBD_CDC_ACM_PortSetLineCoding
   \   00000080   0xBD02             POP      {R1,PC}          ;; return
   \   00000082   0xBF00             Nop      
   \                     ??USBD_CDC_ACM_Reset_0:
   \   00000084   0x........         DC32     data_send_access
   \   00000088   0x........         DC32     data_send_active
   \   0000008C   0x........         DC32     data_send_zlp
   \   00000090   0x........         DC32     data_to_send_wr
   \   00000094   0x........         DC32     data_to_send_rd
   \   00000098   0x........         DC32     USBD_CDC_ACM_SendBuf
   \   0000009C   0x........         DC32     ptr_data_to_send
   \   000000A0   0x........         DC32     ptr_data_sent
   \   000000A4   0x........         DC32     data_send_ACK_rev
   \   000000A8   0x........         DC32     data_read_access
   \   000000AC   0x........         DC32     data_receive_int_access
   \   000000B0   0x........         DC32     data_received_pending_pckts
   \   000000B4   0x........         DC32     data_no_space_for_receive
   \   000000B8   0x........         DC32     USBD_CDC_ACM_ReceiveBuf
   \   000000BC   0x........         DC32     ptr_data_received
   \   000000C0   0x........         DC32     ptr_data_read
   \   000000C4   0x........         DC32     control_line_state
   \   000000C8   0x........         DC32     line_coding
    158          }
    159          
    160          
    161          /** \brief  Sets Line Coding for the USB CDC ACM Virtual COM Port
    162          
    163              The function is a callback function that forwards USB CDC ACM request
    164              to set communication settings to the Virtual COM Port.
    165          
    166              \return             0        Function failed.
    167              \return             1        Function succeeded.
    168           */
    169          

   \                                 In section .text, align 4
    170          __weak int32_t USBD_CDC_ACM_SetLineCoding (void) {
   \                     USBD_CDC_ACM_SetLineCoding: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    171          
    172            line_coding.dwDTERate   = (USBD_EP0Buf[0] <<  0) |
    173                                      (USBD_EP0Buf[1] <<  8) |
    174                                      (USBD_EP0Buf[2] << 16) |
    175                                      (USBD_EP0Buf[3] << 24) ;
   \   00000002   0x4810             LDR      R0,??USBD_CDC_ACM_SetLineCoding_0
   \   00000004   0x7800             LDRB     R0,[R0, #+0]
   \   00000006   0x490F             LDR      R1,??USBD_CDC_ACM_SetLineCoding_0
   \   00000008   0x7849             LDRB     R1,[R1, #+1]
   \   0000000A   0x0209             LSLS     R1,R1,#+8
   \   0000000C   0x4301             ORRS     R1,R1,R0
   \   0000000E   0x480D             LDR      R0,??USBD_CDC_ACM_SetLineCoding_0
   \   00000010   0x7880             LDRB     R0,[R0, #+2]
   \   00000012   0x0400             LSLS     R0,R0,#+16
   \   00000014   0x4308             ORRS     R0,R0,R1
   \   00000016   0x490B             LDR      R1,??USBD_CDC_ACM_SetLineCoding_0
   \   00000018   0x78C9             LDRB     R1,[R1, #+3]
   \   0000001A   0x0609             LSLS     R1,R1,#+24
   \   0000001C   0x4301             ORRS     R1,R1,R0
   \   0000001E   0x480A             LDR      R0,??USBD_CDC_ACM_SetLineCoding_0+0x4
   \   00000020   0x6001             STR      R1,[R0, #+0]
    176            line_coding.bCharFormat =  USBD_EP0Buf[4];
   \   00000022   0x4808             LDR      R0,??USBD_CDC_ACM_SetLineCoding_0
   \   00000024   0x7900             LDRB     R0,[R0, #+4]
   \   00000026   0x4908             LDR      R1,??USBD_CDC_ACM_SetLineCoding_0+0x4
   \   00000028   0x7108             STRB     R0,[R1, #+4]
    177            line_coding.bParityType =  USBD_EP0Buf[5];
   \   0000002A   0x4806             LDR      R0,??USBD_CDC_ACM_SetLineCoding_0
   \   0000002C   0x7940             LDRB     R0,[R0, #+5]
   \   0000002E   0x4906             LDR      R1,??USBD_CDC_ACM_SetLineCoding_0+0x4
   \   00000030   0x7148             STRB     R0,[R1, #+5]
    178            line_coding.bDataBits   =  USBD_EP0Buf[6];
   \   00000032   0x4804             LDR      R0,??USBD_CDC_ACM_SetLineCoding_0
   \   00000034   0x7980             LDRB     R0,[R0, #+6]
   \   00000036   0x4904             LDR      R1,??USBD_CDC_ACM_SetLineCoding_0+0x4
   \   00000038   0x7188             STRB     R0,[R1, #+6]
    179          
    180            return (USBD_CDC_ACM_PortSetLineCoding (&line_coding));
   \   0000003A   0x4803             LDR      R0,??USBD_CDC_ACM_SetLineCoding_0+0x4
   \   0000003C   0x.... 0x....      BL       USBD_CDC_ACM_PortSetLineCoding
   \   00000040   0xBD02             POP      {R1,PC}          ;; return
   \   00000042   0xBF00             Nop      
   \                     ??USBD_CDC_ACM_SetLineCoding_0:
   \   00000044   0x........         DC32     USBD_EP0Buf
   \   00000048   0x........         DC32     line_coding
    181          }
    182          
    183          
    184          /** \brief  Gets Line Coding from the USB CDC ACM Virtual COM Port
    185          
    186              The function is a callback function that forwards USB CDC ACM request
    187              to get communication settings from the Virtual COM Port.
    188          
    189              \return             0        Function failed.
    190              \return             1        Function succeeded.
    191           */
    192          

   \                                 In section .text, align 4
    193          __weak int32_t USBD_CDC_ACM_GetLineCoding (void) {
   \                     USBD_CDC_ACM_GetLineCoding: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    194          
    195            if (USBD_CDC_ACM_PortGetLineCoding (&line_coding)) {
   \   00000002   0x4814             LDR      R0,??USBD_CDC_ACM_GetLineCoding_0
   \   00000004   0x.... 0x....      BL       USBD_CDC_ACM_PortGetLineCoding
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD020             BEQ      ??USBD_CDC_ACM_GetLineCoding_1
    196              USBD_EP0Buf[0] = (line_coding.dwDTERate >>  0) & 0xFF;
   \   0000000C   0x4811             LDR      R0,??USBD_CDC_ACM_GetLineCoding_0
   \   0000000E   0x6800             LDR      R0,[R0, #+0]
   \   00000010   0x4911             LDR      R1,??USBD_CDC_ACM_GetLineCoding_0+0x4
   \   00000012   0x7008             STRB     R0,[R1, #+0]
    197              USBD_EP0Buf[1] = (line_coding.dwDTERate >>  8) & 0xFF;
   \   00000014   0x480F             LDR      R0,??USBD_CDC_ACM_GetLineCoding_0
   \   00000016   0x6800             LDR      R0,[R0, #+0]
   \   00000018   0x0A00             LSRS     R0,R0,#+8
   \   0000001A   0x490F             LDR      R1,??USBD_CDC_ACM_GetLineCoding_0+0x4
   \   0000001C   0x7048             STRB     R0,[R1, #+1]
    198              USBD_EP0Buf[2] = (line_coding.dwDTERate >> 16) & 0xFF;
   \   0000001E   0x480D             LDR      R0,??USBD_CDC_ACM_GetLineCoding_0
   \   00000020   0x6800             LDR      R0,[R0, #+0]
   \   00000022   0x0C00             LSRS     R0,R0,#+16
   \   00000024   0x490C             LDR      R1,??USBD_CDC_ACM_GetLineCoding_0+0x4
   \   00000026   0x7088             STRB     R0,[R1, #+2]
    199              USBD_EP0Buf[3] = (line_coding.dwDTERate >> 24) & 0xFF;
   \   00000028   0x480A             LDR      R0,??USBD_CDC_ACM_GetLineCoding_0
   \   0000002A   0x6800             LDR      R0,[R0, #+0]
   \   0000002C   0x0E00             LSRS     R0,R0,#+24
   \   0000002E   0x490A             LDR      R1,??USBD_CDC_ACM_GetLineCoding_0+0x4
   \   00000030   0x70C8             STRB     R0,[R1, #+3]
    200              USBD_EP0Buf[4] =  line_coding.bCharFormat;
   \   00000032   0x4808             LDR      R0,??USBD_CDC_ACM_GetLineCoding_0
   \   00000034   0x7900             LDRB     R0,[R0, #+4]
   \   00000036   0x4908             LDR      R1,??USBD_CDC_ACM_GetLineCoding_0+0x4
   \   00000038   0x7108             STRB     R0,[R1, #+4]
    201              USBD_EP0Buf[5] =  line_coding.bParityType;
   \   0000003A   0x4806             LDR      R0,??USBD_CDC_ACM_GetLineCoding_0
   \   0000003C   0x7940             LDRB     R0,[R0, #+5]
   \   0000003E   0x4906             LDR      R1,??USBD_CDC_ACM_GetLineCoding_0+0x4
   \   00000040   0x7148             STRB     R0,[R1, #+5]
    202              USBD_EP0Buf[6] =  line_coding.bDataBits;
   \   00000042   0x4804             LDR      R0,??USBD_CDC_ACM_GetLineCoding_0
   \   00000044   0x7980             LDRB     R0,[R0, #+6]
   \   00000046   0x4904             LDR      R1,??USBD_CDC_ACM_GetLineCoding_0+0x4
   \   00000048   0x7188             STRB     R0,[R1, #+6]
    203              return (1);
   \   0000004A   0x2001             MOVS     R0,#+1
   \   0000004C   0xE000             B        ??USBD_CDC_ACM_GetLineCoding_2
    204            }
    205          
    206            return (0);
   \                     ??USBD_CDC_ACM_GetLineCoding_1: (+1)
   \   0000004E   0x2000             MOVS     R0,#+0
   \                     ??USBD_CDC_ACM_GetLineCoding_2: (+1)
   \   00000050   0xBD02             POP      {R1,PC}          ;; return
   \   00000052   0xBF00             Nop      
   \                     ??USBD_CDC_ACM_GetLineCoding_0:
   \   00000054   0x........         DC32     line_coding
   \   00000058   0x........         DC32     USBD_EP0Buf
    207          }
    208          
    209          
    210          /** \brief  Sets Control Line State for the USB CDC ACM Virtual COM Port
    211          
    212              The function is a callback function that forwards USB CDC ACM request
    213              to set desired control line state to the Virtual COM Port.
    214          
    215              \param [in]         ctrl_bmp Control line settings bitmap (
    216                                    0. bit - DTR state,
    217                                    1. bit - RTS state).
    218              \return             0        Function failed.
    219              \return             1        Function succeeded.
    220           */
    221          

   \                                 In section .text, align 4
    222          __weak int32_t USBD_CDC_ACM_SetControlLineState (uint16_t ctrl_bmp) {
   \                     USBD_CDC_ACM_SetControlLineState: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    223          
    224            control_line_state = ctrl_bmp;
   \   00000002   0x4903             LDR      R1,??USBD_CDC_ACM_SetControlLineState_0
   \   00000004   0x8008             STRH     R0,[R1, #+0]
    225          
    226            return (USBD_CDC_ACM_PortSetControlLineState (ctrl_bmp));
   \   00000006   0xB280             UXTH     R0,R0
   \   00000008   0x.... 0x....      BL       USBD_CDC_ACM_PortSetControlLineState
   \   0000000C   0xBD02             POP      {R1,PC}          ;; return
   \   0000000E   0xBF00             Nop      
   \                     ??USBD_CDC_ACM_SetControlLineState_0:
   \   00000010   0x........         DC32     control_line_state
    227          }
    228          
    229          
    230          /*----------------- USB CDC ACM user API functions ---------------------------*/
    231          
    232          /** \brief Number of free bytes in the Send buffer
    233          */

   \                                 In section .text, align 2, keep-with-next
    234          int32_t USBD_CDC_ACM_DataFree(void) {
    235            return ((int32_t)usbd_cdc_acm_sendbuf_sz) - (data_to_send_wr - data_to_send_rd);
   \                     USBD_CDC_ACM_DataFree: (+1)
   \   00000000   0x....             LDR      R0,??DataTable6
   \   00000002   0x8800             LDRH     R0,[R0, #+0]
   \   00000004   0x....             LDR      R1,??DataTable6_1
   \   00000006   0x6809             LDR      R1,[R1, #+0]
   \   00000008   0x1A40             SUBS     R0,R0,R1
   \   0000000A   0x....             LDR      R1,??DataTable6_2
   \   0000000C   0x6809             LDR      R1,[R1, #+0]
   \   0000000E   0x1840             ADDS     R0,R0,R1
   \   00000010   0x4770             BX       LR               ;; return
    236          }
    237          
    238          /** \brief  Sends data over the USB CDC ACM Virtual COM Port
    239          
    240              The function puts requested data to the send intermediate buffer and
    241              prepares it for sending over the Virtual COM Port.
    242          
    243              \param [in]         buf      Buffer containing data to be sent.
    244              \param [in]         len      Maximum number of bytes to be sent.
    245              \return                      Number of bytes accepted to be sent.
    246           */
    247          

   \                                 In section .text, align 2, keep-with-next
    248          int32_t USBD_CDC_ACM_DataSend (const uint8_t *buf, int32_t len) {
   \                     USBD_CDC_ACM_DataSend: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x000D             MOVS     R5,R1
    249            int32_t  len_data, len_available, len_before_wrap;
    250            uint8_t *buf_loc;
    251          
    252            buf_loc       = (uint8_t *)buf;       /* Pointer to buf                     */
   \   00000004   0x0006             MOVS     R6,R0
    253            len_data      = data_to_send_wr - data_to_send_rd;  /* Num of data in buffer*/
   \   00000006   0x....             LDR      R0,??DataTable6_1
   \   00000008   0x6800             LDR      R0,[R0, #+0]
   \   0000000A   0x....             LDR      R1,??DataTable6_2
   \   0000000C   0x6809             LDR      R1,[R1, #+0]
   \   0000000E   0x1A40             SUBS     R0,R0,R1
    254            len_available = ((int32_t)usbd_cdc_acm_sendbuf_sz) - len_data;  /* Num of
   \   00000010   0x....             LDR      R1,??DataTable6
   \   00000012   0x8809             LDRH     R1,[R1, #+0]
   \   00000014   0x1A08             SUBS     R0,R1,R0
    255                                                     bytes of space available           */
    256            if (len_available <= 0)               /* If no space for data to send       */
   \   00000016   0x2801             CMP      R0,#+1
   \   00000018   0xDA01             BGE      ??USBD_CDC_ACM_DataSend_0
    257              return (0);
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0xE03A             B        ??USBD_CDC_ACM_DataSend_1
    258          
    259            if (len > len_available)              /* If more data requested for sending
   \                     ??USBD_CDC_ACM_DataSend_0: (+1)
   \   0000001E   0x42A8             CMP      R0,R5
   \   00000020   0xDA00             BGE      ??USBD_CDC_ACM_DataSend_2
    260                                                     then available space               */
    261              len = len_available;                /* Correct to maximum available       */
   \   00000022   0x0005             MOVS     R5,R0
    262          
    263            len_before_wrap = 0;                  /* Circular buffer size before wrap   */
   \                     ??USBD_CDC_ACM_DataSend_2: (+1)
   \   00000024   0x2400             MOVS     R4,#+0
    264          
    265            if ((ptr_data_to_send>=ptr_data_sent) &&   /* If wrap is possible to happen */
    266               ((ptr_data_to_send + len) >= (USBD_CDC_ACM_SendBuf + usbd_cdc_acm_sendbuf_sz))) {
   \   00000026   0x....             LDR      R0,??DataTable7
   \   00000028   0x6800             LDR      R0,[R0, #+0]
   \   0000002A   0x....             LDR      R1,??DataTable7_1
   \   0000002C   0x6809             LDR      R1,[R1, #+0]
   \   0000002E   0x4288             CMP      R0,R1
   \   00000030   0xD31B             BCC      ??USBD_CDC_ACM_DataSend_3
   \   00000032   0x....             LDR      R0,??DataTable7
   \   00000034   0x6800             LDR      R0,[R0, #+0]
   \   00000036   0x1940             ADDS     R0,R0,R5
   \   00000038   0x....             LDR      R1,??DataTable7_2
   \   0000003A   0x....             LDR      R2,??DataTable6
   \   0000003C   0x8812             LDRH     R2,[R2, #+0]
   \   0000003E   0x1889             ADDS     R1,R1,R2
   \   00000040   0x4288             CMP      R0,R1
   \   00000042   0xD312             BCC      ??USBD_CDC_ACM_DataSend_3
    267                                                  /* If data wraps around end of buffer */
    268              len_before_wrap   = USBD_CDC_ACM_SendBuf + usbd_cdc_acm_sendbuf_sz - ptr_data_to_send;
   \   00000044   0x....             LDR      R0,??DataTable7_2
   \   00000046   0x....             LDR      R1,??DataTable6
   \   00000048   0x8809             LDRH     R1,[R1, #+0]
   \   0000004A   0x1840             ADDS     R0,R0,R1
   \   0000004C   0x....             LDR      R1,??DataTable7
   \   0000004E   0x6809             LDR      R1,[R1, #+0]
   \   00000050   0x1A44             SUBS     R4,R0,R1
    269              memcpy (ptr_data_to_send, buf_loc, len_before_wrap);/* Copy data till end */
   \   00000052   0x0022             MOVS     R2,R4
   \   00000054   0x0031             MOVS     R1,R6
   \   00000056   0x....             LDR      R0,??DataTable7
   \   00000058   0x6807             LDR      R7,[R0, #+0]
   \   0000005A   0x0038             MOVS     R0,R7
   \   0000005C   0x.... 0x....      BL       __aeabi_memcpy
    270              buf_loc          += len_before_wrap;            /* Increment buf pointer  */
   \   00000060   0x1936             ADDS     R6,R6,R4
    271              len              -= len_before_wrap;            /* Decrement bytes to send*/
   \   00000062   0x1B2D             SUBS     R5,R5,R4
    272              ptr_data_to_send  = USBD_CDC_ACM_SendBuf;       /* Wrap send buffer
   \   00000064   0x....             LDR      R0,??DataTable7_2
   \   00000066   0x....             LDR      R1,??DataTable7
   \   00000068   0x6008             STR      R0,[R1, #+0]
    273                                                                 pointer to beginning of
    274                                                                 the send buffer        */
    275            }
    276          
    277            if (len) {                            /* If there are bytes to send         */
   \                     ??USBD_CDC_ACM_DataSend_3: (+1)
   \   0000006A   0x2D00             CMP      R5,#+0
   \   0000006C   0xD00B             BEQ      ??USBD_CDC_ACM_DataSend_4
    278              memcpy (ptr_data_to_send, buf_loc, len);  /* Copy data to send buffer     */
   \   0000006E   0x002A             MOVS     R2,R5
   \   00000070   0x0031             MOVS     R1,R6
   \   00000072   0x....             LDR      R0,??DataTable7
   \   00000074   0x6806             LDR      R6,[R0, #+0]
   \   00000076   0x0030             MOVS     R0,R6
   \   00000078   0x.... 0x....      BL       __aeabi_memcpy
    279              ptr_data_to_send += len;            /* Correct position of write pointer  */
   \   0000007C   0x....             LDR      R0,??DataTable7
   \   0000007E   0x6800             LDR      R0,[R0, #+0]
   \   00000080   0x1940             ADDS     R0,R0,R5
   \   00000082   0x....             LDR      R1,??DataTable7
   \   00000084   0x6008             STR      R0,[R1, #+0]
    280            }
    281            len += len_before_wrap;               /* Total number of bytes prepared for
   \                     ??USBD_CDC_ACM_DataSend_4: (+1)
   \   00000086   0x192D             ADDS     R5,R5,R4
    282                                                     send                               */
    283            data_to_send_wr += len;               /* Bytes prepared to send counter     */
   \   00000088   0x....             LDR      R0,??DataTable6_1
   \   0000008A   0x6800             LDR      R0,[R0, #+0]
   \   0000008C   0x1940             ADDS     R0,R0,R5
   \   0000008E   0x....             LDR      R1,??DataTable6_1
   \   00000090   0x6008             STR      R0,[R1, #+0]
    284          //USBD_CDC_ACM_SOF_Event();     // add hk
    285            return (len);                         /* Number of bytes accepted for send  */
   \   00000092   0x0028             MOVS     R0,R5
   \                     ??USBD_CDC_ACM_DataSend_1: (+1)
   \   00000094   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    286          }
    287          

   \                                 In section .text, align 2, keep-with-next
    288          int32_t
    289          USBD_CDC_ACM_WaitSendCompletion() {
   \                     USBD_CDC_ACM_WaitSendCompletion: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    290          //+++---------------------------------------------------------------------
    291              if (data_send_ACK_rev == 0) {
   \   00000002   0x....             LDR      R0,??DataTable7_3
   \   00000004   0x7800             LDRB     R0,[R0, #+0]
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD101             BNE      ??USBD_CDC_ACM_WaitSendCompletion_0
    292                  return 0;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0xE004             B        ??USBD_CDC_ACM_WaitSendCompletion_1
    293              }
    294          	else {
    295          		data_send_ACK_rev = 0;
   \                     ??USBD_CDC_ACM_WaitSendCompletion_0: (+1)
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0x....             LDR      R1,??DataTable7_3
   \   00000012   0x7008             STRB     R0,[R1, #+0]
    296          	}
    297          //+++---------------------------------------------------------------------
    298          
    299              return USBD_CDC_ACM_EP_BULKIN_HandleData();
   \   00000014   0x.... 0x....      BL       USBD_CDC_ACM_EP_BULKIN_HandleData
   \                     ??USBD_CDC_ACM_WaitSendCompletion_1: (+1)
   \   00000018   0xBD02             POP      {R1,PC}          ;; return
    300          }
    301          
    302          /** \brief  Sends a single character over the USB CDC ACM Virtual COM Port
    303          
    304              The function puts requested data character to the send intermediate buffer
    305              and prepares it for sending over the Virtual COM Port.
    306          
    307              \param [in]         ch       Character to be sent.
    308              \return             -1       Function failed.
    309              \return                      Character accepted to be sent.
    310           */
    311          

   \                                 In section .text, align 2, keep-with-next
    312          int32_t USBD_CDC_ACM_PutChar (const uint8_t ch) {
   \                     USBD_CDC_ACM_PutChar: (+1)
   \   00000000   0xB501             PUSH     {R0,LR}
    313          
    314            if ((USBD_CDC_ACM_DataSend (&ch, 1)) == 1)
   \   00000002   0x2101             MOVS     R1,#+1
   \   00000004   0x4668             MOV      R0,SP
   \   00000006   0x.... 0x....      BL       USBD_CDC_ACM_DataSend
   \   0000000A   0x2801             CMP      R0,#+1
   \   0000000C   0xD102             BNE      ??USBD_CDC_ACM_PutChar_0
    315              return ((uint32_t) ch);
   \   0000000E   0x4668             MOV      R0,SP
   \   00000010   0x7800             LDRB     R0,[R0, #+0]
   \   00000012   0xE001             B        ??USBD_CDC_ACM_PutChar_1
    316          
    317            return (-1);
   \                     ??USBD_CDC_ACM_PutChar_0: (+1)
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x43C0             MVNS     R0,R0            ;; #-1
   \                     ??USBD_CDC_ACM_PutChar_1: (+1)
   \   00000018   0xBD02             POP      {R1,PC}          ;; return
    318          }
    319          
    320          
    321          /** \brief  Reads data received over the USB CDC ACM Virtual COM Port
    322          
    323              The function reads data from the receive intermediate buffer that was
    324              received over the Virtual COM Port.
    325          
    326              \param [in]         buf      Buffer to where data will be read.
    327              \param [in]         len      Maximum number of bytes to be read.
    328              \return                      Number of bytes actually read.
    329           */
    330          

   \                                 In section .text, align 2, keep-with-next
    331          int32_t USBD_CDC_ACM_DataRead (uint8_t *buf, int32_t len) {
   \                     USBD_CDC_ACM_DataRead: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    332            int32_t len_data;
    333          
    334            if (ptr_data_received>ptr_data_read) {/*If there is already received data   */
   \   00000006   0x....             LDR      R0,??DataTable8
   \   00000008   0x6800             LDR      R0,[R0, #+0]
   \   0000000A   0x....             LDR      R1,??DataTable7_4
   \   0000000C   0x6809             LDR      R1,[R1, #+0]
   \   0000000E   0x4288             CMP      R0,R1
   \   00000010   0xD213             BCS      ??USBD_CDC_ACM_DataRead_0
    335              len_data = ptr_data_received - ptr_data_read; /* Available bytes of data  */
   \   00000012   0x....             LDR      R0,??DataTable7_4
   \   00000014   0x6800             LDR      R0,[R0, #+0]
   \   00000016   0x....             LDR      R1,??DataTable8
   \   00000018   0x6809             LDR      R1,[R1, #+0]
   \   0000001A   0x1A40             SUBS     R0,R0,R1
    336          
    337              if (len > len_data)                 /* If more requested then available   */
   \   0000001C   0x42A8             CMP      R0,R5
   \   0000001E   0xDA00             BGE      ??USBD_CDC_ACM_DataRead_1
    338                len = len_data;                   /* correct to return maximum available*/
   \   00000020   0x0005             MOVS     R5,R0
    339          
    340              memcpy (buf, ptr_data_read, len);   /* Copy received data to provided buf */
   \                     ??USBD_CDC_ACM_DataRead_1: (+1)
   \   00000022   0x....             LDR      R0,??DataTable8
   \   00000024   0x6801             LDR      R1,[R0, #+0]
   \   00000026   0x002A             MOVS     R2,R5
   \   00000028   0x0020             MOVS     R0,R4
   \   0000002A   0x.... 0x....      BL       __aeabi_memcpy
    341              ptr_data_read      += len;          /* Correct position of read pointer   */
   \   0000002E   0x....             LDR      R0,??DataTable8
   \   00000030   0x6800             LDR      R0,[R0, #+0]
   \   00000032   0x1940             ADDS     R0,R0,R5
   \   00000034   0x....             LDR      R1,??DataTable8
   \   00000036   0x6008             STR      R0,[R1, #+0]
   \   00000038   0xE000             B        ??USBD_CDC_ACM_DataRead_2
    342            } else {
    343              len = 0;                            /* No data received                   */
   \                     ??USBD_CDC_ACM_DataRead_0: (+1)
   \   0000003A   0x2500             MOVS     R5,#+0
    344            }
    345          
    346            return (len);                         /* Number of bytes actually read      */
   \                     ??USBD_CDC_ACM_DataRead_2: (+1)
   \   0000003C   0x0028             MOVS     R0,R5
   \   0000003E   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    347          }
    348          
    349          
    350          /** \brief  Reads one character of data received over the USB CDC ACM Virtual COM Port
    351          
    352              The function reads data character from the receive intermediate buffer that
    353              was received over the Virtual COM Port.
    354          
    355              \return             -1       No character available.
    356              \return                      Received character.
    357           */
    358          

   \                                 In section .text, align 2, keep-with-next
    359          int32_t USBD_CDC_ACM_GetChar (void) {
   \                     USBD_CDC_ACM_GetChar: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    360            uint8_t ch;
    361          
    362            if ((USBD_CDC_ACM_DataRead (&ch, 1)) == 1)
   \   00000002   0x2101             MOVS     R1,#+1
   \   00000004   0x4668             MOV      R0,SP
   \   00000006   0x.... 0x....      BL       USBD_CDC_ACM_DataRead
   \   0000000A   0x2801             CMP      R0,#+1
   \   0000000C   0xD102             BNE      ??USBD_CDC_ACM_GetChar_0
    363              return ((int32_t) ch);
   \   0000000E   0x4668             MOV      R0,SP
   \   00000010   0x7800             LDRB     R0,[R0, #+0]
   \   00000012   0xE001             B        ??USBD_CDC_ACM_GetChar_1
    364          
    365            return (-1);
   \                     ??USBD_CDC_ACM_GetChar_0: (+1)
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x43C0             MVNS     R0,R0            ;; #-1
   \                     ??USBD_CDC_ACM_GetChar_1: (+1)
   \   00000018   0xBD02             POP      {R1,PC}          ;; return
    366          }
    367          
    368          
    369          /** \brief  Retrieves number of bytes received over the USB CDC ACM Virtual COM Port
    370          
    371              The function retrieves number of bytes available in the intermediate buffer
    372              that were received over the Virtual COM Port.
    373          
    374              \return                      Number of bytes available for read.
    375           */
    376          

   \                                 In section .text, align 2, keep-with-next
    377          int32_t USBD_CDC_ACM_DataAvailable (void) {
    378            return (ptr_data_received - ptr_data_read);
   \                     USBD_CDC_ACM_DataAvailable: (+1)
   \   00000000   0x....             LDR      R0,??DataTable7_4
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x....             LDR      R1,??DataTable8
   \   00000006   0x6809             LDR      R1,[R1, #+0]
   \   00000008   0x1A40             SUBS     R0,R0,R1
   \   0000000A   0x4770             BX       LR               ;; return
    379          }
    380          
    381          
    382          /** \brief  Sends a notification of Virtual COM Port statuses and line states
    383          
    384              The function sends error and line status of the Virtual COM Port over the
    385              Interrupt endpoint. (SerialState notification is defined in usbcdc11.pdf, 6.3.5.)
    386          
    387              \param [in]         stat     Error and line statuses (
    388                                             6. bit - bOverRun,
    389                                             5. bit - bParity,
    390                                             4. bit - bFraming,
    391                                             3. bit - bRingSignal,
    392                                             2. bit - bBreak,
    393                                             1. bit - bTxCarrier (DSR line state),
    394                                             0. bit - bRxCarrier (DCD line status)).
    395              \return             0        Function failed.
    396              \return             1        Function succeeded.
    397           */
    398          

   \                                 In section .text, align 2, keep-with-next
    399          int32_t USBD_CDC_ACM_Notify (uint16_t stat) {
   \                     USBD_CDC_ACM_Notify: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    400          
    401            if (USBD_Configuration) {
   \   00000002   0x....             LDR      R1,??DataTable7_5
   \   00000004   0x7809             LDRB     R1,[R1, #+0]
   \   00000006   0x2900             CMP      R1,#+0
   \   00000008   0xD028             BEQ      ??USBD_CDC_ACM_Notify_0
    402              USBD_CDC_ACM_NotifyBuf[0] = 0xA1;   /* bmRequestType                      */
   \   0000000A   0x21A1             MOVS     R1,#+161
   \   0000000C   0x....             LDR      R2,??DataTable8_1
   \   0000000E   0x7011             STRB     R1,[R2, #+0]
    403              USBD_CDC_ACM_NotifyBuf[1] = CDC_NOTIFICATION_SERIAL_STATE;/* bNotification
   \   00000010   0x2120             MOVS     R1,#+32
   \   00000012   0x....             LDR      R2,??DataTable8_1
   \   00000014   0x7051             STRB     R1,[R2, #+1]
    404                                                    (SERIAL_STATE)                      */
    405              USBD_CDC_ACM_NotifyBuf[2] = 0x00;   /* wValue                             */
   \   00000016   0x2100             MOVS     R1,#+0
   \   00000018   0x....             LDR      R2,??DataTable8_1
   \   0000001A   0x7091             STRB     R1,[R2, #+2]
    406              USBD_CDC_ACM_NotifyBuf[3] = 0x00;
   \   0000001C   0x2100             MOVS     R1,#+0
   \   0000001E   0x....             LDR      R2,??DataTable8_1
   \   00000020   0x70D1             STRB     R1,[R2, #+3]
    407              USBD_CDC_ACM_NotifyBuf[4] = 0x00;   /* wIndex (Interface 0)               */
   \   00000022   0x2100             MOVS     R1,#+0
   \   00000024   0x....             LDR      R2,??DataTable8_1
   \   00000026   0x7111             STRB     R1,[R2, #+4]
    408              USBD_CDC_ACM_NotifyBuf[5] = 0x00;
   \   00000028   0x2100             MOVS     R1,#+0
   \   0000002A   0x....             LDR      R2,??DataTable8_1
   \   0000002C   0x7151             STRB     R1,[R2, #+5]
    409              USBD_CDC_ACM_NotifyBuf[6] = 0x02;   /* wLength                            */
   \   0000002E   0x2102             MOVS     R1,#+2
   \   00000030   0x....             LDR      R2,??DataTable8_1
   \   00000032   0x7191             STRB     R1,[R2, #+6]
    410              USBD_CDC_ACM_NotifyBuf[7] = 0x00;
   \   00000034   0x2100             MOVS     R1,#+0
   \   00000036   0x....             LDR      R2,??DataTable8_1
   \   00000038   0x71D1             STRB     R1,[R2, #+7]
    411              USBD_CDC_ACM_NotifyBuf[8] = stat>>0;/* UART State Bitmap                  */
   \   0000003A   0x0001             MOVS     R1,R0
   \   0000003C   0x....             LDR      R2,??DataTable8_1
   \   0000003E   0x7211             STRB     R1,[R2, #+8]
    412              USBD_CDC_ACM_NotifyBuf[9] = stat>>8;
   \   00000040   0xB280             UXTH     R0,R0
   \   00000042   0x0A00             LSRS     R0,R0,#+8
   \   00000044   0x....             LDR      R1,??DataTable8_1
   \   00000046   0x7248             STRB     R0,[R1, #+9]
    413          
    414                                                  /* Write notification to be sent      */
    415              USBD_WriteEP (usbd_cdc_acm_ep_intin | 0x80, USBD_CDC_ACM_NotifyBuf, 10);
   \   00000048   0x220A             MOVS     R2,#+10
   \   0000004A   0x....             LDR      R1,??DataTable8_1
   \   0000004C   0x....             LDR      R0,??DataTable10
   \   0000004E   0x7803             LDRB     R3,[R0, #+0]
   \   00000050   0x2080             MOVS     R0,#+128
   \   00000052   0x4318             ORRS     R0,R0,R3
   \   00000054   0x.... 0x....      BL       USBD_WriteEP
    416              return (1);
   \   00000058   0x2001             MOVS     R0,#+1
   \   0000005A   0xE000             B        ??USBD_CDC_ACM_Notify_1
    417            }
    418          
    419            return (0);
   \                     ??USBD_CDC_ACM_Notify_0: (+1)
   \   0000005C   0x2000             MOVS     R0,#+0
   \                     ??USBD_CDC_ACM_Notify_1: (+1)
   \   0000005E   0xBD02             POP      {R1,PC}          ;; return
    420          }
    421          
    422          
    423          /*----------------- USB CDC ACM communication event handlers -----------------*/
    424          
    425          /** \brief  Handle Reset Events
    426          
    427              The function handles Reset events.
    428           */
    429          

   \                                 In section .text, align 2, keep-with-next
    430          void USBD_CDC_ACM_Reset_Event (void) {
   \                     USBD_CDC_ACM_Reset_Event: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    431          
    432            USBD_CDC_ACM_Reset ();
   \   00000002   0x.... 0x....      BL       USBD_CDC_ACM_Reset
    433          }
   \   00000006   0xBD01             POP      {R0,PC}          ;; return
    434          
    435          
    436          /** \brief  Handle SOF Events
    437          
    438              The function handles Start Of Frame events. It checks if there is pending
    439              data on the Bulk Out endpoint and handles it
    440              (USBD_CDC_ACM_EP_BULKOUT_HandleData) if there is enough space in the
    441              intermediate receive buffer and it calls received function callback
    442              (USBD_CDC_ACM_DataReceived) it also activates data send over the Bulk In
    443              endpoint if there is data to be sent (USBD_CDC_ACM_EP_BULKIN_HandleData).
    444           */
    445          

   \                                 In section .text, align 2, keep-with-next
    446          void USBD_CDC_ACM_SOF_Event (void) {
   \                     USBD_CDC_ACM_SOF_Event: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    447          
    448            if ((!data_read_access)         &&    /* If not read active                 */
    449                (ptr_data_received == ptr_data_read) &&     /* If received and read
    450                                                               pointers point to same
    451                                                               the location             */
    452                (ptr_data_received != USBD_CDC_ACM_ReceiveBuf)) { /* and if receive
   \   00000002   0x....             LDR      R0,??DataTable8_2
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD119             BNE      ??USBD_CDC_ACM_SOF_Event_0
   \   0000000A   0x....             LDR      R0,??DataTable7_4
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0x....             LDR      R1,??DataTable8
   \   00000010   0x6809             LDR      R1,[R1, #+0]
   \   00000012   0x4288             CMP      R0,R1
   \   00000014   0xD113             BNE      ??USBD_CDC_ACM_SOF_Event_0
   \   00000016   0x....             LDR      R0,??DataTable7_4
   \   00000018   0x6800             LDR      R0,[R0, #+0]
   \   0000001A   0x....             LDR      R1,??DataTable9
   \   0000001C   0x4288             CMP      R0,R1
   \   0000001E   0xD00E             BEQ      ??USBD_CDC_ACM_SOF_Event_0
    453                                                               pointer does not already
    454                                                               point to the start of
    455                                                               the receive buffer       */
    456              data_read_access = 1;               /* Block access to read data          */
   \   00000020   0x2001             MOVS     R0,#+1
   \   00000022   0x....             LDR      R1,??DataTable8_2
   \   00000024   0x6008             STR      R0,[R1, #+0]
    457              ptr_data_received = USBD_CDC_ACM_ReceiveBuf;  /* Correct received pointer
   \   00000026   0x....             LDR      R0,??DataTable9
   \   00000028   0x....             LDR      R1,??DataTable7_4
   \   0000002A   0x6008             STR      R0,[R1, #+0]
    458                                                               to point to the start of
    459                                                               the receive buffer       */
    460              ptr_data_read     = USBD_CDC_ACM_ReceiveBuf;  /* Correct read pointer to
   \   0000002C   0x....             LDR      R0,??DataTable9
   \   0000002E   0x....             LDR      R1,??DataTable8
   \   00000030   0x6008             STR      R0,[R1, #+0]
    461                                                               point to the start of the
    462                                                               receive buffer           */
    463              data_no_space_for_receive  = 0;               /* There is space for
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0x....             LDR      R1,??DataTable10_1
   \   00000036   0x6008             STR      R0,[R1, #+0]
    464                                                               reception available      */
    465              data_read_access = 0;               /* Allow access to read data          */
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0x....             LDR      R1,??DataTable8_2
   \   0000003C   0x6008             STR      R0,[R1, #+0]
    466            }
    467            if (data_received_pending_pckts &&    /* If packets are pending             */
    468               (!data_read_access)          &&    /* and if not read active             */
    469               (!data_no_space_for_receive)) {    /* and if there is space to receive   */
   \                     ??USBD_CDC_ACM_SOF_Event_0: (+1)
   \   0000003E   0x....             LDR      R0,??DataTable10_2
   \   00000040   0x6800             LDR      R0,[R0, #+0]
   \   00000042   0x2800             CMP      R0,#+0
   \   00000044   0xD01B             BEQ      ??USBD_CDC_ACM_SOF_Event_1
   \   00000046   0x....             LDR      R0,??DataTable8_2
   \   00000048   0x6800             LDR      R0,[R0, #+0]
   \   0000004A   0x....             LDR      R1,??DataTable10_1
   \   0000004C   0x6809             LDR      R1,[R1, #+0]
   \   0000004E   0x4301             ORRS     R1,R1,R0
   \   00000050   0x2900             CMP      R1,#+0
   \   00000052   0xD114             BNE      ??USBD_CDC_ACM_SOF_Event_1
    470              data_read_access = 1;               /* Disable access to read data        */
   \   00000054   0x2001             MOVS     R0,#+1
   \   00000056   0x....             LDR      R1,??DataTable8_2
   \   00000058   0x6008             STR      R0,[R1, #+0]
    471              USBD_CDC_ACM_EP_BULKOUT_HandleData(); /* Handle received data             */
   \   0000005A   0x.... 0x....      BL       USBD_CDC_ACM_EP_BULKOUT_HandleData
    472              data_read_access = 0;               /* Enable access to read data         */
   \   0000005E   0x2000             MOVS     R0,#+0
   \   00000060   0x....             LDR      R1,??DataTable8_2
   \   00000062   0x6008             STR      R0,[R1, #+0]
    473              if (ptr_data_received != ptr_data_read)
   \   00000064   0x....             LDR      R0,??DataTable7_4
   \   00000066   0x6800             LDR      R0,[R0, #+0]
   \   00000068   0x....             LDR      R1,??DataTable8
   \   0000006A   0x6809             LDR      R1,[R1, #+0]
   \   0000006C   0x4288             CMP      R0,R1
   \   0000006E   0xD006             BEQ      ??USBD_CDC_ACM_SOF_Event_1
    474                USBD_CDC_ACM_DataReceived (ptr_data_received - ptr_data_read);  /* Call
   \   00000070   0x....             LDR      R0,??DataTable7_4
   \   00000072   0x6800             LDR      R0,[R0, #+0]
   \   00000074   0x....             LDR      R1,??DataTable8
   \   00000076   0x6809             LDR      R1,[R1, #+0]
   \   00000078   0x1A40             SUBS     R0,R0,R1
   \   0000007A   0x.... 0x....      BL       USBD_CDC_ACM_DataReceived
    475                                                     received callback                  */
    476            }
    477          
    478            if ((!data_send_access)         &&    /* If send data is not being accessed */
    479                (!data_send_active)         &&    /* and send is not active             */
    480                (data_to_send_wr-data_to_send_rd) /* and if there is data to be sent    */
    481          //&& ((control_line_state & 3) == 3)    /* and if DTR and RTS is 1            */
    482               ) {
   \                     ??USBD_CDC_ACM_SOF_Event_1: (+1)
   \   0000007E   0x....             LDR      R0,??DataTable10_3
   \   00000080   0x6800             LDR      R0,[R0, #+0]
   \   00000082   0x....             LDR      R1,??DataTable10_4
   \   00000084   0x6809             LDR      R1,[R1, #+0]
   \   00000086   0x4301             ORRS     R1,R1,R0
   \   00000088   0x2900             CMP      R1,#+0
   \   0000008A   0xD111             BNE      ??USBD_CDC_ACM_SOF_Event_2
   \   0000008C   0x....             LDR      R0,??DataTable6_1
   \   0000008E   0x6800             LDR      R0,[R0, #+0]
   \   00000090   0x....             LDR      R1,??DataTable6_2
   \   00000092   0x6809             LDR      R1,[R1, #+0]
   \   00000094   0x1A40             SUBS     R0,R0,R1
   \   00000096   0x2800             CMP      R0,#+0
   \   00000098   0xD00A             BEQ      ??USBD_CDC_ACM_SOF_Event_2
    483              data_send_access = 1;               /* Block access to send data          */
   \   0000009A   0x2001             MOVS     R0,#+1
   \   0000009C   0x....             LDR      R1,??DataTable10_3
   \   0000009E   0x6008             STR      R0,[R1, #+0]
    484              data_send_active = 1;               /* Start data sending                 */
   \   000000A0   0x2001             MOVS     R0,#+1
   \   000000A2   0x....             LDR      R1,??DataTable10_4
   \   000000A4   0x6008             STR      R0,[R1, #+0]
    485              USBD_CDC_ACM_EP_BULKIN_HandleData();/* Handle data to send                */
   \   000000A6   0x.... 0x....      BL       USBD_CDC_ACM_EP_BULKIN_HandleData
    486              data_send_access = 0;               /* Allow access to send data          */
   \   000000AA   0x2000             MOVS     R0,#+0
   \   000000AC   0x....             LDR      R1,??DataTable10_3
   \   000000AE   0x6008             STR      R0,[R1, #+0]
    487            }
    488          }
   \                     ??USBD_CDC_ACM_SOF_Event_2: (+1)
   \   000000B0   0xBD01             POP      {R0,PC}          ;; return
    489          
    490          
    491          /** \brief  Handle Interrupt In Endpoint Events
    492          
    493              The function handles Interrupt In endpoint events.
    494          
    495              \param [in]         event    Type of event (USBD_EVT_IN - input event).
    496           */
    497          

   \                                 In section .text, align 2, keep-with-next
    498          void USBD_CDC_ACM_EP_INTIN_Event (uint32_t event) {
    499          
    500            /* Notification will be loadad aynchronously and sent automatically upon
    501               Interrupt IN token reception                                             */
    502          }
   \                     USBD_CDC_ACM_EP_INTIN_Event: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    503          
    504          
    505          /** \brief  Handle Bulk Out Endpoint Received Data
    506          
    507              The function handles data received on the Bulk Out endpoint. It reads the
    508              received data to the receive intermediate buffer if there is enough space
    509              available.
    510           */
    511          

   \                                 In section .text, align 2, keep-with-next
    512          static void USBD_CDC_ACM_EP_BULKOUT_HandleData () {
   \                     USBD_CDC_ACM_EP_BULKOUT_HandleData: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    513            int32_t len_received;
    514          
    515            if ((usbd_cdc_acm_receivebuf_sz - (ptr_data_received - USBD_CDC_ACM_ReceiveBuf)) >= usbd_cdc_acm_maxpacketsize1[USBD_HighSpeed]) {
   \   00000002   0x....             LDR      R0,??DataTable10_5
   \   00000004   0x8800             LDRH     R0,[R0, #+0]
   \   00000006   0x....             LDR      R1,??DataTable7_4
   \   00000008   0x6809             LDR      R1,[R1, #+0]
   \   0000000A   0x....             LDR      R2,??DataTable9
   \   0000000C   0x1A89             SUBS     R1,R1,R2
   \   0000000E   0x1A40             SUBS     R0,R0,R1
   \   00000010   0x....             LDR      R1,??DataTable10_6
   \   00000012   0x....             LDR      R2,??DataTable10_7
   \   00000014   0x7812             LDRB     R2,[R2, #+0]
   \   00000016   0x2302             MOVS     R3,#+2
   \   00000018   0x435A             MULS     R2,R3,R2
   \   0000001A   0x5A89             LDRH     R1,[R1, R2]
   \   0000001C   0x4288             CMP      R0,R1
   \   0000001E   0xDB18             BLT      ??USBD_CDC_ACM_EP_BULKOUT_HandleData_0
    516                                                  /* If there is space for 1 max packet */
    517                                                  /* Read received packet to receive buf*/
    518              len_received       = USBD_ReadEP(usbd_cdc_acm_ep_bulkout, ptr_data_received);
   \   00000020   0x....             LDR      R0,??DataTable7_4
   \   00000022   0x6801             LDR      R1,[R0, #+0]
   \   00000024   0x....             LDR      R0,??DataTable10_8
   \   00000026   0x7800             LDRB     R0,[R0, #+0]
   \   00000028   0x.... 0x....      BL       USBD_ReadEP
    519              ptr_data_received += len_received;  /* Correct pointer to received data   */
   \   0000002C   0x....             LDR      R1,??DataTable7_4
   \   0000002E   0x6809             LDR      R1,[R1, #+0]
   \   00000030   0x1808             ADDS     R0,R1,R0
   \   00000032   0x....             LDR      R1,??DataTable7_4
   \   00000034   0x6008             STR      R0,[R1, #+0]
    520              if (data_received_pending_pckts &&  /* If packet was pending              */
    521                 !data_receive_int_access) {      /* and not interrupt access           */
   \   00000036   0x....             LDR      R0,??DataTable10_2
   \   00000038   0x6800             LDR      R0,[R0, #+0]
   \   0000003A   0x2800             CMP      R0,#+0
   \   0000003C   0xD015             BEQ      ??USBD_CDC_ACM_EP_BULKOUT_HandleData_1
   \   0000003E   0x....             LDR      R0,??DataTable10_9
   \   00000040   0x6800             LDR      R0,[R0, #+0]
   \   00000042   0x2800             CMP      R0,#+0
   \   00000044   0xD111             BNE      ??USBD_CDC_ACM_EP_BULKOUT_HandleData_1
    522                data_received_pending_pckts--;    /* Decrement pending packets number   */
   \   00000046   0x....             LDR      R0,??DataTable10_2
   \   00000048   0x6800             LDR      R0,[R0, #+0]
   \   0000004A   0x1E40             SUBS     R0,R0,#+1
   \   0000004C   0x....             LDR      R1,??DataTable10_2
   \   0000004E   0x6008             STR      R0,[R1, #+0]
   \   00000050   0xE00B             B        ??USBD_CDC_ACM_EP_BULKOUT_HandleData_1
    523              }
    524            } else {
    525              data_no_space_for_receive = 1;      /* There is no space in receive buffer
   \                     ??USBD_CDC_ACM_EP_BULKOUT_HandleData_0: (+1)
   \   00000052   0x2001             MOVS     R0,#+1
   \   00000054   0x....             LDR      R1,??DataTable10_1
   \   00000056   0x6008             STR      R0,[R1, #+0]
    526                                                     for the newly received data        */
    527              if (data_receive_int_access) {      /* If this access is from interrupt
   \   00000058   0x....             LDR      R0,??DataTable10_9
   \   0000005A   0x6800             LDR      R0,[R0, #+0]
   \   0000005C   0x2800             CMP      R0,#+0
   \   0000005E   0xD004             BEQ      ??USBD_CDC_ACM_EP_BULKOUT_HandleData_1
    528                                                     function                           */
    529                data_received_pending_pckts++;    /* then this is new unhandled packet  */
   \   00000060   0x....             LDR      R0,??DataTable10_2
   \   00000062   0x6800             LDR      R0,[R0, #+0]
   \   00000064   0x1C40             ADDS     R0,R0,#+1
   \   00000066   0x....             LDR      R1,??DataTable10_2
   \   00000068   0x6008             STR      R0,[R1, #+0]
    530              }
    531            }
    532          }
   \                     ??USBD_CDC_ACM_EP_BULKOUT_HandleData_1: (+1)
   \   0000006A   0xBD01             POP      {R0,PC}          ;; return
    533          
    534          
    535          /** \brief  Handle Bulk In Endpoint Data to Send
    536          
    537              The function handles data to be sent on the Bulk In endpoint. It transmits
    538              pending data to be sent that is already in the send intermediate buffer,
    539              and it also sends Zero Length Packet if last packet sent was not a short
    540              packet.
    541           */
    542          
    543          //-- static void USBD_CDC_ACM_EP_BULKIN_HandleData (void) {

   \                                 In section .text, align 2, keep-with-next
    544          static int32_t USBD_CDC_ACM_EP_BULKIN_HandleData (void) {
   \                     USBD_CDC_ACM_EP_BULKIN_HandleData: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    545            int32_t len_to_send, len_sent;
    546          
    547            if (!data_send_active)                /* If sending is not active           */
   \   00000002   0x....             LDR      R0,??DataTable10_4
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD101             BNE      ??USBD_CDC_ACM_EP_BULKIN_HandleData_0
    548              return 0;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0xE070             B        ??USBD_CDC_ACM_EP_BULKIN_HandleData_1
    549          
    550          
    551            len_to_send = data_to_send_wr - data_to_send_rd;  /* Num of data to send    */
   \                     ??USBD_CDC_ACM_EP_BULKIN_HandleData_0: (+1)
   \   0000000E   0x....             LDR      R0,??DataTable10_10
   \   00000010   0x6800             LDR      R0,[R0, #+0]
   \   00000012   0x....             LDR      R1,??DataTable10_11
   \   00000014   0x6809             LDR      R1,[R1, #+0]
   \   00000016   0x1A42             SUBS     R2,R0,R1
    552          
    553            /* Check if sending is finished                                             */
    554            if (!len_to_send    &&                /* If all data was sent               */
    555                !data_send_zlp)  {                /* and ZLP was sent if necessary also */
   \   00000018   0x....             LDR      R0,??DataTable10_12
   \   0000001A   0x6800             LDR      R0,[R0, #+0]
   \   0000001C   0x4310             ORRS     R0,R0,R2
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD104             BNE      ??USBD_CDC_ACM_EP_BULKIN_HandleData_2
    556              data_send_active = 0;               /* Sending not active any more        */
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0x....             LDR      R1,??DataTable10_4
   \   00000026   0x6008             STR      R0,[R1, #+0]
    557              return 1;
   \   00000028   0x2001             MOVS     R0,#+1
   \   0000002A   0xE061             B        ??USBD_CDC_ACM_EP_BULKIN_HandleData_1
    558            }
    559          
    560            /* Check if data needs to be sent                                           */
    561            if (len_to_send) {                    /* If there is data available do be
   \                     ??USBD_CDC_ACM_EP_BULKIN_HandleData_2: (+1)
   \   0000002C   0x2A00             CMP      R2,#+0
   \   0000002E   0xD024             BEQ      ??USBD_CDC_ACM_EP_BULKIN_HandleData_3
    562                                                     sent                               */
    563              if ((ptr_data_sent>=ptr_data_to_send) &&/* If data before end of buf avail*/
    564                  ((ptr_data_sent + len_to_send) >= (USBD_CDC_ACM_SendBuf + usbd_cdc_acm_sendbuf_sz))) {
   \   00000030   0x....             LDR      R0,??DataTable10_13
   \   00000032   0x6800             LDR      R0,[R0, #+0]
   \   00000034   0x....             LDR      R1,??DataTable10_14
   \   00000036   0x6809             LDR      R1,[R1, #+0]
   \   00000038   0x4288             CMP      R0,R1
   \   0000003A   0xD30F             BCC      ??USBD_CDC_ACM_EP_BULKIN_HandleData_4
   \   0000003C   0x....             LDR      R0,??DataTable10_13
   \   0000003E   0x6800             LDR      R0,[R0, #+0]
   \   00000040   0x1880             ADDS     R0,R0,R2
   \   00000042   0x....             LDR      R1,??DataTable10_15
   \   00000044   0x....             LDR      R3,??DataTable10_16
   \   00000046   0x881B             LDRH     R3,[R3, #+0]
   \   00000048   0x18C9             ADDS     R1,R1,R3
   \   0000004A   0x4288             CMP      R0,R1
   \   0000004C   0xD306             BCC      ??USBD_CDC_ACM_EP_BULKIN_HandleData_4
    565                                                  /* and if available data wraps around
    566                                                     the end of the send buffer         */
    567                                                  /* Correct bytes to send to data
    568                                                     available untill end of send buf   */
    569                len_to_send = USBD_CDC_ACM_SendBuf + usbd_cdc_acm_sendbuf_sz - ptr_data_sent;
   \   0000004E   0x....             LDR      R0,??DataTable10_15
   \   00000050   0x....             LDR      R1,??DataTable10_16
   \   00000052   0x8809             LDRH     R1,[R1, #+0]
   \   00000054   0x1840             ADDS     R0,R0,R1
   \   00000056   0x....             LDR      R1,??DataTable10_13
   \   00000058   0x6809             LDR      R1,[R1, #+0]
   \   0000005A   0x1A42             SUBS     R2,R0,R1
    570              }
    571          
    572              if (len_to_send > usbd_cdc_acm_maxpacketsize1[USBD_HighSpeed]) {  /* If
   \                     ??USBD_CDC_ACM_EP_BULKIN_HandleData_4: (+1)
   \   0000005C   0x....             LDR      R0,??DataTable10_6
   \   0000005E   0x....             LDR      R1,??DataTable10_7
   \   00000060   0x7809             LDRB     R1,[R1, #+0]
   \   00000062   0x2302             MOVS     R3,#+2
   \   00000064   0x4359             MULS     R1,R3,R1
   \   00000066   0x5A40             LDRH     R0,[R0, R1]
   \   00000068   0x4290             CMP      R0,R2
   \   0000006A   0xDA0B             BGE      ??USBD_CDC_ACM_EP_BULKIN_HandleData_5
    573                                                     there is more data to be sent then
    574                                                     can be sent in a single packet     */
    575                                                  /* Correct to send maximum pckt size  */
    576                len_to_send = usbd_cdc_acm_maxpacketsize1[USBD_HighSpeed];
   \   0000006C   0x....             LDR      R0,??DataTable10_6
   \   0000006E   0x....             LDR      R1,??DataTable10_7
   \   00000070   0x7809             LDRB     R1,[R1, #+0]
   \   00000072   0x2202             MOVS     R2,#+2
   \   00000074   0x4351             MULS     R1,R2,R1
   \   00000076   0x5A42             LDRH     R2,[R0, R1]
   \   00000078   0xE004             B        ??USBD_CDC_ACM_EP_BULKIN_HandleData_5
    577              }
    578            } else if (data_send_zlp) {           /* or if ZLP should be sent           */
   \                     ??USBD_CDC_ACM_EP_BULKIN_HandleData_3: (+1)
   \   0000007A   0x....             LDR      R0,??DataTable10_12
   \   0000007C   0x6800             LDR      R0,[R0, #+0]
   \   0000007E   0x2800             CMP      R0,#+0
   \   00000080   0xD000             BEQ      ??USBD_CDC_ACM_EP_BULKIN_HandleData_5
    579              len_to_send = 0;
   \   00000082   0x2200             MOVS     R2,#+0
    580            }
    581          
    582            data_send_zlp = 0;
   \                     ??USBD_CDC_ACM_EP_BULKIN_HandleData_5: (+1)
   \   00000084   0x2000             MOVS     R0,#+0
   \   00000086   0x....             LDR      R1,??DataTable10_12
   \   00000088   0x6008             STR      R0,[R1, #+0]
    583          
    584                                                  /* Send data                          */
    585            len_sent = USBD_WriteEP(usbd_cdc_acm_ep_bulkin | 0x80, ptr_data_sent, len_to_send);
   \   0000008A   0x....             LDR      R0,??DataTable10_13
   \   0000008C   0x6801             LDR      R1,[R0, #+0]
   \   0000008E   0x....             LDR      R0,??DataTable10_17
   \   00000090   0x7803             LDRB     R3,[R0, #+0]
   \   00000092   0x2080             MOVS     R0,#+128
   \   00000094   0x4318             ORRS     R0,R0,R3
   \   00000096   0x.... 0x....      BL       USBD_WriteEP
    586          
    587            ptr_data_sent    += len_sent;         /* Correct position of sent pointer   */
   \   0000009A   0x....             LDR      R1,??DataTable10_13
   \   0000009C   0x6809             LDR      R1,[R1, #+0]
   \   0000009E   0x1809             ADDS     R1,R1,R0
   \   000000A0   0x....             LDR      R2,??DataTable10_13
   \   000000A2   0x6011             STR      R1,[R2, #+0]
    588            data_to_send_rd  += len_sent;         /* Correct num of bytes left to send  */
   \   000000A4   0x....             LDR      R1,??DataTable10_11
   \   000000A6   0x6809             LDR      R1,[R1, #+0]
   \   000000A8   0x1809             ADDS     R1,R1,R0
   \   000000AA   0x....             LDR      R2,??DataTable10_11
   \   000000AC   0x6011             STR      R1,[R2, #+0]
    589            if (ptr_data_sent == USBD_CDC_ACM_SendBuf + usbd_cdc_acm_sendbuf_sz)
   \   000000AE   0x....             LDR      R1,??DataTable10_13
   \   000000B0   0x6809             LDR      R1,[R1, #+0]
   \   000000B2   0x....             LDR      R2,??DataTable10_15
   \   000000B4   0x....             LDR      R3,??DataTable10_16
   \   000000B6   0x881B             LDRH     R3,[R3, #+0]
   \   000000B8   0x18D2             ADDS     R2,R2,R3
   \   000000BA   0x4291             CMP      R1,R2
   \   000000BC   0xD102             BNE      ??USBD_CDC_ACM_EP_BULKIN_HandleData_6
    590                                                  /* If pointer to sent data wraps      */
    591              ptr_data_sent = USBD_CDC_ACM_SendBuf; /* Correct it to beginning of send
   \   000000BE   0x....             LDR      R1,??DataTable10_15
   \   000000C0   0x....             LDR      R2,??DataTable10_13
   \   000000C2   0x6011             STR      R1,[R2, #+0]
    592                                                     buffer                             */
    593            if ((data_to_send_wr == data_to_send_rd) &&   /* If there are no more
    594                                                     bytes available to be sent         */
    595                (len_sent == usbd_cdc_acm_maxpacketsize1[USBD_HighSpeed])) {
   \                     ??USBD_CDC_ACM_EP_BULKIN_HandleData_6: (+1)
   \   000000C4   0x....             LDR      R1,??DataTable10_10
   \   000000C6   0x6809             LDR      R1,[R1, #+0]
   \   000000C8   0x....             LDR      R2,??DataTable10_11
   \   000000CA   0x6812             LDR      R2,[R2, #+0]
   \   000000CC   0x4291             CMP      R1,R2
   \   000000CE   0xD10B             BNE      ??USBD_CDC_ACM_EP_BULKIN_HandleData_7
   \   000000D0   0x....             LDR      R1,??DataTable10_6
   \   000000D2   0x....             LDR      R2,??DataTable10_7
   \   000000D4   0x7812             LDRB     R2,[R2, #+0]
   \   000000D6   0x2302             MOVS     R3,#+2
   \   000000D8   0x435A             MULS     R2,R3,R2
   \   000000DA   0x5A89             LDRH     R1,[R1, R2]
   \   000000DC   0x4288             CMP      R0,R1
   \   000000DE   0xD103             BNE      ??USBD_CDC_ACM_EP_BULKIN_HandleData_7
    596                                                  /* If last packet size was same as
    597                                                     maximum packet size                */
    598              data_send_zlp = 1;                  /* ZLP packet should be sent          */
   \   000000E0   0x2001             MOVS     R0,#+1
   \   000000E2   0x....             LDR      R1,??DataTable10_12
   \   000000E4   0x6008             STR      R0,[R1, #+0]
   \   000000E6   0xE002             B        ??USBD_CDC_ACM_EP_BULKIN_HandleData_8
    599            } else {
    600              data_send_zlp = 0;                  /* No ZLP packet should be sent       */
   \                     ??USBD_CDC_ACM_EP_BULKIN_HandleData_7: (+1)
   \   000000E8   0x2000             MOVS     R0,#+0
   \   000000EA   0x....             LDR      R1,??DataTable10_12
   \   000000EC   0x6008             STR      R0,[R1, #+0]
    601            }
    602          	return 0;
   \                     ??USBD_CDC_ACM_EP_BULKIN_HandleData_8: (+1)
   \   000000EE   0x2000             MOVS     R0,#+0
   \                     ??USBD_CDC_ACM_EP_BULKIN_HandleData_1: (+1)
   \   000000F0   0xBD02             POP      {R1,PC}          ;; return
    603          }
    604          
    605          
    606          /** \brief  Handle Bulk Out Endpoint Events
    607          
    608              The function handles Bulk Out endpoint events. It calls
    609              USBD_CDC_ACM_EP_BULKOUT_HandleData function to handle received data
    610              unless data was being accessed in which case function just acknowledges
    611              that there is data to be handled later.
    612          
    613              \param [in]         event    Type of event (USBD_EVT_OUT - output event).
    614           */
    615          

   \                                 In section .text, align 2, keep-with-next
    616          void USBD_CDC_ACM_EP_BULKOUT_Event (uint32_t event) {
   \                     USBD_CDC_ACM_EP_BULKOUT_Event: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    617          
    618            if (data_read_access) {               /* If data is being accessed from
   \   00000002   0x....             LDR      R0,??DataTable10_18
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD005             BEQ      ??USBD_CDC_ACM_EP_BULKOUT_Event_0
    619                                                     read function                      */
    620              data_received_pending_pckts++;      /* 1 more packet received and not
   \   0000000A   0x....             LDR      R0,??DataTable10_2
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0x1C40             ADDS     R0,R0,#+1
   \   00000010   0x....             LDR      R1,??DataTable10_2
   \   00000012   0x6008             STR      R0,[R1, #+0]
    621                                                     handled                            */
    622              return;
   \   00000014   0xE01A             B        ??USBD_CDC_ACM_EP_BULKOUT_Event_1
    623            }
    624          
    625            data_read_access = 1;                 /* Block access to read data          */
   \                     ??USBD_CDC_ACM_EP_BULKOUT_Event_0: (+1)
   \   00000016   0x2001             MOVS     R0,#+1
   \   00000018   0x....             LDR      R1,??DataTable10_18
   \   0000001A   0x6008             STR      R0,[R1, #+0]
    626            data_receive_int_access = 1;          /* Read access from interrupt function*/
   \   0000001C   0x2001             MOVS     R0,#+1
   \   0000001E   0x....             LDR      R1,??DataTable10_9
   \   00000020   0x6008             STR      R0,[R1, #+0]
    627            USBD_CDC_ACM_EP_BULKOUT_HandleData ();/* Handle received data               */
   \   00000022   0x.... 0x....      BL       USBD_CDC_ACM_EP_BULKOUT_HandleData
    628            data_receive_int_access = 0;          /* Read access from interrupt func end*/
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0x....             LDR      R1,??DataTable10_9
   \   0000002A   0x6008             STR      R0,[R1, #+0]
    629            data_read_access = 0;                 /* Allow access to read data          */
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0x....             LDR      R1,??DataTable10_18
   \   00000030   0x6008             STR      R0,[R1, #+0]
    630            if (ptr_data_received != ptr_data_read)
   \   00000032   0x....             LDR      R0,??DataTable10_19
   \   00000034   0x6800             LDR      R0,[R0, #+0]
   \   00000036   0x....             LDR      R1,??DataTable10_20
   \   00000038   0x6809             LDR      R1,[R1, #+0]
   \   0000003A   0x4288             CMP      R0,R1
   \   0000003C   0xD006             BEQ      ??USBD_CDC_ACM_EP_BULKOUT_Event_2
    631              USBD_CDC_ACM_DataReceived (ptr_data_received - ptr_data_read);    /* Call
   \   0000003E   0x....             LDR      R0,??DataTable10_19
   \   00000040   0x6800             LDR      R0,[R0, #+0]
   \   00000042   0x....             LDR      R1,??DataTable10_20
   \   00000044   0x6809             LDR      R1,[R1, #+0]
   \   00000046   0x1A40             SUBS     R0,R0,R1
   \   00000048   0x.... 0x....      BL       USBD_CDC_ACM_DataReceived
    632                                                     received callback                  */
    633          }
   \                     ??USBD_CDC_ACM_EP_BULKOUT_Event_2: (+1)
   \                     ??USBD_CDC_ACM_EP_BULKOUT_Event_1: (+1)
   \   0000004C   0xBD01             POP      {R0,PC}          ;; return
    634          
    635          
    636          /** \brief  Handle Bulk In Endpoint Events
    637          
    638              The function handles Bulk In endpoint events. It calls
    639              USBD_CDC_ACM_EP_BULKIN_HandleData function to handle send data
    640              unless data was being accessed in which case function just returns.
    641          
    642              \param [in]         event    Type of event (USBD_EVT_IN - input event).
    643           */
    644          

   \                                 In section .text, align 2, keep-with-next
    645          void USBD_CDC_ACM_EP_BULKIN_Event (uint32_t event) {
   \                     USBD_CDC_ACM_EP_BULKIN_Event: (+1)
   \   00000000   0xB500             PUSH     {LR}
    646          
    647              if ( data_send_active == 1 ) {
   \   00000002   0x....             LDR      R0,??DataTable10_4
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x2801             CMP      R0,#+1
   \   00000008   0xD102             BNE      ??USBD_CDC_ACM_EP_BULKIN_Event_0
    648                  data_send_ACK_rev = 1;
   \   0000000A   0x2001             MOVS     R0,#+1
   \   0000000C   0x....             LDR      R1,??DataTable10_21
   \   0000000E   0x7008             STRB     R0,[R1, #+0]
    649              }
    650          
    651              return ;
   \                     ??USBD_CDC_ACM_EP_BULKIN_Event_0: (+1)
   \   00000010   0xBD00             POP      {PC}             ;; return
    652          
    653          //+++---------------------------------------------------------------------
    654          //--   if (data_send_access                  /* If send data is being accessed     */
    655          //-- // ||((control_line_state & 3) != 3)    /* or if DTR or RTS is 0              */
    656          //--     ) {
    657          //--     return;
    658          //--   }
    659          //-- 
    660          //--   data_send_access = 1;                 /* Block access to send data          */
    661          //--   USBD_CDC_ACM_EP_BULKIN_HandleData (); /* Handle data to send                */
    662          //--   data_send_access = 0;                 /* Allow access to send data          */
    663          //+++---------------------------------------------------------------------
    664          }
    665          
    666          
    667          /** \brief  Handle Bulk In/Out Endpoint Events
    668          
    669              The function handles Bulk In/Out endpoint events. It is used for endpoints
    670              that do In and Out functionality on the same endpoint number. It dispatches
    671              events to appropriate In or Out event handlers.
    672          
    673              \param [in]         event    Type of event (
    674                                             USBD_EVT_IN  - input event,
    675                                             USBD_EVT_OUT - output event).
    676           */
    677          

   \                                 In section .text, align 2, keep-with-next
    678          void USBD_CDC_ACM_EP_BULK_Event (uint32_t event) {
   \                     USBD_CDC_ACM_EP_BULK_Event: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    679            if (event & USBD_EVT_OUT) {
   \   00000004   0x0760             LSLS     R0,R4,#+29
   \   00000006   0xD502             BPL      ??USBD_CDC_ACM_EP_BULK_Event_0
    680              USBD_CDC_ACM_EP_BULKOUT_Event (event);
   \   00000008   0x0020             MOVS     R0,R4
   \   0000000A   0x.... 0x....      BL       USBD_CDC_ACM_EP_BULKOUT_Event
    681            }
    682            if (event & USBD_EVT_IN) {
   \                     ??USBD_CDC_ACM_EP_BULK_Event_0: (+1)
   \   0000000E   0x0720             LSLS     R0,R4,#+28
   \   00000010   0xD502             BPL      ??USBD_CDC_ACM_EP_BULK_Event_1
    683              USBD_CDC_ACM_EP_BULKIN_Event (event);
   \   00000012   0x0020             MOVS     R0,R4
   \   00000014   0x.... 0x....      BL       USBD_CDC_ACM_EP_BULKIN_Event
    684            }
    685          }
   \                     ??USBD_CDC_ACM_EP_BULK_Event_1: (+1)
   \   00000018   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6:
   \   00000000   0x........         DC32     usbd_cdc_acm_sendbuf_sz

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_1:
   \   00000000   0x........         DC32     data_to_send_wr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_2:
   \   00000000   0x........         DC32     data_to_send_rd

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7:
   \   00000000   0x........         DC32     ptr_data_to_send

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_1:
   \   00000000   0x........         DC32     ptr_data_sent

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_2:
   \   00000000   0x........         DC32     USBD_CDC_ACM_SendBuf

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_3:
   \   00000000   0x........         DC32     data_send_ACK_rev

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_4:
   \   00000000   0x........         DC32     ptr_data_received

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_5:
   \   00000000   0x........         DC32     USBD_Configuration

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \   00000000   0x........         DC32     ptr_data_read

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_1:
   \   00000000   0x........         DC32     USBD_CDC_ACM_NotifyBuf

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_2:
   \   00000000   0x........         DC32     data_read_access

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \   00000000   0x........         DC32     USBD_CDC_ACM_ReceiveBuf

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \   00000000   0x........         DC32     usbd_cdc_acm_ep_intin

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_1:
   \   00000000   0x........         DC32     data_no_space_for_receive

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_2:
   \   00000000   0x........         DC32     data_received_pending_pckts

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_3:
   \   00000000   0x........         DC32     data_send_access

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_4:
   \   00000000   0x........         DC32     data_send_active

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_5:
   \   00000000   0x........         DC32     usbd_cdc_acm_receivebuf_sz

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_6:
   \   00000000   0x........         DC32     usbd_cdc_acm_maxpacketsize1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_7:
   \   00000000   0x........         DC32     USBD_HighSpeed

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_8:
   \   00000000   0x........         DC32     usbd_cdc_acm_ep_bulkout

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_9:
   \   00000000   0x........         DC32     data_receive_int_access

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_10:
   \   00000000   0x........         DC32     data_to_send_wr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_11:
   \   00000000   0x........         DC32     data_to_send_rd

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_12:
   \   00000000   0x........         DC32     data_send_zlp

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_13:
   \   00000000   0x........         DC32     ptr_data_sent

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_14:
   \   00000000   0x........         DC32     ptr_data_to_send

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_15:
   \   00000000   0x........         DC32     USBD_CDC_ACM_SendBuf

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_16:
   \   00000000   0x........         DC32     usbd_cdc_acm_sendbuf_sz

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_17:
   \   00000000   0x........         DC32     usbd_cdc_acm_ep_bulkin

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_18:
   \   00000000   0x........         DC32     data_read_access

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_19:
   \   00000000   0x........         DC32     ptr_data_received

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_20:
   \   00000000   0x........         DC32     ptr_data_read

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_21:
   \   00000000   0x........         DC32     data_send_ACK_rev
    686          
    687          
    688          #ifdef __RTX                            /* RTX tasks for handling events      */
    689          
    690          /** \brief  Task Handling Interrupt In Endpoint Events
    691          
    692              The task dispatches Interrupt In events to the Interrupt In handling
    693              function (USBD_CDC_ACM_EP_INTIN_Event).
    694           */
    695          
    696          __task void USBD_RTX_CDC_ACM_EP_INTIN_Event (void) {
    697          
    698            if (__rtx) {
    699              for (;;) {
    700                usbd_os_evt_wait_or (0xFFFF, 0xFFFF);
    701                USBD_CDC_ACM_EP_INTIN_Event (usbd_os_evt_get());
    702              }
    703            }
    704          }
    705          
    706          
    707          /** \brief  Task Handling Bulk In Endpoint Events
    708          
    709              The task dispatches Bulk In events to the Bulk In handling
    710              function (USBD_CDC_ACM_EP_BULKIN_Event).
    711           */
    712          
    713          __task void USBD_RTX_CDC_ACM_EP_BULKIN_Event (void) {
    714          
    715            if (__rtx) {
    716              for (;;) {
    717                usbd_os_evt_wait_or (0xFFFF, 0xFFFF);
    718                if (usbd_os_evt_get() & USBD_EVT_IN) {
    719                  USBD_CDC_ACM_EP_BULKIN_Event (0);
    720                }
    721              }
    722            }
    723          }
    724          
    725          
    726          /** \brief  Task Handling Bulk Out Endpoint Events
    727          
    728              The task dispatches Bulk Out events to the Bulk Out handling
    729              function (USBD_CDC_ACM_EP_BULKOUT_Event).
    730           */
    731          
    732          __task void USBD_RTX_CDC_ACM_EP_BULKOUT_Event (void) {
    733          
    734            if (__rtx) {
    735              for (;;) {
    736                usbd_os_evt_wait_or (0xFFFF, 0xFFFF);
    737                if (usbd_os_evt_get() & USBD_EVT_OUT) {
    738                  USBD_CDC_ACM_EP_BULKOUT_Event (0);
    739                }
    740              }
    741            }
    742          }
    743          
    744          
    745          /** \brief  Task Handling Bulk In/Out Endpoint Events
    746          
    747              The task dispatches Bulk In/Out events to the Bulk In/Out handling
    748              function (USBD_CDC_ACM_EP_BULK_Event).
    749           */
    750          
    751          __task void USBD_RTX_CDC_ACM_EP_BULK_Event (void) {
    752          
    753            if (__rtx) {
    754              for (;;) {
    755                usbd_os_evt_wait_or (0xFFFF, 0xFFFF);
    756                USBD_CDC_ACM_EP_BULK_Event (usbd_os_evt_get());
    757              }
    758            }
    759          }
    760          #endif
    761          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   USBD_CDC_ACM_ClearCommFeature
       0   USBD_CDC_ACM_DataAvailable
       0   USBD_CDC_ACM_DataFree
      16   USBD_CDC_ACM_DataRead
        16   -> __aeabi_memcpy
       0   USBD_CDC_ACM_DataReceived
      24   USBD_CDC_ACM_DataSend
        24   -> __aeabi_memcpy
       4   USBD_CDC_ACM_EP_BULKIN_Event
       8   USBD_CDC_ACM_EP_BULKIN_HandleData
         8   -> USBD_WriteEP
       8   USBD_CDC_ACM_EP_BULKOUT_Event
         8   -> USBD_CDC_ACM_DataReceived
         8   -> USBD_CDC_ACM_EP_BULKOUT_HandleData
       8   USBD_CDC_ACM_EP_BULKOUT_HandleData
         8   -> USBD_ReadEP
       8   USBD_CDC_ACM_EP_BULK_Event
         8   -> USBD_CDC_ACM_EP_BULKIN_Event
         8   -> USBD_CDC_ACM_EP_BULKOUT_Event
       0   USBD_CDC_ACM_EP_INTIN_Event
       8   USBD_CDC_ACM_GetChar
         8   -> USBD_CDC_ACM_DataRead
       0   USBD_CDC_ACM_GetCommFeature
       0   USBD_CDC_ACM_GetEncapsulatedResponse
       8   USBD_CDC_ACM_GetLineCoding
         8   -> USBD_CDC_ACM_PortGetLineCoding
       8   USBD_CDC_ACM_Initialize
         8   -> USBD_CDC_ACM_PortInitialize
       8   USBD_CDC_ACM_Notify
         8   -> USBD_WriteEP
       0   USBD_CDC_ACM_PortGetLineCoding
       0   USBD_CDC_ACM_PortInitialize
       0   USBD_CDC_ACM_PortReset
       0   USBD_CDC_ACM_PortSetControlLineState
       0   USBD_CDC_ACM_PortSetLineCoding
       0   USBD_CDC_ACM_PortUninitialize
       8   USBD_CDC_ACM_PutChar
         8   -> USBD_CDC_ACM_DataSend
       8   USBD_CDC_ACM_Reset
         8   -> USBD_CDC_ACM_PortReset
         8   -> USBD_CDC_ACM_PortSetLineCoding
       8   USBD_CDC_ACM_Reset_Event
         8   -> USBD_CDC_ACM_Reset
       8   USBD_CDC_ACM_SOF_Event
         8   -> USBD_CDC_ACM_DataReceived
         8   -> USBD_CDC_ACM_EP_BULKIN_HandleData
         8   -> USBD_CDC_ACM_EP_BULKOUT_HandleData
       0   USBD_CDC_ACM_SendBreak
       0   USBD_CDC_ACM_SendEncapsulatedCommand
       0   USBD_CDC_ACM_SetCommFeature
       8   USBD_CDC_ACM_SetControlLineState
         8   -> USBD_CDC_ACM_PortSetControlLineState
       8   USBD_CDC_ACM_SetLineCoding
         8   -> USBD_CDC_ACM_PortSetLineCoding
       8   USBD_CDC_ACM_Uninitialization
         8   -> USBD_CDC_ACM_PortUninitialize
       8   USBD_CDC_ACM_WaitSendCompletion
         8   -> USBD_CDC_ACM_EP_BULKIN_HandleData


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
       4  ??DataTable10_1
       4  ??DataTable10_10
       4  ??DataTable10_11
       4  ??DataTable10_12
       4  ??DataTable10_13
       4  ??DataTable10_14
       4  ??DataTable10_15
       4  ??DataTable10_16
       4  ??DataTable10_17
       4  ??DataTable10_18
       4  ??DataTable10_19
       4  ??DataTable10_2
       4  ??DataTable10_20
       4  ??DataTable10_21
       4  ??DataTable10_3
       4  ??DataTable10_4
       4  ??DataTable10_5
       4  ??DataTable10_6
       4  ??DataTable10_7
       4  ??DataTable10_8
       4  ??DataTable10_9
       4  ??DataTable6
       4  ??DataTable6_1
       4  ??DataTable6_2
       4  ??DataTable7
       4  ??DataTable7_1
       4  ??DataTable7_2
       4  ??DataTable7_3
       4  ??DataTable7_4
       4  ??DataTable7_5
       4  ??DataTable8
       4  ??DataTable8_1
       4  ??DataTable8_2
       4  ??DataTable9
       4  USBD_CDC_ACM_ClearCommFeature
      12  USBD_CDC_ACM_DataAvailable
      18  USBD_CDC_ACM_DataFree
      64  USBD_CDC_ACM_DataRead
       4  USBD_CDC_ACM_DataReceived
     150  USBD_CDC_ACM_DataSend
      18  USBD_CDC_ACM_EP_BULKIN_Event
     242  USBD_CDC_ACM_EP_BULKIN_HandleData
      78  USBD_CDC_ACM_EP_BULKOUT_Event
     108  USBD_CDC_ACM_EP_BULKOUT_HandleData
      26  USBD_CDC_ACM_EP_BULK_Event
       2  USBD_CDC_ACM_EP_INTIN_Event
      26  USBD_CDC_ACM_GetChar
       4  USBD_CDC_ACM_GetCommFeature
       4  USBD_CDC_ACM_GetEncapsulatedResponse
      92  USBD_CDC_ACM_GetLineCoding
       8  USBD_CDC_ACM_Initialize
      96  USBD_CDC_ACM_Notify
       4  USBD_CDC_ACM_PortGetLineCoding
       4  USBD_CDC_ACM_PortInitialize
       4  USBD_CDC_ACM_PortReset
       4  USBD_CDC_ACM_PortSetControlLineState
       4  USBD_CDC_ACM_PortSetLineCoding
       4  USBD_CDC_ACM_PortUninitialize
      26  USBD_CDC_ACM_PutChar
     204  USBD_CDC_ACM_Reset
       8  USBD_CDC_ACM_Reset_Event
     178  USBD_CDC_ACM_SOF_Event
       4  USBD_CDC_ACM_SendBreak
       4  USBD_CDC_ACM_SendEncapsulatedCommand
       4  USBD_CDC_ACM_SetCommFeature
      20  USBD_CDC_ACM_SetControlLineState
      76  USBD_CDC_ACM_SetLineCoding
       8  USBD_CDC_ACM_Uninitialization
      26  USBD_CDC_ACM_WaitSendCompletion
       2  control_line_state
       4  data_no_space_for_receive
       4  data_read_access
       4  data_receive_int_access
       4  data_received_pending_pckts
       1  data_send_ACK_rev
       4  data_send_access
       4  data_send_active
       4  data_send_zlp
       4  data_to_send_rd
       4  data_to_send_wr
       8  line_coding
       4  ptr_data_read
       4  ptr_data_received
       4  ptr_data_sent
       4  ptr_data_to_send

 
    63 bytes in section .bss
 1 678 bytes in section .text
 
 1 218 bytes of CODE memory (+ 460 bytes shared)
    63 bytes of DATA memory

Errors: none
Warnings: none
