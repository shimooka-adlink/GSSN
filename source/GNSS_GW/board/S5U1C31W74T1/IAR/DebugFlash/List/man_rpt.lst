###############################################################################
#
# IAR ANSI C/C++ Compiler V7.80.4.12462/W32 for ARM       21/May/2019  17:01:03
# Copyright 1999-2017 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  C:\GNSS\Software\rJ105\source\GNSS_GW\apl\man_rpt.c
#    Command line =  
#        C:\GNSS\Software\rJ105\source\GNSS_GW\apl\man_rpt.c -D
#        __TARGET_ARCH_7_M -D S1C31W74 -D GNSS_GW_SIDE_A -lCN
#        C:\GNSS\Software\rJ105\source\GNSS_GW\board\S5U1C31W74T1\IAR\DebugFlash\List
#        -lA
#        C:\GNSS\Software\rJ105\source\GNSS_GW\board\S5U1C31W74T1\IAR\DebugFlash\List
#        --diag_suppress Pe177,Pe111,Pa082 -o
#        C:\GNSS\Software\rJ105\source\GNSS_GW\board\S5U1C31W74T1\IAR\DebugFlash\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M0+ -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.5\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\GNSS\Software\rJ105\source\GNSS_GW\board\S5U1C31W74T1\IAR\ -I
#        C:\GNSS\Software\rJ105\source\GNSS_GW\board\S5U1C31W74T1\IAR\..\..\..\
#        -I "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.5\arm\CMSIS\Include\" -I "C:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 7.5\arm\inc\Epson\" -I
#        C:\GNSS\Software\rJ105\source\GNSS_GW\board\S5U1C31W74T1\IAR\..\..\..\..\..\CMSIS\Device\S1C31W74\Include\
#        -I
#        C:\GNSS\Software\rJ105\source\GNSS_GW\board\S5U1C31W74T1\IAR\..\..\..\..\..\CMSIS\Driver\Include\
#        -I
#        C:\GNSS\Software\rJ105\source\GNSS_GW\board\S5U1C31W74T1\IAR\..\..\..\..\..\sePeriphLibrary\
#        -I
#        C:\GNSS\Software\rJ105\source\GNSS_GW\board\S5U1C31W74T1\IAR\..\..\..\..\..\board\S5U1C31W74T1\
#        -I
#        C:\GNSS\Software\rJ105\source\GNSS_GW\board\S5U1C31W74T1\IAR\..\..\..\..\..\USBStack\INC\
#        -I
#        C:\GNSS\Software\rJ105\source\GNSS_GW\board\S5U1C31W74T1\IAR\..\..\..\include\
#        -Ol
#    Locale       =  Japanese_Japan.932
#    List file    =  
#        C:\GNSS\Software\rJ105\source\GNSS_GW\board\S5U1C31W74T1\IAR\DebugFlash\List\man_rpt.lst
#    Object file  =  
#        C:\GNSS\Software\rJ105\source\GNSS_GW\board\S5U1C31W74T1\IAR\DebugFlash\Obj\man_rpt.o
#
###############################################################################

C:\GNSS\Software\rJ105\source\GNSS_GW\apl\man_rpt.c
      1          
      2          /**
      3            ******************************************************************************
      4            * @file    man_rpt.c
      5            * @author  コア
      6            * @version V1.0
      7            * @date    2017.10.2
      8            * @brief   レポートを管理する
      9            ******************************************************************************
     10            $Id: man_rpt.c 208 2018-06-29 01:00:30Z shitaoka $
     11            * @attention
     12            *
     13            *****************************************************************************
     14          */
     15          
     16          #include <string.h>
     17          #include <stdio.h>
     18          #include <stdlib.h>
     19          #include <time.h>
     20          
     21          #include "board.h"
     22          
     23          #include "gnss_gw_common.h"
     24          #include "man_http.h"
     25          #include "man_data.h"
     26          #include "man_msg.h"
     27          #include "man_rpt.h"
     28          #include "man_usb.h"
     29          #include "man_rtc.h"
     30          #include "man_error.h"
     31          #include "man_gps.h"
     32          #include "man_timer.h"
     33          
     34          
     35          #pragma section = "APL_PRG_BLOCK"
     36          
     37          /************************************************************************/
     38          /* declaration of structure                                             */
     39          /************************************************************************/
     40          
     41          
     42          #define	MAN_RPT_RETRY_MAX			1				// HTTPコマンドのリトライ回数
     43          
     44          #define	MAN_RPT_CLOSE_DURATION		5				// run_interval - duration_time_num が5秒未満の場合はCLOSEを行わない
     45          
     46          // レポート管理出力モード
     47          typedef enum {
     48          	MAN_RPT_SEND_START,				    // 出力開始
     49          	MAN_RPT_SEND_STOP,			    	// 出力停止
     50          } man_rpt_send_def;
     51          
     52          // 出力先管理
     53          typedef enum {
     54          	MAN_RPT_SEL_UDP,				    // UDPに出力
     55          	MAN_RPT_SEL_USB,			    	// USBに出力
     56          } man_rpt_sel_def;
     57          
     58          // レポート管理モード
     59          typedef enum {
     60          	MAN_RPT_MODE_STOP,				    // レポート報告停止(NET CLOSE)
     61          	MAN_RPT_MODE_START,			    	// レポート報告開始(NET OPEN)
     62          } man_rpt_mode_def;
     63          
     64          // 0Vレポートモード
     65          typedef enum {
     66          	MAN_RPT_0VMODE_OFF,					// 通常モード
     67          	MAN_RPT_0VMODE_ON,					// 0Vモード(park_interval使用)
     68          } man_rpt_mode0v_def;
     69          
     70          
     71          // レポート管理シーケンス
     72          typedef enum {
     73          	MAN_RPT_SEQ_READY,					// 00 : 要求待ち
     74          	
     75          	MAN_RPT_SEQ_OPEN_UDP_REQ,			// 01 : OPEN UDP開始
     76          	MAN_RPT_SEQ_OPEN_UDP,				// 02 : OPEN UDP中
     77          	MAN_RPT_SEQ_OPEN_UDP_OK,			// 03 : OPEN UDP完了
     78          	MAN_RPT_SEQ_OPEN_UDP_NG,			// 04 : OPEN UDP異常
     79          
     80          	MAN_RPT_SEQ_CLOSE_UDP_REQ,			// 05 : CLOSE UDP要求
     81          	MAN_RPT_SEQ_CLOSE_UDP,				// 06 : CLOSE UDP中
     82          	MAN_RPT_SEQ_CLOSE_UDP_OK,			// 07 : CLOSE UDP完了
     83          	MAN_RPT_SEQ_CLOSE_UDP_NG,			// 08 : CLOSE UDP異常
     84          
     85          	MAN_RPT_SEQ_SEND1_UDP_REQ,			// 09 : SEND1 UDP要求
     86          	MAN_RPT_SEQ_SEND1_UDP,				// 10 : SEND1 UDP
     87          	MAN_RPT_SEQ_SEND1_UDP_OK,			// 11 : SEND1 UDP完了
     88          	MAN_RPT_SEQ_SEND1_UDP_NG,			// 12 : SEND1 UDP異常
     89          	MAN_RPT_SEQ_SEND2_UDP,				// 13 : SEND2 UDP
     90          	MAN_RPT_SEQ_SEND2_UDP_OK,			// 14 : SEND2 UDP完了
     91          	MAN_RPT_SEQ_SEND2_UDP_NG,			// 15 : SEND2 UDP異常
     92          	
     93          	MAN_RPT_SEQ_SEND1_USB_REQ,			// 16 : SEND1 USB要求
     94          	MAN_RPT_SEQ_SEND1_USB,				// 17 : SEND1 USB
     95          	MAN_RPT_SEQ_SEND1_USB_OK,			// 18 : SEND1 USB完了
     96          	MAN_RPT_SEQ_SEND1_USB_NG,			// 19 : SEND1 USB異常
     97          	MAN_RPT_SEQ_SEND2_USB,				// 20 : SEND2 USB
     98          	MAN_RPT_SEQ_SEND2_USB_OK,			// 21 : SEND2 USB完了
     99          	MAN_RPT_SEQ_SEND2_USB_NG,			// 22 : SEND2 USB異常
    100          	MAN_RPT_SEQ_ERROR,					// 23 : 異常状態
    101          	MAN_RPT_SEQ_ERROR_WAIT,				// 24 : 異常解除待ち
    102          } man_rpt_seq_def;
    103          
    104          #define	MAN_RPT_NOTI_STATE		1000
    105          
    106          
    107          // サイクル管理シーケンス
    108          #define	MAN_RPT_CYCLE_REQ_READY		0x00	// 要求待ち
    109          #define	MAN_RPT_CYCLE_REQ_SEND		0x01	// 送信
    110          #define	MAN_RPT_CYCLE_REQ_CLOSE		0x02	// CLOSE
    111          
    112          #define	MAN_RPT_CYCLE_REQ_USB_SEND	0x03	// USB送信
    113          
    114          
    115          // 要求
    116          #define	MAN_RPT_REQ_CMD_READY		0		// 要求待ち
    117          #define	MAN_RPT_REQ_CMD_CLOSE		1		// CLOSE
    118          
    119          
    120          // 要求
    121          typedef struct _man_rpt_req_info_t {
    122          	int32_t					req_cmd;	// 要求
    123          	int32_t					id;					// ユニークID
    124          	func_man_rpt			callback;			// 結果を通知するcallback関数
    125          } man_rpt_req_info_t;
    126          
    127          // 要求に対する応答
    128          typedef struct _man_rpt_resp_cmd_t {
    129          	int32_t					flag;
    130          	int32_t					id;
    131          	int32_t					status;
    132          } man_rpt_resp_cmd_t;
    133          
    134          typedef struct _man_rpt_body_data_t {
    135          	uint8_t					data[MAN_DATA_BODY_SIZE];
    136          	int32_t					data_len;
    137          } man_rpt_body_data_t;
    138          
    139          typedef struct _man_rpt_info2_data_t {
    140          	uint8_t					data[MAN_DATA_INFO_SIZE];
    141          	int32_t					data_len;
    142          } man_rpt_info2_data_t;
    143          
    144          typedef struct _man_rpt_info1_data_t {
    145          	uint8_t					data[MAN_DATA_INFO_SIZE+MAN_DATA_NMEA_MAX];
    146          	int32_t					data_len;
    147          } man_rpt_info1_data_t;
    148          
    149          typedef struct _man_rpt_rpt1_data_t {
    150          	uint8_t					data[MAN_DATA_HTTP_SIZE+MAN_DATA_NMEA_MAX];
    151          	int32_t					data_len;
    152          } man_rpt_rpt1_data_t;
    153          
    154          typedef struct _man_rpt_rpt2_data_t {
    155          	uint8_t					data[MAN_DATA_HTTP_SIZE];
    156          	int32_t					data_len;
    157          } man_rpt_rpt2_data_t;
    158          
    159          // GPS測位結果出力サイクル管理情報
    160          typedef struct _man_rpt_cycle_info_t {
    161          	man_data_num_gpssleeptime_t	setting;	// GPS測位結果出力サイクル設定情報
    162          	int32_t					charge0_mode;	// 0V (1: 0V, 0: 0V以上)
    163          
    164          	uint32_t				send_counter;	// RPT送信数
    165          	uint32_t				counter;		// counter
    166          	uint32_t				park_counter;	// park用 counter
    167          
    168          	man_rpt_mode0v_def		mode0v;			// 0Vレポートモード
    169          	uint32_t				mode0v_timer;	// ５分カウントタイマー
    170          } man_rpt_cycle_info_t;
    171          
    172          
    173          // 異常状態通知先情報
    174          typedef struct _man_rpt_error_info_t {
    175          	int32_t					id;					// ユニークID
    176          	func_man_rpt			callback_error;		// 異常を通知するcallback関数
    177          } man_rpt_error_info_t;
    178          
    179          // レポート管理ワーク
    180          typedef struct _man_rpt_work_t {
    181          	man_rpt_seq_def			seq_log[100];	// シーケンスログ
    182          	int32_t					seq_wp;
    183          
    184          	man_rpt_sel_def			select;			// 出力先指定
    185          	man_rpt_mode_def		udp_mode;		// UDPモード
    186          	man_rpt_mode_def		usb_mode;		// USBモード
    187          	man_rpt_send_def		send_mode;		// 出力モード
    188          	man_rpt_udp_sts_def		udp_sts;		// UDPの状態
    189          	int32_t					trans_mode;		// UDP送信状態
    190          	man_rpt_seq_def			sequense;		// シーケンス
    191          	man_rpt_req_info_t		request;		// 要求
    192          	int32_t					retry;			// リトライカウンタ
    193          	uint32_t				delay_timer;	// 時間監視
    194          
    195          	int32_t					req_state;		// NETWORKの状態
    196          	man_data_rssi_sts_def	rssi_sts;		// 電波状況(圏内/圏外)
    197          
    198          	man_rpt_error_info_t	noti_error;		// 異常状態通知先情報
    199          
    200          	man_rpt_cycle_info_t	cycle_info;	// GPS測位結果出力サイクル管理情報
    201          	uint32_t				cycle_req;
    202          
    203          	man_rpt_resp_cmd_t		resp_cmd;	// 要求に対する応答
    204          	man_rpt_body_data_t		body1;		// body用(LTE1;...)
    205          	man_rpt_body_data_t		body2;		// body用(LTE1;...)
    206          	man_rpt_info1_data_t	info1;		// info用(NMEAデータ, 設定データ)
    207          	man_rpt_info2_data_t	info2;		// info用(NMEAデータ, 設定データ)
    208          
    209          	man_rpt_rpt1_data_t		rpt_buff1;	// 送信用(body + info)
    210          	man_rpt_rpt2_data_t		rpt_buff2;	// 送信用(body + info)
    211          
    212          	uint8_t					buff[100];
    213          } man_rpt_work_t;
    214          
    215          /************************************************************************/
    216          /* definition of variables                                              */
    217          /************************************************************************/
    218          

   \                                 In section .bss, align 4
    219          man_rpt_work_t	man_rpt_work;
   \                     man_rpt_work:
   \   00000000                      DS8 5816
    220          
    221          
    222          
    223          
    224          /********************************************************************/
    225          /*	callback関数                                                    */
    226          /********************************************************************/
    227          
    228          /********************************************************************/
    229          /*!
    230           * \name	man_rpt_req_callback
    231           * \brief	要求に対するcallback処理
    232           * \param	id     : ユニークID
    233           *          status : 受信結果
    234           * \return  なし
    235           * \note	
    236           */
    237          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    238          static void man_rpt_req_callback(int32_t id, int32_t status)
    239          {
    240          	man_rpt_work.resp_cmd.flag = 1;
   \                     man_rpt_req_callback: (+1)
   \   00000000   0x2201             MOVS     R2,#+1
   \   00000002   0x....             LDR      R3,??DataTable4
   \   00000004   0x601A             STR      R2,[R3, #+0]
    241          	man_rpt_work.resp_cmd.id = id;
   \   00000006   0x....             LDR      R2,??DataTable4_1
   \   00000008   0x6010             STR      R0,[R2, #+0]
    242          	man_rpt_work.resp_cmd.status = status;
   \   0000000A   0x....             LDR      R0,??DataTable4_2
   \   0000000C   0x6001             STR      R1,[R0, #+0]
    243          }
   \   0000000E   0x4770             BX       LR               ;; return
    244          
    245          
    246          /********************************************************************/
    247          /*	static関数                                                      */
    248          /********************************************************************/
    249          
    250          
    251          /********************************************************************/
    252          /*!
    253           * \name	man_rpt_set_sequense
    254           * \brief	シーケンスを設定する
    255           * \param	sequense : 設定するシーケンス
    256           * \return  なし
    257           * \note	
    258           */
    259          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    260          static void man_rpt_set_sequense( man_rpt_seq_def sequense )
    261          {
   \                     man_rpt_set_sequense: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    262          	if (man_rpt_work.sequense != sequense) {
   \   00000002   0x....             LDR      R1,??DataTable4_3
   \   00000004   0x7809             LDRB     R1,[R1, #+0]
   \   00000006   0x0002             MOVS     R2,R0
   \   00000008   0xB2D2             UXTB     R2,R2
   \   0000000A   0x4291             CMP      R1,R2
   \   0000000C   0xD017             BEQ      ??man_rpt_set_sequense_0
    263          		man_rpt_work.sequense = sequense;
   \   0000000E   0x....             LDR      R1,??DataTable4_3
   \   00000010   0x7008             STRB     R0,[R1, #+0]
    264          		man_rpt_work.seq_log[man_rpt_work.seq_wp] = sequense;
   \   00000012   0x....             LDR      R1,??DataTable4_4
   \   00000014   0x....             LDR      R2,??DataTable4_4
   \   00000016   0x6E52             LDR      R2,[R2, #+100]
   \   00000018   0x5488             STRB     R0,[R1, R2]
    265          		man_rpt_work.seq_wp++;
   \   0000001A   0x....             LDR      R1,??DataTable4_4
   \   0000001C   0x6E49             LDR      R1,[R1, #+100]
   \   0000001E   0x1C49             ADDS     R1,R1,#+1
   \   00000020   0x....             LDR      R2,??DataTable4_4
   \   00000022   0x6651             STR      R1,[R2, #+100]
    266          		if (man_rpt_work.seq_wp >= 100) {
   \   00000024   0x....             LDR      R1,??DataTable4_4
   \   00000026   0x6E49             LDR      R1,[R1, #+100]
   \   00000028   0x2964             CMP      R1,#+100
   \   0000002A   0xDB02             BLT      ??man_rpt_set_sequense_1
    267          			man_rpt_work.seq_wp = 0;
   \   0000002C   0x2100             MOVS     R1,#+0
   \   0000002E   0x....             LDR      R2,??DataTable4_4
   \   00000030   0x6651             STR      R1,[R2, #+100]
    268          		}
    269          
    270          		// デバックログに登録 
    271          		man_dbglog_setting(MAN_ERROR_DBG_MAN_RPT, MAN_ERROR_DBG_TYPE_SEQ, sequense);
   \                     ??man_rpt_set_sequense_1: (+1)
   \   00000032   0xB2C0             UXTB     R0,R0
   \   00000034   0x0002             MOVS     R2,R0
   \   00000036   0x2101             MOVS     R1,#+1
   \   00000038   0x2005             MOVS     R0,#+5
   \   0000003A   0x.... 0x....      BL       man_dbglog_setting
    272          
    273          #ifdef GNSS_DEBUG_MAN_RPT 
    274          			int32_t		length;
    275          			sprintf((char *)&man_rpt_work.buff[0], "RPT SEQ(%d)\n", sequense);
    276          			length = strlen((char const *)&man_rpt_work.buff[0]);
    277          			man_usb_data_send(&man_rpt_work.buff[0], length);
    278          #endif
    279          
    280          	}
    281          }
   \                     ??man_rpt_set_sequense_0: (+1)
   \   0000003E   0xBD01             POP      {R0,PC}          ;; return
    282          
    283          
    284          /********************************************************************/
    285          /*!
    286           * \name	man_rpt_return_callback
    287           * \brief	callback応答を返す処理
    288           * \param	status : 通知するステータス
    289           * \return   0: 成功
    290           *          -1:失敗
    291           * \note	
    292           */
    293          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    294          static void man_rpt_return_callback( int32_t status )
    295          {
   \                     man_rpt_return_callback: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    296          
    297          	// callback関数で終了通知
    298          	if (man_rpt_work.request.callback != NULL) {
   \   00000002   0x....             LDR      R1,??DataTable4_5
   \   00000004   0x6809             LDR      R1,[R1, #+0]
   \   00000006   0x2900             CMP      R1,#+0
   \   00000008   0xD008             BEQ      ??man_rpt_return_callback_0
    299          		man_rpt_work.request.callback(man_rpt_work.request.id, status);
   \   0000000A   0x0001             MOVS     R1,R0
   \   0000000C   0x....             LDR      R0,??DataTable4_4
   \   0000000E   0x6FC0             LDR      R0,[R0, #+124]
   \   00000010   0x....             LDR      R2,??DataTable4_5
   \   00000012   0x6812             LDR      R2,[R2, #+0]
   \   00000014   0x4790             BLX      R2
    300          		man_rpt_work.request.callback = NULL;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x....             LDR      R1,??DataTable4_5
   \   0000001A   0x6008             STR      R0,[R1, #+0]
    301          	}
    302          	man_rpt_set_sequense(MAN_RPT_SEQ_READY);
   \                     ??man_rpt_return_callback_0: (+1)
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0x.... 0x....      BL       man_rpt_set_sequense
    303          	man_rpt_work.request.req_cmd = MAN_RPT_REQ_CMD_READY;
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0x....             LDR      R1,??DataTable4_4
   \   00000026   0x6788             STR      R0,[R1, #+120]
    304          }
   \   00000028   0xBD01             POP      {R0,PC}          ;; return
    305          
    306          
    307          /********************************************************************/
    308          /*!
    309           * \name	man_rpt_make_info_sensor
    310           * \brief	サーバに通知するINFOデータ(センサ用)を作成する処理
    311           * \param	なし
    312           * \return  なし
    313           * \note	
    314           */
    315          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    316          static void man_rpt_make_info_sensor( void )
    317          {
   \                     man_rpt_make_info_sensor: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB091             SUB      SP,SP,#+68
    318          	int32_t		size;
    319          	man_rpt_info1_data_t	*info1 = &man_rpt_work.info1;
   \   00000004   0x....             LDR      R5,??man_rpt_send_body_sensor_0
    320          	man_rpt_info2_data_t	*info2 = &man_rpt_work.info2;
   \   00000006   0x....             LDR      R6,??man_rpt_send_body_sensor_0+0x4
    321          	man_data_get_sensor_t	*sensor = man_data_get_sensor();
   \   00000008   0x.... 0x....      BL       man_data_get_sensor
   \   0000000C   0x0004             MOVS     R4,R0
    322          
    323          	memset(info1->data, 0, MAN_DATA_INFO_SIZE+MAN_DATA_NMEA_MAX);
   \   0000000E   0x21BE             MOVS     R1,#+190
   \   00000010   0x00C9             LSLS     R1,R1,#+3        ;; #+1520
   \   00000012   0x2200             MOVS     R2,#+0
   \   00000014   0x0028             MOVS     R0,R5
   \   00000016   0x.... 0x....      BL       __aeabi_memset
    324          	info1->data_len = 0;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x21BE             MOVS     R1,#+190
   \   0000001E   0x00C9             LSLS     R1,R1,#+3        ;; #+1520
   \   00000020   0x5068             STR      R0,[R5, R1]
    325          	info2->data_len = 0;
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0x21CD             MOVS     R1,#+205
   \   00000026   0x0089             LSLS     R1,R1,#+2        ;; #+820
   \   00000028   0x5070             STR      R0,[R6, R1]
    326          
    327          	sprintf((char *)info1->data, "%d;%d;%d;%d;%d;%d;%d;%d;%d;%d;%d;%d;%d.%02d;%d;%d;0.00;%d;%d;",
    328          								sensor->gyro.raw_accel_x,				// 加速度センサー生値（X軸）
    329          								sensor->gyro.raw_accel_y,				// 加速度センサー生値（Y軸）
    330          								sensor->gyro.raw_accel_z,				// 加速度センサー生値（Z軸）
    331          								sensor->gyro.accel_x,					// 加速度(X軸)[mG]
    332          								sensor->gyro.accel_y,					// 加速度(Y軸)[mG]
    333          								sensor->gyro.accel_z,					// 加速度(Z軸)[mG]
    334          								sensor->gyro.raw_gyro_x,				// 角速度センサー生値（X軸）
    335          								sensor->gyro.raw_gyro_y,				// 角速度センサー生値（Y軸）
    336          								sensor->gyro.raw_gyro_z,				// 角速度センサー生値（Z軸）
    337          								sensor->gyro.gyro_x,					// 角速度(X軸)[dps]
    338          								sensor->gyro.gyro_y,					// 角速度(Y軸)[dps]
    339          								sensor->gyro.gyro_z,					// 角速度(Z軸)[dps]
    340          								sensor->pressure/100,					// 角速度(Z軸)[dps]
    341          								sensor->pressure%100,						// 気圧(******[hPa])
    342          								sensor->temperature,					// 気温(***[℃])
    343          								sensor->altitude,						// 高度(-*** 〜 *****[m])
    344          								sensor->rsrp,							// 基準信号受信電力[dbm]
    345          								sensor->rssi);							// 受信信号強度[dbm]
   \   0000002A   0x20BE             MOVS     R0,#+190
   \   0000002C   0x0100             LSLS     R0,R0,#+4        ;; #+3040
   \   0000002E   0x5820             LDR      R0,[R4, R0]
   \   00000030   0x900F             STR      R0,[SP, #+60]
   \   00000032   0x....             LDR      R0,??DataTable4_6  ;; 0xbdc
   \   00000034   0x5820             LDR      R0,[R4, R0]
   \   00000036   0x900E             STR      R0,[SP, #+56]
   \   00000038   0x6E20             LDR      R0,[R4, #+96]
   \   0000003A   0x900D             STR      R0,[SP, #+52]
   \   0000003C   0x6D60             LDR      R0,[R4, #+84]
   \   0000003E   0x900C             STR      R0,[SP, #+48]
   \   00000040   0x6DE0             LDR      R0,[R4, #+92]
   \   00000042   0x2164             MOVS     R1,#+100
   \   00000044   0x.... 0x....      BL       __aeabi_idivmod
   \   00000048   0x910B             STR      R1,[SP, #+44]
   \   0000004A   0x6DE0             LDR      R0,[R4, #+92]
   \   0000004C   0x2164             MOVS     R1,#+100
   \   0000004E   0x.... 0x....      BL       __aeabi_idiv
   \   00000052   0x900A             STR      R0,[SP, #+40]
   \   00000054   0x6BA0             LDR      R0,[R4, #+56]
   \   00000056   0x9009             STR      R0,[SP, #+36]
   \   00000058   0x6B60             LDR      R0,[R4, #+52]
   \   0000005A   0x9008             STR      R0,[SP, #+32]
   \   0000005C   0x6B20             LDR      R0,[R4, #+48]
   \   0000005E   0x9007             STR      R0,[SP, #+28]
   \   00000060   0x6960             LDR      R0,[R4, #+20]
   \   00000062   0x9006             STR      R0,[SP, #+24]
   \   00000064   0x6920             LDR      R0,[R4, #+16]
   \   00000066   0x9005             STR      R0,[SP, #+20]
   \   00000068   0x68E0             LDR      R0,[R4, #+12]
   \   0000006A   0x9004             STR      R0,[SP, #+16]
   \   0000006C   0x6C60             LDR      R0,[R4, #+68]
   \   0000006E   0x9003             STR      R0,[SP, #+12]
   \   00000070   0x6C20             LDR      R0,[R4, #+64]
   \   00000072   0x9002             STR      R0,[SP, #+8]
   \   00000074   0x6BE0             LDR      R0,[R4, #+60]
   \   00000076   0x9001             STR      R0,[SP, #+4]
   \   00000078   0x6A20             LDR      R0,[R4, #+32]
   \   0000007A   0x9000             STR      R0,[SP, #+0]
   \   0000007C   0x69E3             LDR      R3,[R4, #+28]
   \   0000007E   0x69A2             LDR      R2,[R4, #+24]
   \   00000080   0x....             LDR      R1,??DataTable4_7
   \   00000082   0x0028             MOVS     R0,R5
   \   00000084   0x.... 0x....      BL       sprintf
    346          
    347          	// UDP向けの場合は分割する
    348          	if (man_rpt_work.select == MAN_RPT_SEL_UDP) {
   \   00000088   0x....             LDR      R0,??DataTable4_8
   \   0000008A   0x7800             LDRB     R0,[R0, #+0]
   \   0000008C   0x2800             CMP      R0,#+0
   \   0000008E   0xD160             BNE      ??man_rpt_make_info_sensor_0
    349          		size = strlen((char const *)info1->data);
   \   00000090   0x0028             MOVS     R0,R5
   \   00000092   0x.... 0x....      BL       strlen
   \   00000096   0x0007             MOVS     R7,R0
    350          		if ( sensor->nmea_len <= MAN_DATA_NMEA_MAX) {
   \   00000098   0x20BE             MOVS     R0,#+190
   \   0000009A   0x00C0             LSLS     R0,R0,#+3        ;; #+1520
   \   0000009C   0x5820             LDR      R0,[R4, R0]
   \   0000009E   0x....             LDR      R1,??DataTable4_9  ;; 0x2bd
   \   000000A0   0x4288             CMP      R0,R1
   \   000000A2   0xDA1B             BGE      ??man_rpt_make_info_sensor_1
    351          			if (sensor->nmea_len > 0) {
   \   000000A4   0x20BE             MOVS     R0,#+190
   \   000000A6   0x00C0             LSLS     R0,R0,#+3        ;; #+1520
   \   000000A8   0x5820             LDR      R0,[R4, R0]
   \   000000AA   0x2801             CMP      R0,#+1
   \   000000AC   0xDB0A             BLT      ??man_rpt_make_info_sensor_2
    352          				memcpy(&info1->data[size], &sensor->nmea[0], sensor->nmea_len);
   \   000000AE   0x20BE             MOVS     R0,#+190
   \   000000B0   0x00C0             LSLS     R0,R0,#+3        ;; #+1520
   \   000000B2   0x5822             LDR      R2,[R4, R0]
   \   000000B4   0x0021             MOVS     R1,R4
   \   000000B6   0x3178             ADDS     R1,R1,#+120
   \   000000B8   0x19E8             ADDS     R0,R5,R7
   \   000000BA   0x9000             STR      R0,[SP, #+0]
   \   000000BC   0x9800             LDR      R0,[SP, #+0]
   \   000000BE   0x.... 0x....      BL       __aeabi_memcpy
   \   000000C2   0x9800             LDR      R0,[SP, #+0]
    353          			}
    354          			info1->data_len = size + sensor->nmea_len;
   \                     ??man_rpt_make_info_sensor_2: (+1)
   \   000000C4   0x20BE             MOVS     R0,#+190
   \   000000C6   0x00C0             LSLS     R0,R0,#+3        ;; #+1520
   \   000000C8   0x5820             LDR      R0,[R4, R0]
   \   000000CA   0x1838             ADDS     R0,R7,R0
   \   000000CC   0x21BE             MOVS     R1,#+190
   \   000000CE   0x00C9             LSLS     R1,R1,#+3        ;; #+1520
   \   000000D0   0x5068             STR      R0,[R5, R1]
    355          			info2->data_len = 0;
   \   000000D2   0x2000             MOVS     R0,#+0
   \   000000D4   0x21CD             MOVS     R1,#+205
   \   000000D6   0x0089             LSLS     R1,R1,#+2        ;; #+820
   \   000000D8   0x5070             STR      R0,[R6, R1]
   \   000000DA   0xE05F             B        ??man_rpt_make_info_sensor_3
    356          		}
    357          		else {
    358          			if (sensor->nmea_len <= (2 * MAN_DATA_NMEA_MAX)) {
   \                     ??man_rpt_make_info_sensor_1: (+1)
   \   000000DC   0x20BE             MOVS     R0,#+190
   \   000000DE   0x00C0             LSLS     R0,R0,#+3        ;; #+1520
   \   000000E0   0x5820             LDR      R0,[R4, R0]
   \   000000E2   0x....             LDR      R1,??DataTable5  ;; 0x579
   \   000000E4   0x4288             CMP      R0,R1
   \   000000E6   0xDA2A             BGE      ??man_rpt_make_info_sensor_4
    359          				memcpy(&info1->data[size], &sensor->nmea[0], MAN_DATA_NMEA_MAX);
   \   000000E8   0x22AF             MOVS     R2,#+175
   \   000000EA   0x0092             LSLS     R2,R2,#+2        ;; #+700
   \   000000EC   0x0021             MOVS     R1,R4
   \   000000EE   0x3178             ADDS     R1,R1,#+120
   \   000000F0   0x19E8             ADDS     R0,R5,R7
   \   000000F2   0x9000             STR      R0,[SP, #+0]
   \   000000F4   0x9800             LDR      R0,[SP, #+0]
   \   000000F6   0x.... 0x....      BL       __aeabi_memcpy
   \   000000FA   0x9800             LDR      R0,[SP, #+0]
    360          				info1->data_len = size + MAN_DATA_NMEA_MAX;
   \   000000FC   0x20AF             MOVS     R0,#+175
   \   000000FE   0x0080             LSLS     R0,R0,#+2        ;; #+700
   \   00000100   0x1838             ADDS     R0,R7,R0
   \   00000102   0x21BE             MOVS     R1,#+190
   \   00000104   0x00C9             LSLS     R1,R1,#+3        ;; #+1520
   \   00000106   0x5068             STR      R0,[R5, R1]
    361          
    362          				memcpy(&info2->data[0], &info1->data[0], size);
   \   00000108   0x003A             MOVS     R2,R7
   \   0000010A   0x0029             MOVS     R1,R5
   \   0000010C   0x0030             MOVS     R0,R6
   \   0000010E   0x.... 0x....      BL       __aeabi_memcpy
    363          				memcpy(&info2->data[size], &sensor->nmea[MAN_DATA_NMEA_MAX], sensor->nmea_len - MAN_DATA_NMEA_MAX);
   \   00000112   0x20BE             MOVS     R0,#+190
   \   00000114   0x00C0             LSLS     R0,R0,#+3        ;; #+1520
   \   00000116   0x5820             LDR      R0,[R4, R0]
   \   00000118   0x....             LDR      R1,??DataTable5_1  ;; 0xfffffd44
   \   0000011A   0x1842             ADDS     R2,R0,R1
   \   0000011C   0x20CD             MOVS     R0,#+205
   \   0000011E   0x0080             LSLS     R0,R0,#+2        ;; #+820
   \   00000120   0x1821             ADDS     R1,R4,R0
   \   00000122   0x19F5             ADDS     R5,R6,R7
   \   00000124   0x0028             MOVS     R0,R5
   \   00000126   0x.... 0x....      BL       __aeabi_memcpy
    364          				info2->data_len = size + sensor->nmea_len - MAN_DATA_NMEA_MAX;
   \   0000012A   0x20BE             MOVS     R0,#+190
   \   0000012C   0x00C0             LSLS     R0,R0,#+3        ;; #+1520
   \   0000012E   0x5820             LDR      R0,[R4, R0]
   \   00000130   0x1838             ADDS     R0,R7,R0
   \   00000132   0x....             LDR      R1,??DataTable5_1  ;; 0xfffffd44
   \   00000134   0x1840             ADDS     R0,R0,R1
   \   00000136   0x21CD             MOVS     R1,#+205
   \   00000138   0x0089             LSLS     R1,R1,#+2        ;; #+820
   \   0000013A   0x5070             STR      R0,[R6, R1]
   \   0000013C   0xE02E             B        ??man_rpt_make_info_sensor_3
    365          			}
    366          			// NMEAデータ長異常
    367          			else {
    368          				man_error_setting(MAN_ERROR_MAN_RPT, sensor->nmea_len, 0);
   \                     ??man_rpt_make_info_sensor_4: (+1)
   \   0000013E   0x23B8             MOVS     R3,#+184
   \   00000140   0x005B             LSLS     R3,R3,#+1        ;; #+368
   \   00000142   0x2200             MOVS     R2,#+0
   \   00000144   0x20BE             MOVS     R0,#+190
   \   00000146   0x00C0             LSLS     R0,R0,#+3        ;; #+1520
   \   00000148   0x5821             LDR      R1,[R4, R0]
   \   0000014A   0x2017             MOVS     R0,#+23
   \   0000014C   0x.... 0x....      BL       man_error_set
   \   00000150   0xE024             B        ??man_rpt_make_info_sensor_3
    369          			}
    370          		}
    371          	}
    372          	
    373          	// USB向けの場合は分割しない
    374          	else {
    375          		size = strlen((char const *)info1->data);
   \                     ??man_rpt_make_info_sensor_0: (+1)
   \   00000152   0x0028             MOVS     R0,R5
   \   00000154   0x.... 0x....      BL       strlen
   \   00000158   0x0007             MOVS     R7,R0
    376          		if (sensor->nmea_len <= (2 * MAN_DATA_NMEA_MAX)) {
   \   0000015A   0x20BE             MOVS     R0,#+190
   \   0000015C   0x00C0             LSLS     R0,R0,#+3        ;; #+1520
   \   0000015E   0x5820             LDR      R0,[R4, R0]
   \   00000160   0x....             LDR      R1,??DataTable5  ;; 0x579
   \   00000162   0x4288             CMP      R0,R1
   \   00000164   0xDA1A             BGE      ??man_rpt_make_info_sensor_3
    377          			if (sensor->nmea_len > 0) {
   \   00000166   0x20BE             MOVS     R0,#+190
   \   00000168   0x00C0             LSLS     R0,R0,#+3        ;; #+1520
   \   0000016A   0x5820             LDR      R0,[R4, R0]
   \   0000016C   0x2801             CMP      R0,#+1
   \   0000016E   0xDB0A             BLT      ??man_rpt_make_info_sensor_5
    378          				memcpy(&info1->data[size], &sensor->nmea[0], sensor->nmea_len);
   \   00000170   0x20BE             MOVS     R0,#+190
   \   00000172   0x00C0             LSLS     R0,R0,#+3        ;; #+1520
   \   00000174   0x5822             LDR      R2,[R4, R0]
   \   00000176   0x0021             MOVS     R1,R4
   \   00000178   0x3178             ADDS     R1,R1,#+120
   \   0000017A   0x19E8             ADDS     R0,R5,R7
   \   0000017C   0x9000             STR      R0,[SP, #+0]
   \   0000017E   0x9800             LDR      R0,[SP, #+0]
   \   00000180   0x.... 0x....      BL       __aeabi_memcpy
   \   00000184   0x9800             LDR      R0,[SP, #+0]
    379          			}
    380          			info1->data_len = size + sensor->nmea_len;
   \                     ??man_rpt_make_info_sensor_5: (+1)
   \   00000186   0x20BE             MOVS     R0,#+190
   \   00000188   0x00C0             LSLS     R0,R0,#+3        ;; #+1520
   \   0000018A   0x5820             LDR      R0,[R4, R0]
   \   0000018C   0x1838             ADDS     R0,R7,R0
   \   0000018E   0x21BE             MOVS     R1,#+190
   \   00000190   0x00C9             LSLS     R1,R1,#+3        ;; #+1520
   \   00000192   0x5068             STR      R0,[R5, R1]
    381          			info2->data_len = 0;
   \   00000194   0x2000             MOVS     R0,#+0
   \   00000196   0x21CD             MOVS     R1,#+205
   \   00000198   0x0089             LSLS     R1,R1,#+2        ;; #+820
   \   0000019A   0x5070             STR      R0,[R6, R1]
    382          		}
    383          		// NMEAデータ長異常
    384          		else {
    385          		}
    386          	}
    387          }
   \                     ??man_rpt_make_info_sensor_3: (+1)
   \   0000019C   0xB011             ADD      SP,SP,#+68
   \   0000019E   0xBDF0             POP      {R4-R7,PC}       ;; return
    388          
    389          /********************************************************************/
    390          /*!
    391           * \name	man_rpt_make_body_sensor
    392           * \brief	サーバに通知するBODYデータ(センサ用)を作成する処理
    393           * \param	なし
    394           * \return  なし
    395           * \note	
    396           */
    397          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    398          static void man_rpt_make_body_sensor( uint8_t tr )
    399          {
   \                     man_rpt_make_body_sensor: (+1)
   \   00000000   0xB5F1             PUSH     {R0,R4-R7,LR}
   \   00000002   0xB092             SUB      SP,SP,#+72
    400          	int32_t		total_id;
    401          	int32_t		id_no;
    402          	int32_t		info_len;
    403          	man_data_get_other_t	*other = man_data_get_other();
   \   00000004   0x.... 0x....      BL       man_data_get_other
   \   00000008   0x900D             STR      R0,[SP, #+52]
    404          	man_rpt_info1_data_t	*info1 = &man_rpt_work.info1;
   \   0000000A   0x....             LDR      R6,??man_rpt_send_body_sensor_0
    405          	man_rpt_info2_data_t	*info2 = &man_rpt_work.info2;
   \   0000000C   0x....             LDR      R0,??man_rpt_send_body_sensor_0+0x4
   \   0000000E   0x900F             STR      R0,[SP, #+60]
    406          	man_rpt_body_data_t		*body1 = &man_rpt_work.body1;
   \   00000010   0x....             LDR      R0,??man_rpt_usb_send_body_sensor_0
   \   00000012   0x900E             STR      R0,[SP, #+56]
    407          	man_rpt_body_data_t		*body2 = &man_rpt_work.body2;
   \   00000014   0x....             LDR      R7,??DataTable5_2
    408          	man_data_get_sensor_t	*sensor = man_data_get_sensor();
   \   00000016   0x.... 0x....      BL       man_data_get_sensor
   \   0000001A   0x0005             MOVS     R5,R0
    409          	clock_info_t			jst_clock;
    410          	clock_info_t			*utc_clock;
    411          
    412          	man_rtc_get_clock(&jst_clock);
   \   0000001C   0xA810             ADD      R0,SP,#+64
   \   0000001E   0x.... 0x....      BL       man_rtc_get_clock
    413          	utc_clock = gm_time(&jst_clock);
   \   00000022   0xA810             ADD      R0,SP,#+64
   \   00000024   0x.... 0x....      BL       gm_time
   \   00000028   0x0004             MOVS     R4,R0
    414          
    415          	// サーバに通知するINFOデータ(センサ用)を作成
    416          	man_rpt_make_info_sensor();
   \   0000002A   0x.... 0x....      BL       man_rpt_make_info_sensor
    417          
    418          	if ( info2->data_len == 0 ) {
   \   0000002E   0x980F             LDR      R0,[SP, #+60]
   \   00000030   0x21CD             MOVS     R1,#+205
   \   00000032   0x0089             LSLS     R1,R1,#+2        ;; #+820
   \   00000034   0x5840             LDR      R0,[R0, R1]
   \   00000036   0x2800             CMP      R0,#+0
   \   00000038   0xD102             BNE      ??man_rpt_make_body_sensor_0
    419          		total_id = 1;
   \   0000003A   0x2201             MOVS     R2,#+1
    420          		id_no = 0;
   \   0000003C   0x2300             MOVS     R3,#+0
   \   0000003E   0xE001             B        ??man_rpt_make_body_sensor_1
    421          	}
    422          	else {
    423          		total_id = 2;
   \                     ??man_rpt_make_body_sensor_0: (+1)
   \   00000040   0x2202             MOVS     R2,#+2
    424          		id_no = 0;
   \   00000042   0x2300             MOVS     R3,#+0
    425          	}
    426          
    427          	sprintf((char *)body1->data, "LTE1;%d;%d;%s;00000000;%d;%d;%d%%;%d%%;%d;%02d%02d%02d%02d%02d%02d;%d;",
    428          									total_id,								// トータルパケット数(total id)
    429          									id_no,									// パケット番号(id no)
    430          									other->imei,							// 端末識別番号(IMEI)
    431          //									other->cid,								// コマンドID(cid) :: 00000000固定
    432          									tr,										// メッセージタイプ(tr)
    433          									sensor->voltage,						// 現在のバッテリー電圧(vo)[mv]
    434          									sensor->charge,							// バッテリー残量(ca)[%]
    435          									other->battery_alarm,					// 低電圧警告閾値(vothr)[%]
    436          									sensor->type_num,						// 温度(Device temperature)[℃]
    437          									utc_clock->year,						// UTC Time(YY)
    438          									utc_clock->month,						// UTC Time(MM)
    439          									utc_clock->day,							// UTC Time(DD)
    440          									utc_clock->hour,						// UTC Time(HH)
    441          									utc_clock->minute,						// UTC Time(MM)
    442          									utc_clock->seconds,						// UTC Time(SS)
    443          									info1->data_len);						// ”info” サイズ長(infolen)
   \                     ??man_rpt_make_body_sensor_1: (+1)
   \   00000044   0x20BE             MOVS     R0,#+190
   \   00000046   0x00C0             LSLS     R0,R0,#+3        ;; #+1520
   \   00000048   0x5830             LDR      R0,[R6, R0]
   \   0000004A   0x900C             STR      R0,[SP, #+48]
   \   0000004C   0x2005             MOVS     R0,#+5
   \   0000004E   0x5620             LDRSB    R0,[R4, R0]
   \   00000050   0x900B             STR      R0,[SP, #+44]
   \   00000052   0x2004             MOVS     R0,#+4
   \   00000054   0x5620             LDRSB    R0,[R4, R0]
   \   00000056   0x900A             STR      R0,[SP, #+40]
   \   00000058   0x2003             MOVS     R0,#+3
   \   0000005A   0x5620             LDRSB    R0,[R4, R0]
   \   0000005C   0x9009             STR      R0,[SP, #+36]
   \   0000005E   0x2002             MOVS     R0,#+2
   \   00000060   0x5620             LDRSB    R0,[R4, R0]
   \   00000062   0x9008             STR      R0,[SP, #+32]
   \   00000064   0x2001             MOVS     R0,#+1
   \   00000066   0x5620             LDRSB    R0,[R4, R0]
   \   00000068   0x9007             STR      R0,[SP, #+28]
   \   0000006A   0x2000             MOVS     R0,#+0
   \   0000006C   0x5620             LDRSB    R0,[R4, R0]
   \   0000006E   0x9006             STR      R0,[SP, #+24]
   \   00000070   0x6DA8             LDR      R0,[R5, #+88]
   \   00000072   0x9005             STR      R0,[SP, #+20]
   \   00000074   0x980D             LDR      R0,[SP, #+52]
   \   00000076   0x69C0             LDR      R0,[R0, #+28]
   \   00000078   0x9004             STR      R0,[SP, #+16]
   \   0000007A   0x6EA8             LDR      R0,[R5, #+104]
   \   0000007C   0x9003             STR      R0,[SP, #+12]
   \   0000007E   0x6E68             LDR      R0,[R5, #+100]
   \   00000080   0x9002             STR      R0,[SP, #+8]
   \   00000082   0xA812             ADD      R0,SP,#+72
   \   00000084   0x7800             LDRB     R0,[R0, #+0]
   \   00000086   0x9001             STR      R0,[SP, #+4]
   \   00000088   0x980D             LDR      R0,[SP, #+52]
   \   0000008A   0x9000             STR      R0,[SP, #+0]
   \   0000008C   0x....             LDR      R1,??DataTable7
   \   0000008E   0x980E             LDR      R0,[SP, #+56]
   \   00000090   0x.... 0x....      BL       sprintf
    444          	body1->data_len = strlen((char const *)body1->data);
   \   00000094   0x980E             LDR      R0,[SP, #+56]
   \   00000096   0x.... 0x....      BL       strlen
   \   0000009A   0x990E             LDR      R1,[SP, #+56]
   \   0000009C   0x22C8             MOVS     R2,#+200
   \   0000009E   0x5088             STR      R0,[R1, R2]
    445          	body2->data_len = 0;
   \   000000A0   0x2000             MOVS     R0,#+0
   \   000000A2   0x21C8             MOVS     R1,#+200
   \   000000A4   0x5078             STR      R0,[R7, R1]
    446          
    447          	if ( info2->data_len != 0 ) {
   \   000000A6   0x980F             LDR      R0,[SP, #+60]
   \   000000A8   0x21CD             MOVS     R1,#+205
   \   000000AA   0x0089             LSLS     R1,R1,#+2        ;; #+820
   \   000000AC   0x5840             LDR      R0,[R0, R1]
   \   000000AE   0x2800             CMP      R0,#+0
   \   000000B0   0xD02F             BEQ      ??man_rpt_make_body_sensor_2
    448          		total_id = 2;
   \   000000B2   0x2202             MOVS     R2,#+2
    449          		id_no = 1;
   \   000000B4   0x2301             MOVS     R3,#+1
    450          
    451          		sprintf((char *)body2->data, "LTE1;%d;%d;%s;00000000;%d;%d;%d%%;%d%%;%d;%02d%02d%02d%02d%02d%02d;%d;",
    452          									total_id,								// トータルパケット数(total id)
    453          									id_no,									// パケット番号(id no)
    454          									other->imei,							// 端末識別番号(IMEI)
    455          //									other->cid,								// コマンドID(cid) :: 00000000固定
    456          									tr,										// メッセージタイプ(tr)
    457          									sensor->voltage,						// 現在のバッテリー電圧(vo)[mv]
    458          									sensor->charge,							// バッテリー残量(ca)[%]
    459          									other->battery_alarm,					// 低電圧警告閾値(vothr)[%]
    460          									sensor->type_num,						// 温度(Device temperature)[℃]
    461          									utc_clock->year,						// UTC Time(YY)
    462          									utc_clock->month,						// UTC Time(MM)
    463          									utc_clock->day,							// UTC Time(DD)
    464          									utc_clock->hour,						// UTC Time(HH)
    465          									utc_clock->minute,						// UTC Time(MM)
    466          									utc_clock->seconds,						// UTC Time(SS)
    467          									info2->data_len);						// ”info” サイズ長(infolen)
   \   000000B6   0x980F             LDR      R0,[SP, #+60]
   \   000000B8   0x21CD             MOVS     R1,#+205
   \   000000BA   0x0089             LSLS     R1,R1,#+2        ;; #+820
   \   000000BC   0x5840             LDR      R0,[R0, R1]
   \   000000BE   0x900C             STR      R0,[SP, #+48]
   \   000000C0   0x2005             MOVS     R0,#+5
   \   000000C2   0x5620             LDRSB    R0,[R4, R0]
   \   000000C4   0x900B             STR      R0,[SP, #+44]
   \   000000C6   0x2004             MOVS     R0,#+4
   \   000000C8   0x5620             LDRSB    R0,[R4, R0]
   \   000000CA   0x900A             STR      R0,[SP, #+40]
   \   000000CC   0x2003             MOVS     R0,#+3
   \   000000CE   0x5620             LDRSB    R0,[R4, R0]
   \   000000D0   0x9009             STR      R0,[SP, #+36]
   \   000000D2   0x2002             MOVS     R0,#+2
   \   000000D4   0x5620             LDRSB    R0,[R4, R0]
   \   000000D6   0x9008             STR      R0,[SP, #+32]
   \   000000D8   0x2001             MOVS     R0,#+1
   \   000000DA   0x5620             LDRSB    R0,[R4, R0]
   \   000000DC   0x9007             STR      R0,[SP, #+28]
   \   000000DE   0x2000             MOVS     R0,#+0
   \   000000E0   0x5620             LDRSB    R0,[R4, R0]
   \   000000E2   0x9006             STR      R0,[SP, #+24]
   \   000000E4   0x6DA8             LDR      R0,[R5, #+88]
   \   000000E6   0x9005             STR      R0,[SP, #+20]
   \   000000E8   0x980D             LDR      R0,[SP, #+52]
   \   000000EA   0x69C0             LDR      R0,[R0, #+28]
   \   000000EC   0x9004             STR      R0,[SP, #+16]
   \   000000EE   0x6EA8             LDR      R0,[R5, #+104]
   \   000000F0   0x9003             STR      R0,[SP, #+12]
   \   000000F2   0x6E68             LDR      R0,[R5, #+100]
   \   000000F4   0x9002             STR      R0,[SP, #+8]
   \   000000F6   0xA812             ADD      R0,SP,#+72
   \   000000F8   0x7800             LDRB     R0,[R0, #+0]
   \   000000FA   0x9001             STR      R0,[SP, #+4]
   \   000000FC   0x980D             LDR      R0,[SP, #+52]
   \   000000FE   0x9000             STR      R0,[SP, #+0]
   \   00000100   0x....             LDR      R1,??DataTable7
   \   00000102   0x0038             MOVS     R0,R7
   \   00000104   0x.... 0x....      BL       sprintf
    468          		body2->data_len = strlen((char const *)body2->data);
   \   00000108   0x0038             MOVS     R0,R7
   \   0000010A   0x.... 0x....      BL       strlen
   \   0000010E   0x21C8             MOVS     R1,#+200
   \   00000110   0x5078             STR      R0,[R7, R1]
    469          	}
    470          }
   \                     ??man_rpt_make_body_sensor_2: (+1)
   \   00000112   0xB013             ADD      SP,SP,#+76
   \   00000114   0xBDF0             POP      {R4-R7,PC}       ;; return
    471          
    472          /********************************************************************/
    473          /*!
    474           * \name	man_rpt_send_body_sensor
    475           * \brief	サーバに通知するBODYデータ(センサ用)を送信する処理
    476           * \param	なし
    477           * \return   0: 成功
    478           *          -1:失敗
    479           * \note	
    480           */
    481          /********************************************************************/

   \                                 In section .text, align 4, keep-with-next
    482          static int32_t man_rpt_send_body_sensor( void )
    483          {
   \                     man_rpt_send_body_sensor: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
    484          	int32_t		ret=0;
   \   00000004   0x2600             MOVS     R6,#+0
    485          	man_rpt_info1_data_t	*info1 = &man_rpt_work.info1;
   \   00000006   0x4D01             LDR      R5,??man_rpt_send_body_sensor_0
    486          	man_rpt_info2_data_t	*info2 = &man_rpt_work.info2;
   \   00000008   0x4801             LDR      R0,??man_rpt_send_body_sensor_0+0x4
   \   0000000A   0xE003             B.N      ??man_rpt_send_body_sensor_1
   \                     ??man_rpt_send_body_sensor_0:
   \   0000000C   0x........         DC32     man_rpt_work+0x26C
   \   00000010   0x........         DC32     man_rpt_work+0x860
   \                     ??man_rpt_send_body_sensor_1: (+1)
   \   00000014   0x9003             STR      R0,[SP, #+12]
    487          	man_rpt_body_data_t		*body1 = &man_rpt_work.body1;
   \   00000016   0x....             LDR      R4,??man_rpt_usb_send_body_sensor_0
    488          	man_rpt_body_data_t		*body2 = &man_rpt_work.body2;
   \   00000018   0x....             LDR      R0,??DataTable5_2
   \   0000001A   0x9001             STR      R0,[SP, #+4]
    489          	man_rpt_rpt1_data_t		*rpt_buff1 = &man_rpt_work.rpt_buff1;
   \   0000001C   0x....             LDR      R7,??DataTable8
    490          	man_rpt_rpt2_data_t		*rpt_buff2 = &man_rpt_work.rpt_buff2;
   \   0000001E   0x....             LDR      R0,??DataTable8_1
   \   00000020   0x9002             STR      R0,[SP, #+8]
    491          
    492          
    493          	rpt_buff1->data_len = 0;
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0x21D7             MOVS     R1,#+215
   \   00000026   0x00C9             LSLS     R1,R1,#+3        ;; #+1720
   \   00000028   0x5078             STR      R0,[R7, R1]
    494          	rpt_buff2->data_len = 0;
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0x9902             LDR      R1,[SP, #+8]
   \   0000002E   0x22FF             MOVS     R2,#+255
   \   00000030   0x0092             LSLS     R2,R2,#+2        ;; #+1020
   \   00000032   0x5088             STR      R0,[R1, R2]
    495          
    496          	if ( (body1->data_len <= MAN_DATA_BODY_SIZE) && (info1->data_len <= MAN_DATA_INFO_SIZE) ) {
   \   00000034   0x20C8             MOVS     R0,#+200
   \   00000036   0x5820             LDR      R0,[R4, R0]
   \   00000038   0x28C9             CMP      R0,#+201
   \   0000003A   0xDA24             BGE      ??man_rpt_send_body_sensor_2
   \   0000003C   0x20BE             MOVS     R0,#+190
   \   0000003E   0x00C0             LSLS     R0,R0,#+3        ;; #+1520
   \   00000040   0x5828             LDR      R0,[R5, R0]
   \   00000042   0x....             LDR      R1,??DataTable8_2  ;; 0x335
   \   00000044   0x4288             CMP      R0,R1
   \   00000046   0xDA1E             BGE      ??man_rpt_send_body_sensor_2
    497          		if (body1->data_len != 0) {
   \   00000048   0x20C8             MOVS     R0,#+200
   \   0000004A   0x5820             LDR      R0,[R4, R0]
   \   0000004C   0x2800             CMP      R0,#+0
   \   0000004E   0xD01A             BEQ      ??man_rpt_send_body_sensor_2
    498          			memcpy(&rpt_buff1->data[0], &body1->data[0], body1->data_len);
   \   00000050   0x20C8             MOVS     R0,#+200
   \   00000052   0x5822             LDR      R2,[R4, R0]
   \   00000054   0x0021             MOVS     R1,R4
   \   00000056   0x0038             MOVS     R0,R7
   \   00000058   0x.... 0x....      BL       __aeabi_memcpy
    499          			memcpy(&rpt_buff1->data[body1->data_len], &info1->data[0], info1->data_len);
   \   0000005C   0x20BE             MOVS     R0,#+190
   \   0000005E   0x00C0             LSLS     R0,R0,#+3        ;; #+1520
   \   00000060   0x582A             LDR      R2,[R5, R0]
   \   00000062   0x0029             MOVS     R1,R5
   \   00000064   0x20C8             MOVS     R0,#+200
   \   00000066   0x5820             LDR      R0,[R4, R0]
   \   00000068   0x1838             ADDS     R0,R7,R0
   \   0000006A   0x9000             STR      R0,[SP, #+0]
   \   0000006C   0x9800             LDR      R0,[SP, #+0]
   \   0000006E   0x.... 0x....      BL       __aeabi_memcpy
   \   00000072   0x9800             LDR      R0,[SP, #+0]
    500          			rpt_buff1->data_len = body1->data_len + info1->data_len;
   \   00000074   0x20C8             MOVS     R0,#+200
   \   00000076   0x5820             LDR      R0,[R4, R0]
   \   00000078   0x21BE             MOVS     R1,#+190
   \   0000007A   0x00C9             LSLS     R1,R1,#+3        ;; #+1520
   \   0000007C   0x5869             LDR      R1,[R5, R1]
   \   0000007E   0x1840             ADDS     R0,R0,R1
   \   00000080   0x21D7             MOVS     R1,#+215
   \   00000082   0x00C9             LSLS     R1,R1,#+3        ;; #+1720
   \   00000084   0x5078             STR      R0,[R7, R1]
    501          		}
    502          	}
    503          
    504          	if ( (body2->data_len <= MAN_DATA_BODY_SIZE) && (info2->data_len <= MAN_DATA_INFO_SIZE) ) {
   \                     ??man_rpt_send_body_sensor_2: (+1)
   \   00000086   0x9801             LDR      R0,[SP, #+4]
   \   00000088   0x21C8             MOVS     R1,#+200
   \   0000008A   0x5840             LDR      R0,[R0, R1]
   \   0000008C   0x28C9             CMP      R0,#+201
   \   0000008E   0xDA32             BGE      ??man_rpt_send_body_sensor_3
   \   00000090   0x9803             LDR      R0,[SP, #+12]
   \   00000092   0x21CD             MOVS     R1,#+205
   \   00000094   0x0089             LSLS     R1,R1,#+2        ;; #+820
   \   00000096   0x5840             LDR      R0,[R0, R1]
   \   00000098   0x....             LDR      R1,??DataTable8_2  ;; 0x335
   \   0000009A   0x4288             CMP      R0,R1
   \   0000009C   0xDA2B             BGE      ??man_rpt_send_body_sensor_3
    505          		if (body2->data_len != 0) {
   \   0000009E   0x9801             LDR      R0,[SP, #+4]
   \   000000A0   0x21C8             MOVS     R1,#+200
   \   000000A2   0x5840             LDR      R0,[R0, R1]
   \   000000A4   0x2800             CMP      R0,#+0
   \   000000A6   0xD026             BEQ      ??man_rpt_send_body_sensor_3
    506          			memcpy(&rpt_buff2->data[0], &body2->data[0], body2->data_len);
   \   000000A8   0x9801             LDR      R0,[SP, #+4]
   \   000000AA   0x21C8             MOVS     R1,#+200
   \   000000AC   0x5842             LDR      R2,[R0, R1]
   \   000000AE   0x9901             LDR      R1,[SP, #+4]
   \   000000B0   0x9802             LDR      R0,[SP, #+8]
   \   000000B2   0x9000             STR      R0,[SP, #+0]
   \   000000B4   0x9800             LDR      R0,[SP, #+0]
   \   000000B6   0x.... 0x....      BL       __aeabi_memcpy
   \   000000BA   0x9800             LDR      R0,[SP, #+0]
    507          			memcpy(&rpt_buff2->data[body2->data_len], &info2->data[0], info2->data_len);
   \   000000BC   0x9803             LDR      R0,[SP, #+12]
   \   000000BE   0x21CD             MOVS     R1,#+205
   \   000000C0   0x0089             LSLS     R1,R1,#+2        ;; #+820
   \   000000C2   0x5842             LDR      R2,[R0, R1]
   \   000000C4   0x9903             LDR      R1,[SP, #+12]
   \   000000C6   0x9B02             LDR      R3,[SP, #+8]
   \   000000C8   0x469C             MOV      R12,R3
   \   000000CA   0x9B01             LDR      R3,[SP, #+4]
   \   000000CC   0x20C8             MOVS     R0,#+200
   \   000000CE   0x5818             LDR      R0,[R3, R0]
   \   000000D0   0x4663             MOV      R3,R12
   \   000000D2   0x1818             ADDS     R0,R3,R0
   \   000000D4   0x9000             STR      R0,[SP, #+0]
   \   000000D6   0x9800             LDR      R0,[SP, #+0]
   \   000000D8   0x.... 0x....      BL       __aeabi_memcpy
   \   000000DC   0x9800             LDR      R0,[SP, #+0]
    508          			rpt_buff2->data_len = body2->data_len + info2->data_len;
   \   000000DE   0x9801             LDR      R0,[SP, #+4]
   \   000000E0   0x21C8             MOVS     R1,#+200
   \   000000E2   0x5840             LDR      R0,[R0, R1]
   \   000000E4   0x9903             LDR      R1,[SP, #+12]
   \   000000E6   0x22CD             MOVS     R2,#+205
   \   000000E8   0x0092             LSLS     R2,R2,#+2        ;; #+820
   \   000000EA   0x5889             LDR      R1,[R1, R2]
   \   000000EC   0x1840             ADDS     R0,R0,R1
   \   000000EE   0x9902             LDR      R1,[SP, #+8]
   \   000000F0   0x22FF             MOVS     R2,#+255
   \   000000F2   0x0092             LSLS     R2,R2,#+2        ;; #+1020
   \   000000F4   0x5088             STR      R0,[R1, R2]
    509          		}
    510          	}
    511          
    512          
    513          	if (rpt_buff1->data_len != 0) {
   \                     ??man_rpt_send_body_sensor_3: (+1)
   \   000000F6   0x20D7             MOVS     R0,#+215
   \   000000F8   0x00C0             LSLS     R0,R0,#+3        ;; #+1720
   \   000000FA   0x5838             LDR      R0,[R7, R0]
   \   000000FC   0x2800             CMP      R0,#+0
   \   000000FE   0xD01B             BEQ      ??man_rpt_send_body_sensor_4
    514          		ret = man_http_udp_send(&rpt_buff1->data[0],
    515          								rpt_buff1->data_len,
    516          								MAN_RPT_SEQ_SEND1_UDP, 
    517          								man_rpt_req_callback);
   \   00000100   0x....             LDR      R3,??DataTable8_3
   \   00000102   0x220A             MOVS     R2,#+10
   \   00000104   0x20D7             MOVS     R0,#+215
   \   00000106   0x00C0             LSLS     R0,R0,#+3        ;; #+1720
   \   00000108   0x5839             LDR      R1,[R7, R0]
   \   0000010A   0x0038             MOVS     R0,R7
   \   0000010C   0x.... 0x....      BL       man_http_udp_send
   \   00000110   0x0006             MOVS     R6,R0
    518          		if (ret >= 0) {
   \   00000112   0x2E00             CMP      R6,#+0
   \   00000114   0xD403             BMI      ??man_rpt_send_body_sensor_5
    519          			man_rpt_set_sequense(MAN_RPT_SEQ_SEND1_UDP);
   \   00000116   0x200A             MOVS     R0,#+10
   \   00000118   0x.... 0x....      BL       man_rpt_set_sequense
   \   0000011C   0xE018             B        ??man_rpt_send_body_sensor_6
    520          		}
    521          		else {
    522          			man_error_setting(MAN_ERROR_MAN_RPT, body1->data_len, info1->data_len);
   \                     ??man_rpt_send_body_sensor_5: (+1)
   \   0000011E   0x....             LDR      R3,??DataTable8_4  ;; 0x20a
   \   00000120   0x20BE             MOVS     R0,#+190
   \   00000122   0x00C0             LSLS     R0,R0,#+3        ;; #+1520
   \   00000124   0x582A             LDR      R2,[R5, R0]
   \   00000126   0x20C8             MOVS     R0,#+200
   \   00000128   0x5821             LDR      R1,[R4, R0]
   \   0000012A   0x2017             MOVS     R0,#+23
   \   0000012C   0x.... 0x....      BL       man_error_set
    523          			man_rpt_set_sequense(MAN_RPT_SEQ_READY);
   \   00000130   0x2000             MOVS     R0,#+0
   \   00000132   0x.... 0x....      BL       man_rpt_set_sequense
   \   00000136   0xE00B             B        ??man_rpt_send_body_sensor_6
    524          		}
    525          	}
    526          	else {
    527          		man_error_setting(MAN_ERROR_MAN_RPT, body1->data_len, info1->data_len);
   \                     ??man_rpt_send_body_sensor_4: (+1)
   \   00000138   0x....             LDR      R3,??DataTable8_5  ;; 0x20f
   \   0000013A   0x20BE             MOVS     R0,#+190
   \   0000013C   0x00C0             LSLS     R0,R0,#+3        ;; #+1520
   \   0000013E   0x582A             LDR      R2,[R5, R0]
   \   00000140   0x20C8             MOVS     R0,#+200
   \   00000142   0x5821             LDR      R1,[R4, R0]
   \   00000144   0x2017             MOVS     R0,#+23
   \   00000146   0x.... 0x....      BL       man_error_set
    528          		man_rpt_set_sequense(MAN_RPT_SEQ_READY);
   \   0000014A   0x2000             MOVS     R0,#+0
   \   0000014C   0x.... 0x....      BL       man_rpt_set_sequense
    529          	}
    530          
    531          	return ret;
   \                     ??man_rpt_send_body_sensor_6: (+1)
   \   00000150   0x0030             MOVS     R0,R6
   \   00000152   0xB005             ADD      SP,SP,#+20
   \   00000154   0xBDF0             POP      {R4-R7,PC}       ;; return
    532          }
    533          
    534          
    535          /********************************************************************/
    536          /*!
    537           * \name	man_rpt_usb_send_body_sensor
    538           * \brief	サーバに通知するBODYデータ(センサ用)を送信する処理
    539           * \param	なし
    540           * \return  なし
    541           * \note	
    542           */
    543          /********************************************************************/

   \                                 In section .text, align 4, keep-with-next
    544          static int32_t man_rpt_usb_send_body_sensor( void )
    545          {
   \                     man_rpt_usb_send_body_sensor: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
    546          	int32_t		ret=0;
   \   00000004   0x2400             MOVS     R4,#+0
    547          	man_rpt_info1_data_t	*info1 = &man_rpt_work.info1;
   \   00000006   0x....             LDR      R0,??DataTable8_6
   \   00000008   0x9003             STR      R0,[SP, #+12]
    548          	man_rpt_info2_data_t	*info2 = &man_rpt_work.info2;
   \   0000000A   0x....             LDR      R5,??DataTable8_7
    549          	man_rpt_body_data_t		*body1 = &man_rpt_work.body1;
   \   0000000C   0x4827             LDR      R0,??man_rpt_usb_send_body_sensor_0
   \   0000000E   0x9000             STR      R0,[SP, #+0]
    550          	man_rpt_body_data_t		*body2 = &man_rpt_work.body2;
   \   00000010   0x....             LDR      R6,??DataTable8_8
    551          	man_rpt_rpt1_data_t		*rpt_buff1 = &man_rpt_work.rpt_buff1;
   \   00000012   0x....             LDR      R0,??DataTable8
   \   00000014   0x9001             STR      R0,[SP, #+4]
    552          	man_rpt_rpt2_data_t		*rpt_buff2 = &man_rpt_work.rpt_buff2;
   \   00000016   0x....             LDR      R7,??DataTable8_1
    553          
    554          	rpt_buff1->data_len = 0;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x9901             LDR      R1,[SP, #+4]
   \   0000001C   0x22D7             MOVS     R2,#+215
   \   0000001E   0x00D2             LSLS     R2,R2,#+3        ;; #+1720
   \   00000020   0x5088             STR      R0,[R1, R2]
    555          	rpt_buff2->data_len = 0;
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0x21FF             MOVS     R1,#+255
   \   00000026   0x0089             LSLS     R1,R1,#+2        ;; #+1020
   \   00000028   0x5078             STR      R0,[R7, R1]
    556          
    557          	if ( (body1->data_len <= MAN_DATA_BODY_SIZE) && (info1->data_len <= MAN_DATA_INFO_SIZE+MAN_DATA_NMEA_MAX) ) {
   \   0000002A   0x9800             LDR      R0,[SP, #+0]
   \   0000002C   0x21C8             MOVS     R1,#+200
   \   0000002E   0x5840             LDR      R0,[R0, R1]
   \   00000030   0x28C9             CMP      R0,#+201
   \   00000032   0xDA32             BGE      ??man_rpt_usb_send_body_sensor_1
   \   00000034   0x9803             LDR      R0,[SP, #+12]
   \   00000036   0x21BE             MOVS     R1,#+190
   \   00000038   0x00C9             LSLS     R1,R1,#+3        ;; #+1520
   \   0000003A   0x5840             LDR      R0,[R0, R1]
   \   0000003C   0x....             LDR      R1,??DataTable8_9  ;; 0x5f1
   \   0000003E   0x4288             CMP      R0,R1
   \   00000040   0xDA2B             BGE      ??man_rpt_usb_send_body_sensor_1
    558          		if (body1->data_len != 0) {
   \   00000042   0x9800             LDR      R0,[SP, #+0]
   \   00000044   0x21C8             MOVS     R1,#+200
   \   00000046   0x5840             LDR      R0,[R0, R1]
   \   00000048   0x2800             CMP      R0,#+0
   \   0000004A   0xD026             BEQ      ??man_rpt_usb_send_body_sensor_1
    559          			memcpy(&rpt_buff1->data[0], &body1->data[0], body1->data_len);
   \   0000004C   0x9800             LDR      R0,[SP, #+0]
   \   0000004E   0x21C8             MOVS     R1,#+200
   \   00000050   0x5842             LDR      R2,[R0, R1]
   \   00000052   0x9900             LDR      R1,[SP, #+0]
   \   00000054   0x9801             LDR      R0,[SP, #+4]
   \   00000056   0x9002             STR      R0,[SP, #+8]
   \   00000058   0x9802             LDR      R0,[SP, #+8]
   \   0000005A   0x.... 0x....      BL       __aeabi_memcpy
   \   0000005E   0x9802             LDR      R0,[SP, #+8]
    560          			memcpy(&rpt_buff1->data[body1->data_len], &info1->data[0], info1->data_len);
   \   00000060   0x9803             LDR      R0,[SP, #+12]
   \   00000062   0x21BE             MOVS     R1,#+190
   \   00000064   0x00C9             LSLS     R1,R1,#+3        ;; #+1520
   \   00000066   0x5842             LDR      R2,[R0, R1]
   \   00000068   0x9903             LDR      R1,[SP, #+12]
   \   0000006A   0x9B01             LDR      R3,[SP, #+4]
   \   0000006C   0x469C             MOV      R12,R3
   \   0000006E   0x9B00             LDR      R3,[SP, #+0]
   \   00000070   0x20C8             MOVS     R0,#+200
   \   00000072   0x5818             LDR      R0,[R3, R0]
   \   00000074   0x4663             MOV      R3,R12
   \   00000076   0x1818             ADDS     R0,R3,R0
   \   00000078   0x9002             STR      R0,[SP, #+8]
   \   0000007A   0x9802             LDR      R0,[SP, #+8]
   \   0000007C   0x.... 0x....      BL       __aeabi_memcpy
   \   00000080   0x9802             LDR      R0,[SP, #+8]
    561          			rpt_buff1->data_len = body1->data_len + info1->data_len;
   \   00000082   0x9800             LDR      R0,[SP, #+0]
   \   00000084   0x21C8             MOVS     R1,#+200
   \   00000086   0x5840             LDR      R0,[R0, R1]
   \   00000088   0x9903             LDR      R1,[SP, #+12]
   \   0000008A   0x22BE             MOVS     R2,#+190
   \   0000008C   0x00D2             LSLS     R2,R2,#+3        ;; #+1520
   \   0000008E   0x5889             LDR      R1,[R1, R2]
   \   00000090   0x1840             ADDS     R0,R0,R1
   \   00000092   0x9901             LDR      R1,[SP, #+4]
   \   00000094   0x22D7             MOVS     R2,#+215
   \   00000096   0x00D2             LSLS     R2,R2,#+3        ;; #+1720
   \   00000098   0x5088             STR      R0,[R1, R2]
    562          		}
    563          	}
    564          
    565          	if ( (body2->data_len <= MAN_DATA_BODY_SIZE) && (info2->data_len <= MAN_DATA_INFO_SIZE) ) {
   \                     ??man_rpt_usb_send_body_sensor_1: (+1)
   \   0000009A   0x20C8             MOVS     R0,#+200
   \   0000009C   0x5830             LDR      R0,[R6, R0]
   \   0000009E   0x28C9             CMP      R0,#+201
   \   000000A0   0xDA27             BGE      ??man_rpt_usb_send_body_sensor_2
   \   000000A2   0x20CD             MOVS     R0,#+205
   \   000000A4   0x0080             LSLS     R0,R0,#+2        ;; #+820
   \   000000A6   0x5828             LDR      R0,[R5, R0]
   \   000000A8   0x....             LDR      R1,??DataTable8_2  ;; 0x335
   \   000000AA   0xE001             B.N      ??man_rpt_usb_send_body_sensor_3
   \                     ??man_rpt_usb_send_body_sensor_0:
   \   000000AC   0x........         DC32     man_rpt_work+0xD4
   \                     ??man_rpt_usb_send_body_sensor_3: (+1)
   \   000000B0   0x4288             CMP      R0,R1
   \   000000B2   0xDA1E             BGE      ??man_rpt_usb_send_body_sensor_2
    566          		if (body2->data_len != 0) {
   \   000000B4   0x20C8             MOVS     R0,#+200
   \   000000B6   0x5830             LDR      R0,[R6, R0]
   \   000000B8   0x2800             CMP      R0,#+0
   \   000000BA   0xD01A             BEQ      ??man_rpt_usb_send_body_sensor_2
    567          			memcpy(&rpt_buff2->data[0], &body2->data[0], body2->data_len);
   \   000000BC   0x20C8             MOVS     R0,#+200
   \   000000BE   0x5832             LDR      R2,[R6, R0]
   \   000000C0   0x0031             MOVS     R1,R6
   \   000000C2   0x0038             MOVS     R0,R7
   \   000000C4   0x.... 0x....      BL       __aeabi_memcpy
    568          			memcpy(&rpt_buff2->data[body2->data_len], &info2->data[0], info2->data_len);
   \   000000C8   0x20CD             MOVS     R0,#+205
   \   000000CA   0x0080             LSLS     R0,R0,#+2        ;; #+820
   \   000000CC   0x582A             LDR      R2,[R5, R0]
   \   000000CE   0x0029             MOVS     R1,R5
   \   000000D0   0x20C8             MOVS     R0,#+200
   \   000000D2   0x5830             LDR      R0,[R6, R0]
   \   000000D4   0x1838             ADDS     R0,R7,R0
   \   000000D6   0x9000             STR      R0,[SP, #+0]
   \   000000D8   0x9800             LDR      R0,[SP, #+0]
   \   000000DA   0x.... 0x....      BL       __aeabi_memcpy
   \   000000DE   0x9800             LDR      R0,[SP, #+0]
    569          			rpt_buff2->data_len = body2->data_len + info2->data_len;
   \   000000E0   0x20C8             MOVS     R0,#+200
   \   000000E2   0x5830             LDR      R0,[R6, R0]
   \   000000E4   0x21CD             MOVS     R1,#+205
   \   000000E6   0x0089             LSLS     R1,R1,#+2        ;; #+820
   \   000000E8   0x5869             LDR      R1,[R5, R1]
   \   000000EA   0x1840             ADDS     R0,R0,R1
   \   000000EC   0x21FF             MOVS     R1,#+255
   \   000000EE   0x0089             LSLS     R1,R1,#+2        ;; #+1020
   \   000000F0   0x5078             STR      R0,[R7, R1]
    570          		}
    571          	}
    572          
    573          
    574          
    575          	if (rpt_buff1->data_len != 0) {
   \                     ??man_rpt_usb_send_body_sensor_2: (+1)
   \   000000F2   0x9801             LDR      R0,[SP, #+4]
   \   000000F4   0x21D7             MOVS     R1,#+215
   \   000000F6   0x00C9             LSLS     R1,R1,#+3        ;; #+1720
   \   000000F8   0x5840             LDR      R0,[R0, R1]
   \   000000FA   0x2800             CMP      R0,#+0
   \   000000FC   0xD00E             BEQ      ??man_rpt_usb_send_body_sensor_4
    576          		ret = man_usb_rpt_send(&rpt_buff1->data[0],
    577          								rpt_buff1->data_len,
    578          								MAN_RPT_SEQ_SEND1_USB, 
    579          								man_rpt_req_callback);
   \   000000FE   0x....             LDR      R3,??DataTable8_3
   \   00000100   0x2211             MOVS     R2,#+17
   \   00000102   0x9801             LDR      R0,[SP, #+4]
   \   00000104   0x21D7             MOVS     R1,#+215
   \   00000106   0x00C9             LSLS     R1,R1,#+3        ;; #+1720
   \   00000108   0x5841             LDR      R1,[R0, R1]
   \   0000010A   0x9801             LDR      R0,[SP, #+4]
   \   0000010C   0x.... 0x....      BL       man_usb_rpt_send
   \   00000110   0x0004             MOVS     R4,R0
    580          		if (ret >= 0) {
   \   00000112   0x2C00             CMP      R4,#+0
   \   00000114   0xD402             BMI      ??man_rpt_usb_send_body_sensor_4
    581          			man_rpt_set_sequense(MAN_RPT_SEQ_SEND1_USB);
   \   00000116   0x2011             MOVS     R0,#+17
   \   00000118   0x.... 0x....      BL       man_rpt_set_sequense
    582          		}
    583          	}
    584          
    585          	return ret;
   \                     ??man_rpt_usb_send_body_sensor_4: (+1)
   \   0000011C   0x0020             MOVS     R0,R4
   \   0000011E   0xB005             ADD      SP,SP,#+20
   \   00000120   0xBDF0             POP      {R4-R7,PC}       ;; return
    586          }
    587          
    588          /********************************************************************/
    589          /*!
    590           * \name	man_rpt_check_setting
    591           * \brief	GPS測位結果出力サイクル設定情報の変更を確認する処理
    592           * \param	なし
    593           * \return  なし
    594           * \note	
    595           */
    596          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    597          static void man_rpt_check_setting( void )
    598          {
   \                     man_rpt_check_setting: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    599          	man_data_num_gpssleeptime_t	*setting = man_data_get_setting_gpssleeptime();
   \   00000002   0x.... 0x....      BL       man_data_get_setting_gpssleeptime
   \   00000006   0x0004             MOVS     R4,R0
    600          
    601          	// 設定情報が更新された場合
    602          	if ( memcmp(setting, &man_rpt_work.cycle_info.setting, sizeof(man_data_num_gpssleeptime_t)) != 0 ) {
   \   00000008   0x2210             MOVS     R2,#+16
   \   0000000A   0x....             LDR      R1,??DataTable8_10
   \   0000000C   0x0020             MOVS     R0,R4
   \   0000000E   0x.... 0x....      BL       memcmp
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD007             BEQ      ??man_rpt_check_setting_0
    603          		memcpy(&man_rpt_work.cycle_info.setting, setting, sizeof(man_data_num_gpssleeptime_t));
   \   00000016   0x2210             MOVS     R2,#+16
   \   00000018   0x0021             MOVS     R1,R4
   \   0000001A   0x....             LDR      R4,??DataTable8_10
   \   0000001C   0x0020             MOVS     R0,R4
   \   0000001E   0x.... 0x....      BL       __aeabi_memcpy
    604          
    605          		// cycle counterを初期化
    606          		man_rpt_init_cycle_counter();
   \   00000022   0x.... 0x....      BL       man_rpt_init_cycle_counter
    607          	}
    608          }
   \                     ??man_rpt_check_setting_0: (+1)
   \   00000026   0xBD10             POP      {R4,PC}          ;; return
    609          
    610          
    611          /********************************************************************/
    612          /*	extern関数                                                      */
    613          /********************************************************************/
    614          
    615          /********************************************************************/
    616          /*!
    617           * \name	man_rpt_init
    618           * \brief	レポート管理の初期化処理
    619           * \param	なし
    620           * \return  なし
    621           * \note	起動時に、呼ばれること
    622           */
    623          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    624          void man_rpt_init(void)
    625          {
   \                     man_rpt_init: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    626          	// 内部変数を初期化する
    627          	memset(&man_rpt_work, 0, sizeof(man_rpt_work_t));
   \   00000002   0x....             LDR      R1,??DataTable8_11  ;; 0x16b8
   \   00000004   0x2200             MOVS     R2,#+0
   \   00000006   0x....             LDR      R4,??DataTable8_12
   \   00000008   0x0020             MOVS     R0,R4
   \   0000000A   0x.... 0x....      BL       __aeabi_memset
    628          	// 状態変化の通知を依頼する
    629          	man_http_udp_state(MAN_RPT_NOTI_STATE, man_rpt_req_callback);
   \   0000000E   0x....             LDR      R1,??DataTable8_3
   \   00000010   0x20FA             MOVS     R0,#+250
   \   00000012   0x0080             LSLS     R0,R0,#+2        ;; #+1000
   \   00000014   0x.... 0x....      BL       man_http_udp_state
    630          	// GPS測位結果出力サイクル設定情報の変更を確認する
    631          	man_rpt_check_setting();
   \   00000018   0x.... 0x....      BL       man_rpt_check_setting
    632          }
   \   0000001C   0xBD10             POP      {R4,PC}          ;; return
    633          
    634          
    635          /********************************************************************/
    636          /*!
    637           * \name	man_rpt_main
    638           * \brief	レポート管理のメイン処理
    639           * \param	なし
    640           * \return  なし
    641           * \note	毎回、呼ばれること
    642           */
    643          /********************************************************************/

   \                                 In section .text, align 4, keep-with-next
    644          void man_rpt_main( void )
    645          {
   \                     man_rpt_main: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    646          	int32_t					ret;
    647          	int32_t					sts = man_http_get_status();
   \   00000002   0x.... 0x....      BL       man_http_get_status
   \   00000006   0x0004             MOVS     R4,R0
    648          	man_data_get_sensor_t	*sensor = man_data_get_sensor();
   \   00000008   0x.... 0x....      BL       man_data_get_sensor
   \   0000000C   0x0005             MOVS     R5,R0
    649          	uint32_t				delay_timer;
    650          
    651          	// ***************************
    652          	// GPS測位結果出力サイクル管理処理
    653          	// ***************************
    654          	switch (man_rpt_work.cycle_req) {
   \   0000000E   0x488D             LDR      R0,??man_rpt_main_0
   \   00000010   0x6800             LDR      R0,[R0, #+0]
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD005             BEQ      ??man_rpt_main_1
   \   00000016   0x2802             CMP      R0,#+2
   \   00000018   0xD01D             BEQ      ??man_rpt_main_2
   \   0000001A   0xD303             BCC      ??man_rpt_main_3
   \   0000001C   0x2803             CMP      R0,#+3
   \   0000001E   0xD02C             BEQ      ??man_rpt_main_4
   \   00000020   0xE033             B        ??man_rpt_main_5
    655          	case MAN_RPT_CYCLE_REQ_READY:
    656          		break;
   \                     ??man_rpt_main_1: (+1)
   \   00000022   0xE035             B        ??man_rpt_main_6
    657          
    658          	case MAN_RPT_CYCLE_REQ_SEND:
    659          		if (man_rpt_work.sequense == MAN_RPT_SEQ_READY) {
   \                     ??man_rpt_main_3: (+1)
   \   00000024   0x4888             LDR      R0,??man_rpt_main_0+0x4
   \   00000026   0x7800             LDRB     R0,[R0, #+0]
   \   00000028   0x2800             CMP      R0,#+0
   \   0000002A   0xD113             BNE      ??man_rpt_main_7
    660          			// サーバに通知するBODYデータ(センサ用)を作成
    661          			man_rpt_make_body_sensor(MAN_MSG_TYPE_REPORT);
   \   0000002C   0x2004             MOVS     R0,#+4
   \   0000002E   0x.... 0x....      BL       man_rpt_make_body_sensor
    662          
    663          			// CLOSE時はOPENから始める
    664          			if (man_rpt_work.udp_sts != MAN_RPT_UDP_STS_OPEN) {
   \   00000032   0x4886             LDR      R0,??man_rpt_main_0+0x8
   \   00000034   0x7800             LDRB     R0,[R0, #+0]
   \   00000036   0x2801             CMP      R0,#+1
   \   00000038   0xD006             BEQ      ??man_rpt_main_8
    665          				// UDP OPEN要求
    666          				man_rpt_set_sequense(MAN_RPT_SEQ_OPEN_UDP_REQ);
   \   0000003A   0x2001             MOVS     R0,#+1
   \   0000003C   0x.... 0x....      BL       man_rpt_set_sequense
    667          				man_rpt_work.retry = 0;
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0x49AD             LDR      R1,??man_rpt_main_9
   \   00000044   0x6008             STR      R0,[R1, #+0]
   \   00000046   0xE002             B        ??man_rpt_main_10
    668          			}
    669          			// OPEN時は送信する
    670          			else {
    671          				// UDP送信要求
    672          				man_rpt_set_sequense(MAN_RPT_SEQ_SEND1_UDP_REQ);
   \                     ??man_rpt_main_8: (+1)
   \   00000048   0x2009             MOVS     R0,#+9
   \   0000004A   0x.... 0x....      BL       man_rpt_set_sequense
    673          			}
    674          			man_rpt_work.cycle_req = MAN_RPT_CYCLE_REQ_READY;
   \                     ??man_rpt_main_10: (+1)
   \   0000004E   0x2000             MOVS     R0,#+0
   \   00000050   0x497C             LDR      R1,??man_rpt_main_0
   \   00000052   0x6008             STR      R0,[R1, #+0]
    675          		}
    676          		break;
   \                     ??man_rpt_main_7: (+1)
   \   00000054   0xE01C             B        ??man_rpt_main_6
    677          
    678          	case MAN_RPT_CYCLE_REQ_CLOSE:
    679          		if (man_rpt_work.sequense == MAN_RPT_SEQ_READY) {
   \                     ??man_rpt_main_2: (+1)
   \   00000056   0x487C             LDR      R0,??man_rpt_main_0+0x4
   \   00000058   0x7800             LDRB     R0,[R0, #+0]
   \   0000005A   0x2800             CMP      R0,#+0
   \   0000005C   0xD10C             BNE      ??man_rpt_main_11
    680          			if (man_rpt_work.udp_sts != MAN_RPT_UDP_STS_CLOSE) {
   \   0000005E   0x487B             LDR      R0,??man_rpt_main_0+0x8
   \   00000060   0x7800             LDRB     R0,[R0, #+0]
   \   00000062   0x2800             CMP      R0,#+0
   \   00000064   0xD005             BEQ      ??man_rpt_main_12
    681          				// CLOSE UDP開始
    682          				man_rpt_set_sequense(MAN_RPT_SEQ_CLOSE_UDP_REQ);
   \   00000066   0x2005             MOVS     R0,#+5
   \   00000068   0x.... 0x....      BL       man_rpt_set_sequense
    683          				man_rpt_work.retry = 0;
   \   0000006C   0x2000             MOVS     R0,#+0
   \   0000006E   0x49A2             LDR      R1,??man_rpt_main_9
   \   00000070   0x6008             STR      R0,[R1, #+0]
    684          			}
    685          			man_rpt_work.cycle_req = MAN_RPT_CYCLE_REQ_READY;
   \                     ??man_rpt_main_12: (+1)
   \   00000072   0x2000             MOVS     R0,#+0
   \   00000074   0x4973             LDR      R1,??man_rpt_main_0
   \   00000076   0x6008             STR      R0,[R1, #+0]
    686          		}
    687          		break;
   \                     ??man_rpt_main_11: (+1)
   \   00000078   0xE00A             B        ??man_rpt_main_6
    688          
    689          	case MAN_RPT_CYCLE_REQ_USB_SEND:
    690          		if (man_rpt_work.sequense == MAN_RPT_SEQ_READY) {
   \                     ??man_rpt_main_4: (+1)
   \   0000007A   0x4873             LDR      R0,??man_rpt_main_0+0x4
   \   0000007C   0x7800             LDRB     R0,[R0, #+0]
   \   0000007E   0x2800             CMP      R0,#+0
   \   00000080   0xD102             BNE      ??man_rpt_main_13
    691          			// BODYデータをUSB出力開始
    692          			man_rpt_set_sequense(MAN_RPT_SEQ_SEND1_USB_REQ);
   \   00000082   0x2010             MOVS     R0,#+16
   \   00000084   0x.... 0x....      BL       man_rpt_set_sequense
    693          		}
    694          		break;
   \                     ??man_rpt_main_13: (+1)
   \   00000088   0xE002             B        ??man_rpt_main_6
    695          
    696          	default:
    697          		man_rpt_work.cycle_req = MAN_RPT_CYCLE_REQ_READY;
   \                     ??man_rpt_main_5: (+1)
   \   0000008A   0x2000             MOVS     R0,#+0
   \   0000008C   0x496D             LDR      R1,??man_rpt_main_0
   \   0000008E   0x6008             STR      R0,[R1, #+0]
    698          		break;
    699          	}
    700          
    701          
    702          	// ***************************
    703          	// 要求処理
    704          	// ***************************
    705          	switch (man_rpt_work.request.req_cmd) {
   \                     ??man_rpt_main_6: (+1)
   \   00000090   0x489A             LDR      R0,??man_rpt_main_9+0x4
   \   00000092   0x6F80             LDR      R0,[R0, #+120]
   \   00000094   0x2800             CMP      R0,#+0
   \   00000096   0xD002             BEQ      ??man_rpt_main_14
   \   00000098   0x2801             CMP      R0,#+1
   \   0000009A   0xD001             BEQ      ??man_rpt_main_15
   \   0000009C   0xE013             B        ??man_rpt_main_16
    706          	case MAN_RPT_REQ_CMD_READY:
    707          		break;
   \                     ??man_rpt_main_14: (+1)
   \   0000009E   0xE012             B        ??man_rpt_main_17
    708          	case MAN_RPT_REQ_CMD_CLOSE:
    709          		if (man_rpt_work.sequense == MAN_RPT_SEQ_READY) {
   \                     ??man_rpt_main_15: (+1)
   \   000000A0   0x4869             LDR      R0,??man_rpt_main_0+0x4
   \   000000A2   0x7800             LDRB     R0,[R0, #+0]
   \   000000A4   0x2800             CMP      R0,#+0
   \   000000A6   0xD10D             BNE      ??man_rpt_main_18
    710          			if (man_rpt_work.udp_sts != MAN_RPT_UDP_STS_CLOSE) {
   \   000000A8   0x4868             LDR      R0,??man_rpt_main_0+0x8
   \   000000AA   0x7800             LDRB     R0,[R0, #+0]
   \   000000AC   0x2800             CMP      R0,#+0
   \   000000AE   0xD006             BEQ      ??man_rpt_main_19
    711          				// CLOSE UDP開始
    712          				man_rpt_set_sequense(MAN_RPT_SEQ_CLOSE_UDP_REQ);
   \   000000B0   0x2005             MOVS     R0,#+5
   \   000000B2   0x.... 0x....      BL       man_rpt_set_sequense
    713          				man_rpt_work.retry = 0;
   \   000000B6   0x2000             MOVS     R0,#+0
   \   000000B8   0x498F             LDR      R1,??man_rpt_main_9
   \   000000BA   0x6008             STR      R0,[R1, #+0]
   \   000000BC   0xE002             B        ??man_rpt_main_18
    714          			}
    715          			// すでにCLOSE状態
    716          			else {
    717          				// 応答を返す
    718          				man_rpt_return_callback(MAN_RPT_STATUS_OK);
   \                     ??man_rpt_main_19: (+1)
   \   000000BE   0x2000             MOVS     R0,#+0
   \   000000C0   0x.... 0x....      BL       man_rpt_return_callback
    719          			}
    720          		}
    721          		break;
   \                     ??man_rpt_main_18: (+1)
   \   000000C4   0xE7FF             B        ??man_rpt_main_17
    722          	default:
    723          		break;
    724          	}
    725          
    726          
    727          	// ***************************
    728          	// 電波状況(圏内/圏外)監視処理
    729          	// ***************************
    730          	if (man_rpt_work.rssi_sts != sensor->rssi_sts) {
   \                     ??man_rpt_main_16: (+1)
   \                     ??man_rpt_main_17: (+1)
   \   000000C6   0x48A5             LDR      R0,??man_rpt_main_20
   \   000000C8   0x7800             LDRB     R0,[R0, #+0]
   \   000000CA   0x49A5             LDR      R1,??man_rpt_main_20+0x4  ;; 0xbd8
   \   000000CC   0x5C69             LDRB     R1,[R5, R1]
   \   000000CE   0x4288             CMP      R0,R1
   \   000000D0   0xD00B             BEQ      ??man_rpt_main_21
    731          		man_rpt_work.rssi_sts = sensor->rssi_sts;
   \   000000D2   0x48A3             LDR      R0,??man_rpt_main_20+0x4  ;; 0xbd8
   \   000000D4   0x5C28             LDRB     R0,[R5, R0]
   \   000000D6   0x49A1             LDR      R1,??man_rpt_main_20
   \   000000D8   0x7008             STRB     R0,[R1, #+0]
    732          
    733          		switch (man_rpt_work.rssi_sts) {
   \   000000DA   0x48A0             LDR      R0,??man_rpt_main_20
   \   000000DC   0x7800             LDRB     R0,[R0, #+0]
   \   000000DE   0x2800             CMP      R0,#+0
   \   000000E0   0xD002             BEQ      ??man_rpt_main_22
   \   000000E2   0x2801             CMP      R0,#+1
   \   000000E4   0xD001             BEQ      ??man_rpt_main_23
   \   000000E6   0xE000             B        ??man_rpt_main_21
    734          		case MAN_DATA_RSSI_STS_NG:			// 圏外
    735          			break;
   \                     ??man_rpt_main_22: (+1)
   \   000000E8   0xE7FF             B        ??man_rpt_main_21
    736          		case MAN_DATA_RSSI_STS_OK:			// 圏内
    737          			break;
    738          		}
    739          	}
    740          
    741          
    742          
    743          
    744          
    745          	// ***************************
    746          	// 応答処理
    747          	// ***************************
    748          	if (man_rpt_work.resp_cmd.flag == 1) {
   \                     ??man_rpt_main_23: (+1)
   \                     ??man_rpt_main_21: (+1)
   \   000000EA   0x489E             LDR      R0,??man_rpt_main_20+0x8
   \   000000EC   0x6800             LDR      R0,[R0, #+0]
   \   000000EE   0x2801             CMP      R0,#+1
   \   000000F0   0xD000             BEQ      .+4
   \   000000F2   0xE0C5             B        ??man_rpt_main_24
    749          		man_rpt_work.resp_cmd.flag = 0;
   \   000000F4   0x2000             MOVS     R0,#+0
   \   000000F6   0x499B             LDR      R1,??man_rpt_main_20+0x8
   \   000000F8   0x6008             STR      R0,[R1, #+0]
    750          
    751          		// 状態変化通知処理
    752          		if (man_rpt_work.resp_cmd.id == MAN_RPT_NOTI_STATE) {
   \   000000FA   0x489B             LDR      R0,??man_rpt_main_20+0xC
   \   000000FC   0x6800             LDR      R0,[R0, #+0]
   \   000000FE   0x21FA             MOVS     R1,#+250
   \   00000100   0x0089             LSLS     R1,R1,#+2        ;; #+1000
   \   00000102   0x4288             CMP      R0,R1
   \   00000104   0xD112             BNE      ??man_rpt_main_25
    753          			switch (man_rpt_work.resp_cmd.status) {
   \   00000106   0x4899             LDR      R0,??man_rpt_main_20+0x10
   \   00000108   0x6800             LDR      R0,[R0, #+0]
   \   0000010A   0x2801             CMP      R0,#+1
   \   0000010C   0xD002             BEQ      ??man_rpt_main_26
   \   0000010E   0x2802             CMP      R0,#+2
   \   00000110   0xD00A             BEQ      ??man_rpt_main_27
   \   00000112   0xE00A             B        ??man_rpt_main_28
    754          			case MAN_HTTP_STATE_CLOSE:
    755          				man_rpt_set_sequense(MAN_RPT_SEQ_READY);
   \                     ??man_rpt_main_26: (+1)
   \   00000114   0x2000             MOVS     R0,#+0
   \   00000116   0x.... 0x....      BL       man_rpt_set_sequense
    756          				// レポート報告を停止する
    757          				man_rpt_work.udp_sts = MAN_RPT_UDP_STS_CLOSE;
   \   0000011A   0x2000             MOVS     R0,#+0
   \   0000011C   0x494B             LDR      R1,??man_rpt_main_0+0x8
   \   0000011E   0x7008             STRB     R0,[R1, #+0]
    758          				// 送信終了
    759          				man_rpt_work.trans_mode = 0;
   \   00000120   0x2000             MOVS     R0,#+0
   \   00000122   0x4976             LDR      R1,??man_rpt_main_9+0x4
   \   00000124   0x6708             STR      R0,[R1, #+112]
    760          				break;
   \   00000126   0xE0AB             B        ??man_rpt_main_24
    761          			case MAN_HTTP_STATE_OPEN:
    762          				break;
   \                     ??man_rpt_main_27: (+1)
   \   00000128   0xE0AA             B        ??man_rpt_main_24
    763          			default:
    764          				break;
   \                     ??man_rpt_main_28: (+1)
   \   0000012A   0xE0A9             B        ??man_rpt_main_24
    765          			}
    766          		}
    767          		
    768          		// 応答コマンド処理
    769          		else {
    770          			if (man_rpt_work.resp_cmd.status == MAN_HTTP_STATUS_OK) {
   \                     ??man_rpt_main_25: (+1)
   \   0000012C   0x488F             LDR      R0,??man_rpt_main_20+0x10
   \   0000012E   0x6800             LDR      R0,[R0, #+0]
   \   00000130   0x2800             CMP      R0,#+0
   \   00000132   0xD147             BNE      ??man_rpt_main_29
    771          				switch (man_rpt_work.resp_cmd.id) {
   \   00000134   0x488C             LDR      R0,??man_rpt_main_20+0xC
   \   00000136   0x6800             LDR      R0,[R0, #+0]
   \   00000138   0x2802             CMP      R0,#+2
   \   0000013A   0xD00A             BEQ      ??man_rpt_main_30
   \   0000013C   0x2806             CMP      R0,#+6
   \   0000013E   0xD010             BEQ      ??man_rpt_main_31
   \   00000140   0x280A             CMP      R0,#+10
   \   00000142   0xD016             BEQ      ??man_rpt_main_32
   \   00000144   0x280D             CMP      R0,#+13
   \   00000146   0xD01C             BEQ      ??man_rpt_main_33
   \   00000148   0x2811             CMP      R0,#+17
   \   0000014A   0xD022             BEQ      ??man_rpt_main_34
   \   0000014C   0x2814             CMP      R0,#+20
   \   0000014E   0xD028             BEQ      ??man_rpt_main_35
   \   00000150   0xE02F             B        ??man_rpt_main_36
    772          				case MAN_RPT_SEQ_OPEN_UDP:
    773          					if (man_rpt_work.sequense == MAN_RPT_SEQ_OPEN_UDP) {
   \                     ??man_rpt_main_30: (+1)
   \   00000152   0x483D             LDR      R0,??man_rpt_main_0+0x4
   \   00000154   0x7800             LDRB     R0,[R0, #+0]
   \   00000156   0x2802             CMP      R0,#+2
   \   00000158   0xD102             BNE      ??man_rpt_main_37
    774          						man_rpt_set_sequense(MAN_RPT_SEQ_OPEN_UDP_OK);
   \   0000015A   0x2003             MOVS     R0,#+3
   \   0000015C   0x.... 0x....      BL       man_rpt_set_sequense
    775          					}
    776          					break;
   \                     ??man_rpt_main_37: (+1)
   \   00000160   0xE08E             B        ??man_rpt_main_24
    777          
    778          				case MAN_RPT_SEQ_CLOSE_UDP:
    779          					if (man_rpt_work.sequense == MAN_RPT_SEQ_CLOSE_UDP) {
   \                     ??man_rpt_main_31: (+1)
   \   00000162   0x4839             LDR      R0,??man_rpt_main_0+0x4
   \   00000164   0x7800             LDRB     R0,[R0, #+0]
   \   00000166   0x2806             CMP      R0,#+6
   \   00000168   0xD102             BNE      ??man_rpt_main_38
    780          						man_rpt_set_sequense(MAN_RPT_SEQ_CLOSE_UDP_OK);
   \   0000016A   0x2007             MOVS     R0,#+7
   \   0000016C   0x.... 0x....      BL       man_rpt_set_sequense
    781          					}
    782          					break;
   \                     ??man_rpt_main_38: (+1)
   \   00000170   0xE086             B        ??man_rpt_main_24
    783          
    784          				case MAN_RPT_SEQ_SEND1_UDP:
    785          					if (man_rpt_work.sequense == MAN_RPT_SEQ_SEND1_UDP) {
   \                     ??man_rpt_main_32: (+1)
   \   00000172   0x4835             LDR      R0,??man_rpt_main_0+0x4
   \   00000174   0x7800             LDRB     R0,[R0, #+0]
   \   00000176   0x280A             CMP      R0,#+10
   \   00000178   0xD102             BNE      ??man_rpt_main_39
    786          						man_rpt_set_sequense(MAN_RPT_SEQ_SEND1_UDP_OK);
   \   0000017A   0x200B             MOVS     R0,#+11
   \   0000017C   0x.... 0x....      BL       man_rpt_set_sequense
    787          					}
    788          					break;
   \                     ??man_rpt_main_39: (+1)
   \   00000180   0xE07E             B        ??man_rpt_main_24
    789          
    790          				case MAN_RPT_SEQ_SEND2_UDP:
    791          					if (man_rpt_work.sequense == MAN_RPT_SEQ_SEND2_UDP) {
   \                     ??man_rpt_main_33: (+1)
   \   00000182   0x4831             LDR      R0,??man_rpt_main_0+0x4
   \   00000184   0x7800             LDRB     R0,[R0, #+0]
   \   00000186   0x280D             CMP      R0,#+13
   \   00000188   0xD102             BNE      ??man_rpt_main_40
    792          						man_rpt_set_sequense(MAN_RPT_SEQ_SEND2_UDP_OK);
   \   0000018A   0x200E             MOVS     R0,#+14
   \   0000018C   0x.... 0x....      BL       man_rpt_set_sequense
    793          					}
    794          					break;
   \                     ??man_rpt_main_40: (+1)
   \   00000190   0xE076             B        ??man_rpt_main_24
    795          
    796          				case MAN_RPT_SEQ_SEND1_USB:
    797          					if (man_rpt_work.sequense == MAN_RPT_SEQ_SEND1_USB) {
   \                     ??man_rpt_main_34: (+1)
   \   00000192   0x482D             LDR      R0,??man_rpt_main_0+0x4
   \   00000194   0x7800             LDRB     R0,[R0, #+0]
   \   00000196   0x2811             CMP      R0,#+17
   \   00000198   0xD102             BNE      ??man_rpt_main_41
    798          						man_rpt_set_sequense(MAN_RPT_SEQ_SEND1_USB_OK);
   \   0000019A   0x2012             MOVS     R0,#+18
   \   0000019C   0x.... 0x....      BL       man_rpt_set_sequense
    799          					}
    800          					break;
   \                     ??man_rpt_main_41: (+1)
   \   000001A0   0xE06E             B        ??man_rpt_main_24
    801          
    802          				case MAN_RPT_SEQ_SEND2_USB:
    803          					if (man_rpt_work.sequense == MAN_RPT_SEQ_SEND2_USB) {
   \                     ??man_rpt_main_35: (+1)
   \   000001A2   0x4829             LDR      R0,??man_rpt_main_0+0x4
   \   000001A4   0x7800             LDRB     R0,[R0, #+0]
   \   000001A6   0x2814             CMP      R0,#+20
   \   000001A8   0xD102             BNE      ??man_rpt_main_42
    804          						man_rpt_set_sequense(MAN_RPT_SEQ_SEND2_USB_OK);
   \   000001AA   0x2015             MOVS     R0,#+21
   \   000001AC   0x.... 0x....      BL       man_rpt_set_sequense
    805          					}
    806          					break;
   \                     ??man_rpt_main_42: (+1)
   \   000001B0   0xE066             B        ??man_rpt_main_24
    807          
    808          				default:
    809          					man_error_setting(MAN_ERROR_MAN_RPT, man_rpt_work.resp_cmd.id, man_rpt_work.sequense);
   \                     ??man_rpt_main_36: (+1)
   \   000001B2   0x4BA1             LDR      R3,??man_rpt_main_43  ;; 0x329
   \   000001B4   0x4824             LDR      R0,??man_rpt_main_0+0x4
   \   000001B6   0x7802             LDRB     R2,[R0, #+0]
   \   000001B8   0x486B             LDR      R0,??man_rpt_main_20+0xC
   \   000001BA   0x6801             LDR      R1,[R0, #+0]
   \   000001BC   0x2017             MOVS     R0,#+23
   \   000001BE   0x.... 0x....      BL       man_error_set
    810          					break;
   \   000001C2   0xE05D             B        ??man_rpt_main_24
    811          				}
    812          			}
    813          
    814          			// 応答が異常
    815          			else {
    816          				switch (man_rpt_work.resp_cmd.id) {
   \                     ??man_rpt_main_29: (+1)
   \   000001C4   0x4868             LDR      R0,??man_rpt_main_20+0xC
   \   000001C6   0x6800             LDR      R0,[R0, #+0]
   \   000001C8   0x2802             CMP      R0,#+2
   \   000001CA   0xD00A             BEQ      ??man_rpt_main_44
   \   000001CC   0x2806             CMP      R0,#+6
   \   000001CE   0xD014             BEQ      ??man_rpt_main_45
   \   000001D0   0x280A             CMP      R0,#+10
   \   000001D2   0xD01E             BEQ      ??man_rpt_main_46
   \   000001D4   0x280D             CMP      R0,#+13
   \   000001D6   0xD028             BEQ      ??man_rpt_main_47
   \   000001D8   0x2811             CMP      R0,#+17
   \   000001DA   0xD039             BEQ      ??man_rpt_main_48
   \   000001DC   0x2814             CMP      R0,#+20
   \   000001DE   0xD03F             BEQ      ??man_rpt_main_49
   \   000001E0   0xE046             B        ??man_rpt_main_50
    817          				case MAN_RPT_SEQ_OPEN_UDP:
    818          					if (man_rpt_work.sequense == MAN_RPT_SEQ_OPEN_UDP) {
   \                     ??man_rpt_main_44: (+1)
   \   000001E2   0x4819             LDR      R0,??man_rpt_main_0+0x4
   \   000001E4   0x7800             LDRB     R0,[R0, #+0]
   \   000001E6   0x2802             CMP      R0,#+2
   \   000001E8   0xD106             BNE      ??man_rpt_main_51
    819          						// 時間監視開始
    820          						man_rpt_work.delay_timer = man_timer_get_1ms_count();
   \   000001EA   0x.... 0x....      BL       man_timer_get_1ms_count
   \   000001EE   0x49BD             LDR      R1,??man_rpt_main_52
   \   000001F0   0x6008             STR      R0,[R1, #+0]
    821          						man_rpt_set_sequense(MAN_RPT_SEQ_OPEN_UDP_NG);
   \   000001F2   0x2004             MOVS     R0,#+4
   \   000001F4   0x.... 0x....      BL       man_rpt_set_sequense
    822          					}
    823          					break;
   \                     ??man_rpt_main_51: (+1)
   \   000001F8   0xE042             B        ??man_rpt_main_24
    824          
    825          				case MAN_RPT_SEQ_CLOSE_UDP:
    826          					if (man_rpt_work.sequense == MAN_RPT_SEQ_CLOSE_UDP) {
   \                     ??man_rpt_main_45: (+1)
   \   000001FA   0x4813             LDR      R0,??man_rpt_main_0+0x4
   \   000001FC   0x7800             LDRB     R0,[R0, #+0]
   \   000001FE   0x2806             CMP      R0,#+6
   \   00000200   0xD106             BNE      ??man_rpt_main_53
    827          						// 時間監視開始
    828          						man_rpt_work.delay_timer = man_timer_get_1ms_count();
   \   00000202   0x.... 0x....      BL       man_timer_get_1ms_count
   \   00000206   0x49B7             LDR      R1,??man_rpt_main_52
   \   00000208   0x6008             STR      R0,[R1, #+0]
    829          						man_rpt_set_sequense(MAN_RPT_SEQ_CLOSE_UDP_NG);
   \   0000020A   0x2008             MOVS     R0,#+8
   \   0000020C   0x.... 0x....      BL       man_rpt_set_sequense
    830          					}
    831          					break;
   \                     ??man_rpt_main_53: (+1)
   \   00000210   0xE036             B        ??man_rpt_main_24
    832          
    833          				case MAN_RPT_SEQ_SEND1_UDP:
    834          					if (man_rpt_work.sequense == MAN_RPT_SEQ_SEND1_UDP) {
   \                     ??man_rpt_main_46: (+1)
   \   00000212   0x480D             LDR      R0,??man_rpt_main_0+0x4
   \   00000214   0x7800             LDRB     R0,[R0, #+0]
   \   00000216   0x280A             CMP      R0,#+10
   \   00000218   0xD106             BNE      ??man_rpt_main_54
    835          						// 時間監視開始
    836          						man_rpt_work.delay_timer = man_timer_get_1ms_count();
   \   0000021A   0x.... 0x....      BL       man_timer_get_1ms_count
   \   0000021E   0x49B1             LDR      R1,??man_rpt_main_52
   \   00000220   0x6008             STR      R0,[R1, #+0]
    837          						man_rpt_set_sequense(MAN_RPT_SEQ_SEND1_UDP_NG);
   \   00000222   0x200C             MOVS     R0,#+12
   \   00000224   0x.... 0x....      BL       man_rpt_set_sequense
    838          					}
    839          					break;
   \                     ??man_rpt_main_54: (+1)
   \   00000228   0xE02A             B        ??man_rpt_main_24
    840          
    841          				case MAN_RPT_SEQ_SEND2_UDP:
    842          					if (man_rpt_work.sequense == MAN_RPT_SEQ_SEND2_UDP) {
   \                     ??man_rpt_main_47: (+1)
   \   0000022A   0x4807             LDR      R0,??man_rpt_main_0+0x4
   \   0000022C   0x7800             LDRB     R0,[R0, #+0]
   \   0000022E   0x280D             CMP      R0,#+13
   \   00000230   0xD106             BNE      ??man_rpt_main_55
    843          						// 時間監視開始
    844          						man_rpt_work.delay_timer = man_timer_get_1ms_count();
   \   00000232   0x.... 0x....      BL       man_timer_get_1ms_count
   \   00000236   0x49AB             LDR      R1,??man_rpt_main_52
   \   00000238   0x6008             STR      R0,[R1, #+0]
    845          						man_rpt_set_sequense(MAN_RPT_SEQ_SEND2_UDP_NG);
   \   0000023A   0x200F             MOVS     R0,#+15
   \   0000023C   0x.... 0x....      BL       man_rpt_set_sequense
    846          					}
    847          					break;
   \                     ??man_rpt_main_55: (+1)
   \   00000240   0xE01E             B        ??man_rpt_main_24
   \   00000242   0xBF00             Nop      
   \                     ??man_rpt_main_0:
   \   00000244   0x........         DC32     man_rpt_work+0xC4
   \   00000248   0x........         DC32     man_rpt_work+0x74
   \   0000024C   0x........         DC32     man_rpt_work+0x6C
    848          
    849          				case MAN_RPT_SEQ_SEND1_USB:
    850          					if (man_rpt_work.sequense == MAN_RPT_SEQ_SEND1_USB) {
   \                     ??man_rpt_main_48: (+1)
   \   00000250   0x48B9             LDR      R0,??man_rpt_main_56
   \   00000252   0x7800             LDRB     R0,[R0, #+0]
   \   00000254   0x2811             CMP      R0,#+17
   \   00000256   0xD102             BNE      ??man_rpt_main_57
    851          						man_rpt_set_sequense(MAN_RPT_SEQ_SEND1_USB_NG);
   \   00000258   0x2013             MOVS     R0,#+19
   \   0000025A   0x.... 0x....      BL       man_rpt_set_sequense
    852          					}
    853          					break;
   \                     ??man_rpt_main_57: (+1)
   \   0000025E   0xE00F             B        ??man_rpt_main_24
    854          
    855          				case MAN_RPT_SEQ_SEND2_USB:
    856          					if (man_rpt_work.sequense == MAN_RPT_SEQ_SEND2_USB) {
   \                     ??man_rpt_main_49: (+1)
   \   00000260   0x48B5             LDR      R0,??man_rpt_main_56
   \   00000262   0x7800             LDRB     R0,[R0, #+0]
   \   00000264   0x2814             CMP      R0,#+20
   \   00000266   0xD102             BNE      ??man_rpt_main_58
    857          						man_rpt_set_sequense(MAN_RPT_SEQ_SEND2_USB_NG);
   \   00000268   0x2016             MOVS     R0,#+22
   \   0000026A   0x.... 0x....      BL       man_rpt_set_sequense
    858          					}
    859          					break;
   \                     ??man_rpt_main_58: (+1)
   \   0000026E   0xE007             B        ??man_rpt_main_24
    860          
    861          				default:
    862          					man_error_setting(MAN_ERROR_MAN_RPT, man_rpt_work.resp_cmd.id, man_rpt_work.sequense);
   \                     ??man_rpt_main_50: (+1)
   \   00000270   0x4BB8             LDR      R3,??man_rpt_main_59  ;; 0x35e
   \   00000272   0x48B1             LDR      R0,??man_rpt_main_56
   \   00000274   0x7802             LDRB     R2,[R0, #+0]
   \   00000276   0x483C             LDR      R0,??man_rpt_main_20+0xC
   \   00000278   0x6801             LDR      R1,[R0, #+0]
   \   0000027A   0x2017             MOVS     R0,#+23
   \   0000027C   0x.... 0x....      BL       man_error_set
    863          					break;
    864          				}
    865          			}
    866          		}
    867          	}
    868          
    869          
    870          	// ***************************
    871          	// シーケンス処理
    872          	// ***************************
    873          	switch (man_rpt_work.sequense) {
   \                     ??man_rpt_main_24: (+1)
   \   00000280   0x48AD             LDR      R0,??man_rpt_main_56
   \   00000282   0x7800             LDRB     R0,[R0, #+0]
   \   00000284   0x2800             CMP      R0,#+0
   \   00000286   0xD03B             BEQ      ??man_rpt_main_60
   \   00000288   0x2802             CMP      R0,#+2
   \   0000028A   0xD05E             BEQ      ??man_rpt_main_61
   \   0000028C   0xD339             BCC      ??man_rpt_main_62
   \   0000028E   0x2804             CMP      R0,#+4
   \   00000290   0xD06E             BEQ      ??man_rpt_main_63
   \   00000292   0xD35B             BCC      ??man_rpt_main_64
   \   00000294   0x2806             CMP      R0,#+6
   \   00000296   0xD100             BNE      .+4
   \   00000298   0xE0D0             B        ??man_rpt_main_65
   \   0000029A   0xD200             BCS      .+4
   \   0000029C   0xE0B2             B        ??man_rpt_main_66
   \   0000029E   0x2808             CMP      R0,#+8
   \   000002A0   0xD100             BNE      .+4
   \   000002A2   0xE0D6             B        ??man_rpt_main_67
   \   000002A4   0xD200             BCS      .+4
   \   000002A6   0xE0CA             B        ??man_rpt_main_68
   \   000002A8   0x280A             CMP      R0,#+10
   \   000002AA   0xD100             BNE      .+4
   \   000002AC   0xE146             B        ??man_rpt_main_69
   \   000002AE   0xD200             BCS      .+4
   \   000002B0   0xE12A             B        ??man_rpt_main_70
   \   000002B2   0x280C             CMP      R0,#+12
   \   000002B4   0xD100             BNE      .+4
   \   000002B6   0xE172             B        ??man_rpt_main_71
   \   000002B8   0xD200             BCS      .+4
   \   000002BA   0xE140             B        ??man_rpt_main_72
   \   000002BC   0x280E             CMP      R0,#+14
   \   000002BE   0xD100             BNE      .+4
   \   000002C0   0xE1B1             B        ??man_rpt_main_73
   \   000002C2   0xD200             BCS      .+4
   \   000002C4   0xE1AE             B        ??man_rpt_main_74
   \   000002C6   0x2810             CMP      R0,#+16
   \   000002C8   0xD100             BNE      .+4
   \   000002CA   0xE1FF             B        ??man_rpt_main_75
   \   000002CC   0xD200             BCS      .+4
   \   000002CE   0xE1B9             B        ??man_rpt_main_76
   \   000002D0   0x2812             CMP      R0,#+18
   \   000002D2   0xD100             BNE      .+4
   \   000002D4   0xE210             B        ??man_rpt_main_77
   \   000002D6   0xD200             BCS      .+4
   \   000002D8   0xE20D             B        ??man_rpt_main_78
   \   000002DA   0x2814             CMP      R0,#+20
   \   000002DC   0xD100             BNE      .+4
   \   000002DE   0xE22F             B        ??man_rpt_main_79
   \   000002E0   0xD200             BCS      .+4
   \   000002E2   0xE223             B        ??man_rpt_main_80
   \   000002E4   0x2816             CMP      R0,#+22
   \   000002E6   0xD100             BNE      .+4
   \   000002E8   0xE22F             B        ??man_rpt_main_81
   \   000002EA   0xD200             BCS      .+4
   \   000002EC   0xE229             B        ??man_rpt_main_82
   \   000002EE   0x2817             CMP      R0,#+23
   \   000002F0   0xD100             BNE      .+4
   \   000002F2   0xE234             B        ??man_rpt_main_83
   \   000002F4   0xE246             B        ??man_rpt_main_84
   \   000002F6   0xBF00             Nop      
   \                     ??man_rpt_main_9:
   \   000002F8   0x........         DC32     man_rpt_work+0x84
   \   000002FC   0x........         DC32     man_rpt_work
    874          	case MAN_RPT_SEQ_READY:					// 要求待ち
    875          		break;
   \                     ??man_rpt_main_60: (+1)
   \   00000300   0xE240             B        ??man_rpt_main_85
    876          
    877          	case MAN_RPT_SEQ_OPEN_UDP_REQ:			// OPEN UDP開始
    878          		// 上位からCLOSE要求があれば送信を中止し、CLOSEに移行する
    879          		if (man_rpt_work.request.req_cmd == MAN_RPT_REQ_CMD_CLOSE) {
   \                     ??man_rpt_main_62: (+1)
   \   00000302   0x48BE             LDR      R0,??man_rpt_main_86
   \   00000304   0x6F80             LDR      R0,[R0, #+120]
   \   00000306   0x2801             CMP      R0,#+1
   \   00000308   0xD106             BNE      ??man_rpt_main_87
    880          			// CLOSE UDP完了
    881          			man_rpt_set_sequense(MAN_RPT_SEQ_READY);
   \   0000030A   0x2000             MOVS     R0,#+0
   \   0000030C   0x.... 0x....      BL       man_rpt_set_sequense
    882          			man_rpt_work.retry = 0;
   \   00000310   0x2000             MOVS     R0,#+0
   \   00000312   0x49C3             LDR      R1,??man_rpt_main_88
   \   00000314   0x6008             STR      R0,[R1, #+0]
   \   00000316   0xE017             B        ??man_rpt_main_89
    883          		}
    884          		else {
    885          			// HTTPの使用状況を確認する
    886          			if (sts == 0) {
   \                     ??man_rpt_main_87: (+1)
   \   00000318   0x2C00             CMP      R4,#+0
   \   0000031A   0xD115             BNE      ??man_rpt_main_89
    887          				// MSGの送信完了を待つ
    888          				if (man_msg_check_send_state() == 0) {
   \   0000031C   0x.... 0x....      BL       man_msg_check_send_state
   \   00000320   0x2800             CMP      R0,#+0
   \   00000322   0xD111             BNE      ??man_rpt_main_89
    889          					// UDP OPEN
    890          					man_rpt_set_sequense(MAN_RPT_SEQ_OPEN_UDP);
   \   00000324   0x2002             MOVS     R0,#+2
   \   00000326   0x.... 0x....      BL       man_rpt_set_sequense
    891          					ret = man_http_udp_open(MAN_RPT_SEQ_OPEN_UDP, man_rpt_req_callback);
   \   0000032A   0x49C3             LDR      R1,??man_rpt_main_90
   \   0000032C   0x2002             MOVS     R0,#+2
   \   0000032E   0x.... 0x....      BL       man_http_udp_open
    892          					if (ret < 0) {
   \   00000332   0x2800             CMP      R0,#+0
   \   00000334   0xD508             BPL      ??man_rpt_main_89
    893          						man_error_setting(MAN_ERROR_MAN_RPT, 0, 0);
   \   00000336   0x4BC1             LDR      R3,??man_rpt_main_90+0x4  ;; 0x37d
   \   00000338   0x2200             MOVS     R2,#+0
   \   0000033A   0x2100             MOVS     R1,#+0
   \   0000033C   0x2017             MOVS     R0,#+23
   \   0000033E   0x.... 0x....      BL       man_error_set
    894          						man_rpt_set_sequense(MAN_RPT_SEQ_ERROR);
   \   00000342   0x2017             MOVS     R0,#+23
   \   00000344   0x.... 0x....      BL       man_rpt_set_sequense
    895          					}
    896          				}
    897          			}
    898          		}
    899          		break;
   \                     ??man_rpt_main_89: (+1)
   \   00000348   0xE21C             B        ??man_rpt_main_85
    900          
    901          	case MAN_RPT_SEQ_OPEN_UDP:				// OPEN UDP
    902          		break;
   \                     ??man_rpt_main_61: (+1)
   \   0000034A   0xE21B             B        ??man_rpt_main_85
    903          
    904          	case MAN_RPT_SEQ_OPEN_UDP_OK:			// OPEN UDP完了
    905          		// レポート報告を開始する
    906          		man_rpt_work.udp_sts = MAN_RPT_UDP_STS_OPEN;
   \                     ??man_rpt_main_64: (+1)
   \   0000034C   0x2001             MOVS     R0,#+1
   \   0000034E   0x49BC             LDR      R1,??man_rpt_main_90+0x8
   \   00000350   0x7008             STRB     R0,[R1, #+0]
    907          		// UDP送信要求
    908          		man_rpt_set_sequense(MAN_RPT_SEQ_SEND1_UDP_REQ);
   \   00000352   0x2009             MOVS     R0,#+9
   \   00000354   0x.... 0x....      BL       man_rpt_set_sequense
    909          		break;
   \   00000358   0xE214             B        ??man_rpt_main_85
   \   0000035A   0xBF00             Nop      
   \                     ??man_rpt_main_20:
   \   0000035C   0x........         DC32     man_rpt_work+0x90
   \   00000360   0x00000BD8         DC32     0xbd8
   \   00000364   0x........         DC32     man_rpt_work+0xC8
   \   00000368   0x........         DC32     man_rpt_work+0xCC
   \   0000036C   0x........         DC32     man_rpt_work+0xD0
    910          
    911          	case MAN_RPT_SEQ_OPEN_UDP_NG:			// OPEN UDP異常
    912          		delay_timer = man_timer_get_elapsed_time(man_rpt_work.delay_timer, man_timer_get_1ms_count());
   \                     ??man_rpt_main_63: (+1)
   \   00000370   0x.... 0x....      BL       man_timer_get_1ms_count
   \   00000374   0x0001             MOVS     R1,R0
   \   00000376   0x485B             LDR      R0,??man_rpt_main_52
   \   00000378   0x6800             LDR      R0,[R0, #+0]
   \   0000037A   0x.... 0x....      BL       man_timer_get_elapsed_time
    913          		// 50ms経過後に異常を解除する
    914          		if (delay_timer >= 50) {
   \   0000037E   0x2832             CMP      R0,#+50
   \   00000380   0xD310             BCC      ??man_rpt_main_91
    915          			if (man_rpt_work.retry <= MAN_RPT_RETRY_MAX) {
   \   00000382   0x48A7             LDR      R0,??man_rpt_main_88
   \   00000384   0x6800             LDR      R0,[R0, #+0]
   \   00000386   0x2802             CMP      R0,#+2
   \   00000388   0xDA08             BGE      ??man_rpt_main_92
    916          				man_rpt_work.retry++;
   \   0000038A   0x48A5             LDR      R0,??man_rpt_main_88
   \   0000038C   0x6800             LDR      R0,[R0, #+0]
   \   0000038E   0x1C40             ADDS     R0,R0,#+1
   \   00000390   0x49A3             LDR      R1,??man_rpt_main_88
   \   00000392   0x6008             STR      R0,[R1, #+0]
    917          				// UDP OPEN要求
    918          				man_rpt_set_sequense(MAN_RPT_SEQ_OPEN_UDP_REQ);
   \   00000394   0x2001             MOVS     R0,#+1
   \   00000396   0x.... 0x....      BL       man_rpt_set_sequense
   \   0000039A   0xE032             B        ??man_rpt_main_93
    919          			}
    920          			else {
    921          				man_rpt_set_sequense(MAN_RPT_SEQ_READY);
   \                     ??man_rpt_main_92: (+1)
   \   0000039C   0x2000             MOVS     R0,#+0
   \   0000039E   0x.... 0x....      BL       man_rpt_set_sequense
   \   000003A2   0xE02E             B        ??man_rpt_main_93
    922          			}
    923          		}
    924          		else {
    925          			switch (man_rpt_work.req_state) {
   \                     ??man_rpt_main_91: (+1)
   \   000003A4   0x48BF             LDR      R0,??man_rpt_main_94
   \   000003A6   0x6800             LDR      R0,[R0, #+0]
   \   000003A8   0x2801             CMP      R0,#+1
   \   000003AA   0xD006             BEQ      ??man_rpt_main_95
   \   000003AC   0x280B             CMP      R0,#+11
   \   000003AE   0xD004             BEQ      ??man_rpt_main_95
   \   000003B0   0x280C             CMP      R0,#+12
   \   000003B2   0xD003             BEQ      ??man_rpt_main_96
   \   000003B4   0x280D             CMP      R0,#+13
   \   000003B6   0xD012             BEQ      ??man_rpt_main_97
   \   000003B8   0xE023             B        ??man_rpt_main_93
    926          			case MAN_RPT_STATE_RESET:
    927          			case MAN_RPT_STATE_NET_CLOSE:
    928          				break;
   \                     ??man_rpt_main_95: (+1)
   \   000003BA   0xE022             B        ??man_rpt_main_93
    929          			case MAN_RPT_STATE_DEV_NOT_SUPPORT:
    930          				// OPEN状態
    931          				man_rpt_work.udp_sts = MAN_RPT_UDP_STS_OPEN;
   \                     ??man_rpt_main_96: (+1)
   \   000003BC   0x2001             MOVS     R0,#+1
   \   000003BE   0x49A0             LDR      R1,??man_rpt_main_90+0x8
   \   000003C0   0x7008             STRB     R0,[R1, #+0]
    932          				// 送信終了
    933          				man_rpt_work.trans_mode = 0;
   \   000003C2   0x2000             MOVS     R0,#+0
   \   000003C4   0x498D             LDR      R1,??man_rpt_main_86
   \   000003C6   0x6708             STR      R0,[R1, #+112]
    934          				// SENDから再開する
    935          				man_rpt_set_sequense(MAN_RPT_SEQ_OPEN_UDP_OK);
   \   000003C8   0x2003             MOVS     R0,#+3
   \   000003CA   0x.... 0x....      BL       man_rpt_set_sequense
    936          				man_error_setting(MAN_ERROR_MAN_RPT, 0, 0);
   \   000003CE   0x23EA             MOVS     R3,#+234
   \   000003D0   0x009B             LSLS     R3,R3,#+2        ;; #+936
   \   000003D2   0x2200             MOVS     R2,#+0
   \   000003D4   0x2100             MOVS     R1,#+0
   \   000003D6   0x2017             MOVS     R0,#+23
   \   000003D8   0x.... 0x....      BL       man_error_set
    937          				break;
   \   000003DC   0xE011             B        ??man_rpt_main_93
    938          			case MAN_RPT_STATE_DEV_BUSY:
    939          				// OPEN状態
    940          				man_rpt_work.udp_sts = MAN_RPT_UDP_STS_OPEN;
   \                     ??man_rpt_main_97: (+1)
   \   000003DE   0x2001             MOVS     R0,#+1
   \   000003E0   0x4997             LDR      R1,??man_rpt_main_90+0x8
   \   000003E2   0x7008             STRB     R0,[R1, #+0]
    941          				// 送信終了
    942          				man_rpt_work.trans_mode = 0;
   \   000003E4   0x2000             MOVS     R0,#+0
   \   000003E6   0x4985             LDR      R1,??man_rpt_main_86
   \   000003E8   0x6708             STR      R0,[R1, #+112]
    943          				// CLOSEから再開する
    944          				man_rpt_set_sequense(MAN_RPT_SEQ_CLOSE_UDP_REQ);
   \   000003EA   0x2005             MOVS     R0,#+5
   \   000003EC   0x.... 0x....      BL       man_rpt_set_sequense
    945          				man_rpt_work.retry = 0;
   \   000003F0   0x2000             MOVS     R0,#+0
   \   000003F2   0x498B             LDR      R1,??man_rpt_main_88
   \   000003F4   0x6008             STR      R0,[R1, #+0]
    946          				man_error_setting(MAN_ERROR_MAN_RPT, 0, 0);
   \   000003F6   0x4BB4             LDR      R3,??man_rpt_main_98  ;; 0x3b2
   \   000003F8   0x2200             MOVS     R2,#+0
   \   000003FA   0x2100             MOVS     R1,#+0
   \   000003FC   0x2017             MOVS     R0,#+23
   \   000003FE   0x.... 0x....      BL       man_error_set
    947          				break;
    948          			}
    949          		}
    950          		break;
   \                     ??man_rpt_main_93: (+1)
   \   00000402   0xE1BF             B        ??man_rpt_main_85
    951          
    952          
    953          
    954          	case MAN_RPT_SEQ_CLOSE_UDP_REQ:			// CLOSE UDP要求
    955          		// HTTPの使用状況を確認する
    956          		if (sts == 0) {
   \                     ??man_rpt_main_66: (+1)
   \   00000404   0x2C00             CMP      R4,#+0
   \   00000406   0xD115             BNE      ??man_rpt_main_99
    957          			// MSGの送信完了を待つ
    958          			if (man_msg_check_send_state() == 0) {
   \   00000408   0x.... 0x....      BL       man_msg_check_send_state
   \   0000040C   0x2800             CMP      R0,#+0
   \   0000040E   0xD111             BNE      ??man_rpt_main_99
    959          				man_rpt_set_sequense(MAN_RPT_SEQ_CLOSE_UDP);
   \   00000410   0x2006             MOVS     R0,#+6
   \   00000412   0x.... 0x....      BL       man_rpt_set_sequense
    960          				ret = man_http_udp_close(MAN_RPT_SEQ_CLOSE_UDP, man_rpt_req_callback);
   \   00000416   0x4988             LDR      R1,??man_rpt_main_90
   \   00000418   0x2006             MOVS     R0,#+6
   \   0000041A   0x.... 0x....      BL       man_http_udp_close
    961          				if (ret < 0) {
   \   0000041E   0x2800             CMP      R0,#+0
   \   00000420   0xD508             BPL      ??man_rpt_main_99
    962          					man_error_setting(MAN_ERROR_MAN_RPT, 0, 0);
   \   00000422   0x4BBF             LDR      R3,??man_rpt_main_100  ;; 0x3c2
   \   00000424   0x2200             MOVS     R2,#+0
   \   00000426   0x2100             MOVS     R1,#+0
   \   00000428   0x2017             MOVS     R0,#+23
   \   0000042A   0x.... 0x....      BL       man_error_set
    963          					man_rpt_set_sequense(MAN_RPT_SEQ_ERROR);
   \   0000042E   0x2017             MOVS     R0,#+23
   \   00000430   0x.... 0x....      BL       man_rpt_set_sequense
    964          				}
    965          			}
    966          		}
    967          		break;
   \                     ??man_rpt_main_99: (+1)
   \   00000434   0xE1A6             B        ??man_rpt_main_85
   \   00000436   0xBF00             Nop      
   \                     ??man_rpt_main_43:
   \   00000438   0x00000329         DC32     0x329
    968          	
    969          	case MAN_RPT_SEQ_CLOSE_UDP:				// CLOSE UDP実行中
    970          		break;
   \                     ??man_rpt_main_65: (+1)
   \   0000043C   0xE1A2             B        ??man_rpt_main_85
    971          
    972          	case MAN_RPT_SEQ_CLOSE_UDP_OK:			// CLOSE UDP完了
    973          		man_rpt_return_callback(MAN_RPT_STATUS_OK);
   \                     ??man_rpt_main_68: (+1)
   \   0000043E   0x2000             MOVS     R0,#+0
   \   00000440   0x.... 0x....      BL       man_rpt_return_callback
    974          		// レポート報告を停止する
    975          		man_rpt_work.udp_sts = MAN_RPT_UDP_STS_CLOSE;
   \   00000444   0x2000             MOVS     R0,#+0
   \   00000446   0x497E             LDR      R1,??man_rpt_main_90+0x8
   \   00000448   0x7008             STRB     R0,[R1, #+0]
    976          		// 送信終了
    977          		man_rpt_work.trans_mode = 0;
   \   0000044A   0x2000             MOVS     R0,#+0
   \   0000044C   0x496B             LDR      R1,??man_rpt_main_86
   \   0000044E   0x6708             STR      R0,[R1, #+112]
    978          		break;
   \   00000450   0xE198             B        ??man_rpt_main_85
    979          
    980          	case MAN_RPT_SEQ_CLOSE_UDP_NG:			// CLOSE UDP異常
    981          		delay_timer = man_timer_get_elapsed_time(man_rpt_work.delay_timer, man_timer_get_1ms_count());
   \                     ??man_rpt_main_67: (+1)
   \   00000452   0x.... 0x....      BL       man_timer_get_1ms_count
   \   00000456   0x0001             MOVS     R1,R0
   \   00000458   0x4822             LDR      R0,??man_rpt_main_52
   \   0000045A   0x6800             LDR      R0,[R0, #+0]
   \   0000045C   0x.... 0x....      BL       man_timer_get_elapsed_time
    982          		// 50ms経過後に異常を解除する
    983          		if (delay_timer >= 50) {
   \   00000460   0x2832             CMP      R0,#+50
   \   00000462   0xD323             BCC      ??man_rpt_main_101
    984          			if (man_rpt_work.retry <= MAN_RPT_RETRY_MAX) {
   \   00000464   0x486E             LDR      R0,??man_rpt_main_88
   \   00000466   0x6800             LDR      R0,[R0, #+0]
   \   00000468   0x2802             CMP      R0,#+2
   \   0000046A   0xDA0F             BGE      ??man_rpt_main_102
    985          				man_rpt_work.retry++;
   \   0000046C   0x486C             LDR      R0,??man_rpt_main_88
   \   0000046E   0x6800             LDR      R0,[R0, #+0]
   \   00000470   0x1C40             ADDS     R0,R0,#+1
   \   00000472   0x496B             LDR      R1,??man_rpt_main_88
   \   00000474   0x6008             STR      R0,[R1, #+0]
    986          				// CLOSE UDP開始
    987          				man_rpt_set_sequense(MAN_RPT_SEQ_CLOSE_UDP_REQ);
   \   00000476   0x2005             MOVS     R0,#+5
   \   00000478   0x.... 0x....      BL       man_rpt_set_sequense
    988          				man_error_setting(MAN_ERROR_MAN_RPT, 0, 0);
   \   0000047C   0x23F7             MOVS     R3,#+247
   \   0000047E   0x009B             LSLS     R3,R3,#+2        ;; #+988
   \   00000480   0x2200             MOVS     R2,#+0
   \   00000482   0x2100             MOVS     R1,#+0
   \   00000484   0x2017             MOVS     R0,#+23
   \   00000486   0x.... 0x....      BL       man_error_set
   \   0000048A   0xE03C             B        ??man_rpt_main_103
    989          			}
    990          			else {
    991          				man_error_setting(MAN_ERROR_MAN_RPT, 0, 0);
   \                     ??man_rpt_main_102: (+1)
   \   0000048C   0x4BBB             LDR      R3,??man_rpt_main_104  ;; 0x3df
   \   0000048E   0x2200             MOVS     R2,#+0
   \   00000490   0x2100             MOVS     R1,#+0
   \   00000492   0x2017             MOVS     R0,#+23
   \   00000494   0x.... 0x....      BL       man_error_set
    992          				// CLOSE失敗時も成功時と同様の処理を行う。
    993          				man_rpt_return_callback(MAN_RPT_STATUS_OK);
   \   00000498   0x2000             MOVS     R0,#+0
   \   0000049A   0x.... 0x....      BL       man_rpt_return_callback
    994          				// レポート報告を停止する
    995          				man_rpt_work.udp_sts = MAN_RPT_UDP_STS_CLOSE;
   \   0000049E   0x2000             MOVS     R0,#+0
   \   000004A0   0x4967             LDR      R1,??man_rpt_main_90+0x8
   \   000004A2   0x7008             STRB     R0,[R1, #+0]
    996          				// 送信終了
    997          				man_rpt_work.trans_mode = 0;
   \   000004A4   0x2000             MOVS     R0,#+0
   \   000004A6   0x4955             LDR      R1,??man_rpt_main_86
   \   000004A8   0x6708             STR      R0,[R1, #+112]
   \   000004AA   0xE02C             B        ??man_rpt_main_103
    998          			}
    999          		}
   1000          		else {
   1001          			switch (man_rpt_work.req_state) {
   \                     ??man_rpt_main_101: (+1)
   \   000004AC   0x487D             LDR      R0,??man_rpt_main_94
   \   000004AE   0x6800             LDR      R0,[R0, #+0]
   \   000004B0   0x2801             CMP      R0,#+1
   \   000004B2   0xD006             BEQ      ??man_rpt_main_105
   \   000004B4   0x280B             CMP      R0,#+11
   \   000004B6   0xD004             BEQ      ??man_rpt_main_105
   \   000004B8   0x280C             CMP      R0,#+12
   \   000004BA   0xD003             BEQ      ??man_rpt_main_106
   \   000004BC   0x280D             CMP      R0,#+13
   \   000004BE   0xD013             BEQ      ??man_rpt_main_107
   \   000004C0   0xE021             B        ??man_rpt_main_103
   1002          			case MAN_RPT_STATE_RESET:
   1003          			case MAN_RPT_STATE_NET_CLOSE:
   1004          				break;
   \                     ??man_rpt_main_105: (+1)
   \   000004C2   0xE020             B        ??man_rpt_main_103
   1005          			case MAN_RPT_STATE_DEV_NOT_SUPPORT:
   1006          				// CLOSE状態
   1007          				man_rpt_work.udp_sts = MAN_RPT_UDP_STS_CLOSE;
   \                     ??man_rpt_main_106: (+1)
   \   000004C4   0x2000             MOVS     R0,#+0
   \   000004C6   0x495E             LDR      R1,??man_rpt_main_90+0x8
   \   000004C8   0x7008             STRB     R0,[R1, #+0]
   1008          				// 送信終了
   1009          				man_rpt_work.trans_mode = 0;
   \   000004CA   0x2000             MOVS     R0,#+0
   \   000004CC   0x494B             LDR      R1,??man_rpt_main_86
   \   000004CE   0x6708             STR      R0,[R1, #+112]
   1010          				man_rpt_set_sequense(MAN_RPT_SEQ_READY);
   \   000004D0   0x2000             MOVS     R0,#+0
   \   000004D2   0x.... 0x....      BL       man_rpt_set_sequense
   1011          				man_error_setting(MAN_ERROR_MAN_RPT, 0, 0);
   \   000004D6   0x4BAA             LDR      R3,??man_rpt_main_104+0x4  ;; 0x3f3
   \   000004D8   0x2200             MOVS     R2,#+0
   \   000004DA   0x2100             MOVS     R1,#+0
   \   000004DC   0x2017             MOVS     R0,#+23
   \   000004DE   0x.... 0x....      BL       man_error_set
   1012          				break;
   \   000004E2   0xE010             B        ??man_rpt_main_103
   \                     ??man_rpt_main_52:
   \   000004E4   0x........         DC32     man_rpt_work+0x88
   1013          			case MAN_RPT_STATE_DEV_BUSY:
   1014          				// CLOSE状態
   1015          				man_rpt_work.udp_sts = MAN_RPT_UDP_STS_CLOSE;
   \                     ??man_rpt_main_107: (+1)
   \   000004E8   0x2000             MOVS     R0,#+0
   \   000004EA   0x4955             LDR      R1,??man_rpt_main_90+0x8
   \   000004EC   0x7008             STRB     R0,[R1, #+0]
   1016          				// 送信終了
   1017          				man_rpt_work.trans_mode = 0;
   \   000004EE   0x2000             MOVS     R0,#+0
   \   000004F0   0x4942             LDR      R1,??man_rpt_main_86
   \   000004F2   0x6708             STR      R0,[R1, #+112]
   1018          				man_rpt_set_sequense(MAN_RPT_SEQ_READY);
   \   000004F4   0x2000             MOVS     R0,#+0
   \   000004F6   0x.... 0x....      BL       man_rpt_set_sequense
   1019          				man_error_setting(MAN_ERROR_MAN_RPT, 0, 0);
   \   000004FA   0x4BBC             LDR      R3,??man_rpt_main_108  ;; 0x3fb
   \   000004FC   0x2200             MOVS     R2,#+0
   \   000004FE   0x2100             MOVS     R1,#+0
   \   00000500   0x2017             MOVS     R0,#+23
   \   00000502   0x.... 0x....      BL       man_error_set
   1020          				break;
   1021          			}
   1022          		}
   1023          		break;
   \                     ??man_rpt_main_103: (+1)
   \   00000506   0xE13D             B        ??man_rpt_main_85
   1024          
   1025          
   1026          	case MAN_RPT_SEQ_SEND1_UDP_REQ:			// SEND1 UDP要求
   1027          		
   1028          		// 上位からCLOSE要求があれば送信を中止し、CLOSEに移行する
   1029          		if (man_rpt_work.request.req_cmd == MAN_RPT_REQ_CMD_CLOSE) {
   \                     ??man_rpt_main_70: (+1)
   \   00000508   0x483C             LDR      R0,??man_rpt_main_86
   \   0000050A   0x6F80             LDR      R0,[R0, #+120]
   \   0000050C   0x2801             CMP      R0,#+1
   \   0000050E   0xD106             BNE      ??man_rpt_main_109
   1030          			// CLOSE UDP開始
   1031          			man_rpt_set_sequense(MAN_RPT_SEQ_CLOSE_UDP_REQ);
   \   00000510   0x2005             MOVS     R0,#+5
   \   00000512   0x.... 0x....      BL       man_rpt_set_sequense
   1032          			man_rpt_work.retry = 0;
   \   00000516   0x2000             MOVS     R0,#+0
   \   00000518   0x4941             LDR      R1,??man_rpt_main_88
   \   0000051A   0x6008             STR      R0,[R1, #+0]
   \   0000051C   0xE00A             B        ??man_rpt_main_110
   1033          		}
   1034          		else {
   1035          			// HTTPの使用状況を確認する
   1036          			if (sts == 0) {
   \                     ??man_rpt_main_109: (+1)
   \   0000051E   0x2C00             CMP      R4,#+0
   \   00000520   0xD108             BNE      ??man_rpt_main_110
   1037          				// MSGの送信完了を待つ
   1038          				if (man_msg_check_send_state() == 0) {
   \   00000522   0x.... 0x....      BL       man_msg_check_send_state
   \   00000526   0x2800             CMP      R0,#+0
   \   00000528   0xD104             BNE      ??man_rpt_main_110
   1039          					// 送信開始
   1040          					man_rpt_work.trans_mode = 1;
   \   0000052A   0x2001             MOVS     R0,#+1
   \   0000052C   0x4933             LDR      R1,??man_rpt_main_86
   \   0000052E   0x6708             STR      R0,[R1, #+112]
   1041          					// BODYデータを出力
   1042          					man_rpt_send_body_sensor();
   \   00000530   0x.... 0x....      BL       man_rpt_send_body_sensor
   1043          				}
   1044          			}
   1045          		}
   1046          		break;
   \                     ??man_rpt_main_110: (+1)
   \   00000534   0xE126             B        ??man_rpt_main_85
   \   00000536   0xBF00             Nop      
   \                     ??man_rpt_main_56:
   \   00000538   0x........         DC32     man_rpt_work+0x74
   1047          
   1048          	case MAN_RPT_SEQ_SEND1_UDP:				// SEND1 UDP実行中
   1049          		break;
   \                     ??man_rpt_main_69: (+1)
   \   0000053C   0xE122             B        ??man_rpt_main_85
   1050          
   1051          	case MAN_RPT_SEQ_SEND1_UDP_OK:			// SEND1 UDP完了
   1052          		// 上位からCLOSE要求があれば送信を中止し、CLOSEに移行する
   1053          		if (man_rpt_work.request.req_cmd == MAN_RPT_REQ_CMD_CLOSE) {
   \                     ??man_rpt_main_72: (+1)
   \   0000053E   0x482F             LDR      R0,??man_rpt_main_86
   \   00000540   0x6F80             LDR      R0,[R0, #+120]
   \   00000542   0x2801             CMP      R0,#+1
   \   00000544   0xD108             BNE      ??man_rpt_main_111
   1054          			// CLOSE UDP開始
   1055          			man_rpt_set_sequense(MAN_RPT_SEQ_CLOSE_UDP_REQ);
   \   00000546   0x2005             MOVS     R0,#+5
   \   00000548   0x.... 0x....      BL       man_rpt_set_sequense
   1056          			man_rpt_work.retry = 0;
   \   0000054C   0x2000             MOVS     R0,#+0
   \   0000054E   0x4934             LDR      R1,??man_rpt_main_88
   \   00000550   0x6008             STR      R0,[R1, #+0]
   \   00000552   0xE023             B        ??man_rpt_main_112
   \                     ??man_rpt_main_59:
   \   00000554   0x0000035E         DC32     0x35e
   1057          		}
   1058          		else {
   1059          			// HTTPの使用状況を確認する
   1060          			if (sts == 0) {
   \                     ??man_rpt_main_111: (+1)
   \   00000558   0x2C00             CMP      R4,#+0
   \   0000055A   0xD11F             BNE      ??man_rpt_main_112
   1061          				if (man_rpt_work.rpt_buff2.data_len != 0) {
   \   0000055C   0x48BA             LDR      R0,??man_rpt_main_113
   \   0000055E   0x6800             LDR      R0,[R0, #+0]
   \   00000560   0x2800             CMP      R0,#+0
   \   00000562   0xD013             BEQ      ??man_rpt_main_114
   1062          					// MSGの送信完了を待つ
   1063          					if (man_msg_check_send_state() == 0) {
   \   00000564   0x.... 0x....      BL       man_msg_check_send_state
   \   00000568   0x2800             CMP      R0,#+0
   \   0000056A   0xD117             BNE      ??man_rpt_main_112
   1064          						man_rpt_set_sequense(MAN_RPT_SEQ_SEND2_UDP);
   \   0000056C   0x200D             MOVS     R0,#+13
   \   0000056E   0x.... 0x....      BL       man_rpt_set_sequense
   1065          						ret = man_http_udp_send(&man_rpt_work.rpt_buff2.data[0],
   1066          												man_rpt_work.rpt_buff2.data_len,
   1067          												MAN_RPT_SEQ_SEND2_UDP, 
   1068          												man_rpt_req_callback);
   \   00000572   0x4B31             LDR      R3,??man_rpt_main_90
   \   00000574   0x220D             MOVS     R2,#+13
   \   00000576   0x48B4             LDR      R0,??man_rpt_main_113
   \   00000578   0x6801             LDR      R1,[R0, #+0]
   \   0000057A   0x48B4             LDR      R0,??man_rpt_main_113+0x4
   \   0000057C   0x.... 0x....      BL       man_http_udp_send
   1069          						if (ret < 0) {
   \   00000580   0x2800             CMP      R0,#+0
   \   00000582   0xD50B             BPL      ??man_rpt_main_112
   1070          							man_rpt_set_sequense(MAN_RPT_SEQ_READY);
   \   00000584   0x2000             MOVS     R0,#+0
   \   00000586   0x.... 0x....      BL       man_rpt_set_sequense
   \   0000058A   0xE007             B        ??man_rpt_main_112
   1071          						}
   1072          					}
   1073          				}
   1074          				else {
   1075          					// UDP送信数更新
   1076          					man_rpt_work.cycle_info.send_counter++;
   \                     ??man_rpt_main_114: (+1)
   \   0000058C   0x....             LDR      R0,??DataTable9
   \   0000058E   0x6800             LDR      R0,[R0, #+0]
   \   00000590   0x1C40             ADDS     R0,R0,#+1
   \   00000592   0x....             LDR      R1,??DataTable9
   \   00000594   0x6008             STR      R0,[R1, #+0]
   1077          					man_rpt_set_sequense(MAN_RPT_SEQ_READY);
   \   00000596   0x2000             MOVS     R0,#+0
   \   00000598   0x.... 0x....      BL       man_rpt_set_sequense
   1078          #ifdef GNSS_DEBUG_OUT_RPT 
   1079          			int32_t		length;
   1080          			sprintf((char *)&man_rpt_work.buff[0], "RPT OUT(%d)\n", man_rpt_work.cycle_info.counter);
   1081          			length = strlen((char const *)&man_rpt_work.buff[0]);
   1082          			man_usb_data_send(&man_rpt_work.buff[0], length);
   1083          #endif
   1084          				}
   1085          			}
   1086          		}
   1087          		break;
   \                     ??man_rpt_main_112: (+1)
   \   0000059C   0xE0F2             B        ??man_rpt_main_85
   1088          
   1089          	case MAN_RPT_SEQ_SEND1_UDP_NG:			// SEND1 UDP異常
   1090          		delay_timer = man_timer_get_elapsed_time(man_rpt_work.delay_timer, man_timer_get_1ms_count());
   \                     ??man_rpt_main_71: (+1)
   \   0000059E   0x.... 0x....      BL       man_timer_get_1ms_count
   \   000005A2   0x0001             MOVS     R1,R0
   \   000005A4   0x....             LDR      R0,??DataTable9_1
   \   000005A6   0x6800             LDR      R0,[R0, #+0]
   \   000005A8   0x.... 0x....      BL       man_timer_get_elapsed_time
   1091          		// 50ms経過後に異常を解除する
   1092          		if (delay_timer >= 50) {
   \   000005AC   0x2832             CMP      R0,#+50
   \   000005AE   0xD309             BCC      ??man_rpt_main_115
   1093          			man_rpt_set_sequense(MAN_RPT_SEQ_READY);
   \   000005B0   0x2000             MOVS     R0,#+0
   \   000005B2   0x.... 0x....      BL       man_rpt_set_sequense
   1094          			man_error_setting(MAN_ERROR_MAN_RPT, 0, 0);
   \   000005B6   0x....             LDR      R3,??DataTable9_2  ;; 0x446
   \   000005B8   0x2200             MOVS     R2,#+0
   \   000005BA   0x2100             MOVS     R1,#+0
   \   000005BC   0x2017             MOVS     R0,#+23
   \   000005BE   0x.... 0x....      BL       man_error_set
   \   000005C2   0xE02C             B        ??man_rpt_main_116
   1095          		}
   1096          		else {
   1097          			switch (man_rpt_work.req_state) {
   \                     ??man_rpt_main_115: (+1)
   \   000005C4   0x4837             LDR      R0,??man_rpt_main_94
   \   000005C6   0x6800             LDR      R0,[R0, #+0]
   \   000005C8   0x2801             CMP      R0,#+1
   \   000005CA   0xD006             BEQ      ??man_rpt_main_117
   \   000005CC   0x280B             CMP      R0,#+11
   \   000005CE   0xD004             BEQ      ??man_rpt_main_117
   \   000005D0   0x280C             CMP      R0,#+12
   \   000005D2   0xD003             BEQ      ??man_rpt_main_118
   \   000005D4   0x280D             CMP      R0,#+13
   \   000005D6   0xD013             BEQ      ??man_rpt_main_119
   \   000005D8   0xE021             B        ??man_rpt_main_116
   1098          			case MAN_RPT_STATE_RESET:
   1099          			case MAN_RPT_STATE_NET_CLOSE:
   1100          				break;
   \                     ??man_rpt_main_117: (+1)
   \   000005DA   0xE020             B        ??man_rpt_main_116
   1101          			case MAN_RPT_STATE_DEV_NOT_SUPPORT:
   1102          				// OPENから再開
   1103          				man_rpt_work.udp_sts = MAN_RPT_UDP_STS_CLOSE;
   \                     ??man_rpt_main_118: (+1)
   \   000005DC   0x2000             MOVS     R0,#+0
   \   000005DE   0x4918             LDR      R1,??man_rpt_main_90+0x8
   \   000005E0   0x7008             STRB     R0,[R1, #+0]
   1104          				// 送信終了
   1105          				man_rpt_work.trans_mode = 0;
   \   000005E2   0x2000             MOVS     R0,#+0
   \   000005E4   0x4905             LDR      R1,??man_rpt_main_86
   \   000005E6   0x6708             STR      R0,[R1, #+112]
   1106          				man_rpt_set_sequense(MAN_RPT_SEQ_READY);
   \   000005E8   0x2000             MOVS     R0,#+0
   \   000005EA   0x.... 0x....      BL       man_rpt_set_sequense
   1107          				man_error_setting(MAN_ERROR_MAN_RPT, 0, 0);
   \   000005EE   0x....             LDR      R3,??DataTable9_3  ;; 0x453
   \   000005F0   0x2200             MOVS     R2,#+0
   \   000005F2   0x2100             MOVS     R1,#+0
   \   000005F4   0x2017             MOVS     R0,#+23
   \   000005F6   0x.... 0x....      BL       man_error_set
   1108          				break;
   \   000005FA   0xE010             B        ??man_rpt_main_116
   \                     ??man_rpt_main_86:
   \   000005FC   0x........         DC32     man_rpt_work
   1109          			case MAN_RPT_STATE_DEV_BUSY:
   1110          				// 送信終了
   1111          				man_rpt_work.trans_mode = 0;
   \                     ??man_rpt_main_119: (+1)
   \   00000600   0x2000             MOVS     R0,#+0
   \   00000602   0x....             LDR      R1,??DataTable9_4
   \   00000604   0x6708             STR      R0,[R1, #+112]
   1112          				// CLOSEから再開する
   1113          				man_rpt_set_sequense(MAN_RPT_SEQ_CLOSE_UDP_REQ);
   \   00000606   0x2005             MOVS     R0,#+5
   \   00000608   0x.... 0x....      BL       man_rpt_set_sequense
   1114          				man_rpt_work.retry = 0;
   \   0000060C   0x2000             MOVS     R0,#+0
   \   0000060E   0x4904             LDR      R1,??man_rpt_main_88
   \   00000610   0x6008             STR      R0,[R1, #+0]
   1115          				man_error_setting(MAN_ERROR_MAN_RPT, 0, 0);
   \   00000612   0x....             LDR      R3,??DataTable9_5  ;; 0x45b
   \   00000614   0x2200             MOVS     R2,#+0
   \   00000616   0x2100             MOVS     R1,#+0
   \   00000618   0x2017             MOVS     R0,#+23
   \   0000061A   0x.... 0x....      BL       man_error_set
   1116          				break;
   1117          			}
   1118          		}
   1119          		break;
   \                     ??man_rpt_main_116: (+1)
   \   0000061E   0xE0B1             B        ??man_rpt_main_85
   \                     ??man_rpt_main_88:
   \   00000620   0x........         DC32     man_rpt_work+0x84
   1120          
   1121          	case MAN_RPT_SEQ_SEND2_UDP:				// SEND2 UDP実行中
   1122          		break;
   \                     ??man_rpt_main_74: (+1)
   \   00000624   0xE0AE             B        ??man_rpt_main_85
   1123          	case MAN_RPT_SEQ_SEND2_UDP_OK:			// SEND2 UDP完了
   1124          		// UDP送信数更新
   1125          		man_rpt_work.cycle_info.send_counter++;
   \                     ??man_rpt_main_73: (+1)
   \   00000626   0x....             LDR      R0,??DataTable9
   \   00000628   0x6800             LDR      R0,[R0, #+0]
   \   0000062A   0x1C40             ADDS     R0,R0,#+1
   \   0000062C   0x....             LDR      R1,??DataTable9
   \   0000062E   0x6008             STR      R0,[R1, #+0]
   1126          
   1127          		man_rpt_set_sequense(MAN_RPT_SEQ_READY);
   \   00000630   0x2000             MOVS     R0,#+0
   \   00000632   0x.... 0x....      BL       man_rpt_set_sequense
   1128          #ifdef GNSS_DEBUG_OUT_RPT 
   1129          			int32_t		length;
   1130          			sprintf((char *)&man_rpt_work.buff[0], "RPT OUT(%d)\n", man_rpt_work.cycle_info.counter);
   1131          			length = strlen((char const *)&man_rpt_work.buff[0]);
   1132          			man_usb_data_send(&man_rpt_work.buff[0], length);
   1133          #endif
   1134          		break;
   \   00000636   0xE0A5             B        ??man_rpt_main_85
   \                     ??man_rpt_main_90:
   \   00000638   0x........         DC32     man_rpt_req_callback
   \   0000063C   0x0000037D         DC32     0x37d
   \   00000640   0x........         DC32     man_rpt_work+0x6C
   1135          
   1136          	case MAN_RPT_SEQ_SEND2_UDP_NG:			// SEND2 UDP異常
   1137          		delay_timer = man_timer_get_elapsed_time(man_rpt_work.delay_timer, man_timer_get_1ms_count());
   \                     ??man_rpt_main_76: (+1)
   \   00000644   0x.... 0x....      BL       man_timer_get_1ms_count
   \   00000648   0x0001             MOVS     R1,R0
   \   0000064A   0x....             LDR      R0,??DataTable9_1
   \   0000064C   0x6800             LDR      R0,[R0, #+0]
   \   0000064E   0x.... 0x....      BL       man_timer_get_elapsed_time
   1138          		// 50ms経過後に異常を解除する
   1139          		if (delay_timer >= 50) {
   \   00000652   0x2832             CMP      R0,#+50
   \   00000654   0xD309             BCC      ??man_rpt_main_120
   1140          			man_rpt_set_sequense(MAN_RPT_SEQ_READY);
   \   00000656   0x2000             MOVS     R0,#+0
   \   00000658   0x.... 0x....      BL       man_rpt_set_sequense
   1141          			man_error_setting(MAN_ERROR_MAN_RPT, 0, 0);
   \   0000065C   0x....             LDR      R3,??DataTable9_6  ;; 0x475
   \   0000065E   0x2200             MOVS     R2,#+0
   \   00000660   0x2100             MOVS     R1,#+0
   \   00000662   0x2017             MOVS     R0,#+23
   \   00000664   0x.... 0x....      BL       man_error_set
   \   00000668   0xE02D             B        ??man_rpt_main_121
   1142          		}
   1143          		else {
   1144          			switch (man_rpt_work.req_state) {
   \                     ??man_rpt_main_120: (+1)
   \   0000066A   0x480E             LDR      R0,??man_rpt_main_94
   \   0000066C   0x6800             LDR      R0,[R0, #+0]
   \   0000066E   0x2801             CMP      R0,#+1
   \   00000670   0xD006             BEQ      ??man_rpt_main_122
   \   00000672   0x280B             CMP      R0,#+11
   \   00000674   0xD004             BEQ      ??man_rpt_main_122
   \   00000676   0x280C             CMP      R0,#+12
   \   00000678   0xD003             BEQ      ??man_rpt_main_123
   \   0000067A   0x280D             CMP      R0,#+13
   \   0000067C   0xD014             BEQ      ??man_rpt_main_124
   \   0000067E   0xE022             B        ??man_rpt_main_121
   1145          			case MAN_RPT_STATE_RESET:
   1146          			case MAN_RPT_STATE_NET_CLOSE:
   1147          				break;
   \                     ??man_rpt_main_122: (+1)
   \   00000680   0xE021             B        ??man_rpt_main_121
   1148          			case MAN_RPT_STATE_DEV_NOT_SUPPORT:
   1149          				// OPENから再開
   1150          				man_rpt_work.udp_sts = MAN_RPT_UDP_STS_CLOSE;
   \                     ??man_rpt_main_123: (+1)
   \   00000682   0x2000             MOVS     R0,#+0
   \   00000684   0x....             LDR      R1,??DataTable9_7
   \   00000686   0x7008             STRB     R0,[R1, #+0]
   1151          				// 送信終了
   1152          				man_rpt_work.trans_mode = 0;
   \   00000688   0x2000             MOVS     R0,#+0
   \   0000068A   0x....             LDR      R1,??DataTable9_4
   \   0000068C   0x6708             STR      R0,[R1, #+112]
   1153          				man_rpt_set_sequense(MAN_RPT_SEQ_READY);
   \   0000068E   0x2000             MOVS     R0,#+0
   \   00000690   0x.... 0x....      BL       man_rpt_set_sequense
   1154          				man_error_setting(MAN_ERROR_MAN_RPT, 0, 0);
   \   00000694   0x....             LDR      R3,??DataTable9_8  ;; 0x482
   \   00000696   0x2200             MOVS     R2,#+0
   \   00000698   0x2100             MOVS     R1,#+0
   \   0000069A   0x2017             MOVS     R0,#+23
   \   0000069C   0x.... 0x....      BL       man_error_set
   1155          				break;
   \   000006A0   0xE011             B        ??man_rpt_main_121
   \   000006A2   0xBF00             Nop      
   \                     ??man_rpt_main_94:
   \   000006A4   0x........         DC32     man_rpt_work+0x8C
   1156          			case MAN_RPT_STATE_DEV_BUSY:
   1157          				// 送信終了
   1158          				man_rpt_work.trans_mode = 0;
   \                     ??man_rpt_main_124: (+1)
   \   000006A8   0x2000             MOVS     R0,#+0
   \   000006AA   0x....             LDR      R1,??DataTable9_4
   \   000006AC   0x6708             STR      R0,[R1, #+112]
   1159          				// CLOSEから再開する
   1160          				man_rpt_set_sequense(MAN_RPT_SEQ_CLOSE_UDP_REQ);
   \   000006AE   0x2005             MOVS     R0,#+5
   \   000006B0   0x.... 0x....      BL       man_rpt_set_sequense
   1161          				man_rpt_work.retry = 0;
   \   000006B4   0x2000             MOVS     R0,#+0
   \   000006B6   0x....             LDR      R1,??DataTable9_9
   \   000006B8   0x6008             STR      R0,[R1, #+0]
   1162          				man_error_setting(MAN_ERROR_MAN_RPT, 0, 0);
   \   000006BA   0x....             LDR      R3,??DataTable9_10  ;; 0x48a
   \   000006BC   0x2200             MOVS     R2,#+0
   \   000006BE   0x2100             MOVS     R1,#+0
   \   000006C0   0x2017             MOVS     R0,#+23
   \   000006C2   0x.... 0x....      BL       man_error_set
   1163          				break;
   1164          			}
   1165          		}
   1166          		break;
   \                     ??man_rpt_main_121: (+1)
   \   000006C6   0xE05D             B        ??man_rpt_main_85
   \                     ??man_rpt_main_98:
   \   000006C8   0x000003B2         DC32     0x3b2
   1167          
   1168          
   1169          
   1170          	case MAN_RPT_SEQ_SEND1_USB_REQ:			// SEND1 USB要求
   1171          		// サーバに通知するBODYデータ(センサ用)を作成
   1172          		man_rpt_make_body_sensor(MAN_MSG_TYPE_REPORT);
   \                     ??man_rpt_main_75: (+1)
   \   000006CC   0x2004             MOVS     R0,#+4
   \   000006CE   0x.... 0x....      BL       man_rpt_make_body_sensor
   1173          		// BODYデータをUSB出力
   1174          		ret = man_rpt_usb_send_body_sensor();
   \   000006D2   0x.... 0x....      BL       man_rpt_usb_send_body_sensor
   1175          		if (ret < 0) {
   \   000006D6   0x2800             CMP      R0,#+0
   \   000006D8   0xD509             BPL      ??man_rpt_main_125
   1176          			man_error_setting(MAN_ERROR_MAN_RPT, 0, 0);
   \   000006DA   0x2393             MOVS     R3,#+147
   \   000006DC   0x00DB             LSLS     R3,R3,#+3        ;; #+1176
   \   000006DE   0x2200             MOVS     R2,#+0
   \   000006E0   0x2100             MOVS     R1,#+0
   \   000006E2   0x2017             MOVS     R0,#+23
   \   000006E4   0x.... 0x....      BL       man_error_set
   1177          			man_rpt_set_sequense(MAN_RPT_SEQ_READY);
   \   000006E8   0x2000             MOVS     R0,#+0
   \   000006EA   0x.... 0x....      BL       man_rpt_set_sequense
   1178          		}
   1179          		man_rpt_work.cycle_req = MAN_RPT_CYCLE_REQ_READY;
   \                     ??man_rpt_main_125: (+1)
   \   000006EE   0x2000             MOVS     R0,#+0
   \   000006F0   0x....             LDR      R1,??DataTable9_11
   \   000006F2   0x6008             STR      R0,[R1, #+0]
   1180          		break;
   \   000006F4   0xE046             B        ??man_rpt_main_85
   1181          
   1182          	case MAN_RPT_SEQ_SEND1_USB:				// SEND1 USB
   1183          		break;
   \                     ??man_rpt_main_78: (+1)
   \   000006F6   0xE045             B        ??man_rpt_main_85
   1184          
   1185          	case MAN_RPT_SEQ_SEND1_USB_OK:			// SEND1 USB完了
   1186          		if (man_rpt_work.rpt_buff2.data_len != 0) {
   \                     ??man_rpt_main_77: (+1)
   \   000006F8   0x4853             LDR      R0,??man_rpt_main_113
   \   000006FA   0x6800             LDR      R0,[R0, #+0]
   \   000006FC   0x2800             CMP      R0,#+0
   \   000006FE   0xD011             BEQ      ??man_rpt_main_126
   1187          			man_rpt_set_sequense(MAN_RPT_SEQ_SEND2_USB);
   \   00000700   0x2014             MOVS     R0,#+20
   \   00000702   0x.... 0x....      BL       man_rpt_set_sequense
   1188          			ret = man_usb_rpt_send(&man_rpt_work.rpt_buff2.data[0],
   1189          									man_rpt_work.rpt_buff2.data_len,
   1190          									MAN_RPT_SEQ_SEND2_USB, 
   1191          									man_rpt_req_callback);
   \   00000706   0x....             LDR      R3,??DataTable9_12
   \   00000708   0x2214             MOVS     R2,#+20
   \   0000070A   0x484F             LDR      R0,??man_rpt_main_113
   \   0000070C   0x6801             LDR      R1,[R0, #+0]
   \   0000070E   0x484F             LDR      R0,??man_rpt_main_113+0x4
   \   00000710   0x.... 0x....      BL       man_usb_rpt_send
   1192          			if (ret < 0) {
   \   00000714   0x2800             CMP      R0,#+0
   \   00000716   0xD508             BPL      ??man_rpt_main_127
   1193          				man_rpt_set_sequense(MAN_RPT_SEQ_READY);
   \   00000718   0x2000             MOVS     R0,#+0
   \   0000071A   0x.... 0x....      BL       man_rpt_set_sequense
   \   0000071E   0xE004             B        ??man_rpt_main_127
   \                     ??man_rpt_main_100:
   \   00000720   0x000003C2         DC32     0x3c2
   1194          			}
   1195          		}
   1196          		else {
   1197          			man_rpt_set_sequense(MAN_RPT_SEQ_READY);
   \                     ??man_rpt_main_126: (+1)
   \   00000724   0x2000             MOVS     R0,#+0
   \   00000726   0x.... 0x....      BL       man_rpt_set_sequense
   1198          		}
   1199          		break;
   \                     ??man_rpt_main_127: (+1)
   \   0000072A   0xE02B             B        ??man_rpt_main_85
   1200          
   1201          	case MAN_RPT_SEQ_SEND1_USB_NG:			// SEND1 USB異常
   1202          		man_error_setting(MAN_ERROR_MAN_RPT, 0, 0);
   \                     ??man_rpt_main_80: (+1)
   \   0000072C   0x....             LDR      R3,??DataTable10  ;; 0x4b2
   \   0000072E   0x2200             MOVS     R2,#+0
   \   00000730   0x2100             MOVS     R1,#+0
   \   00000732   0x2017             MOVS     R0,#+23
   \   00000734   0x.... 0x....      BL       man_error_set
   1203          		man_rpt_set_sequense(MAN_RPT_SEQ_READY);
   \   00000738   0x2000             MOVS     R0,#+0
   \   0000073A   0x.... 0x....      BL       man_rpt_set_sequense
   1204          		break;
   \   0000073E   0xE021             B        ??man_rpt_main_85
   1205          
   1206          	case MAN_RPT_SEQ_SEND2_USB:				// SEND2 USB
   1207          		break;
   \                     ??man_rpt_main_79: (+1)
   \   00000740   0xE020             B        ??man_rpt_main_85
   1208          
   1209          	case MAN_RPT_SEQ_SEND2_USB_OK:			// SEND2 USB完了
   1210          		man_rpt_set_sequense(MAN_RPT_SEQ_READY);
   \                     ??man_rpt_main_82: (+1)
   \   00000742   0x2000             MOVS     R0,#+0
   \   00000744   0x.... 0x....      BL       man_rpt_set_sequense
   1211          		break;
   \   00000748   0xE01C             B        ??man_rpt_main_85
   1212          
   1213          	case MAN_RPT_SEQ_SEND2_USB_NG:			// SEND2 USB異常
   1214          		man_rpt_set_sequense(MAN_RPT_SEQ_READY);
   \                     ??man_rpt_main_81: (+1)
   \   0000074A   0x2000             MOVS     R0,#+0
   \   0000074C   0x.... 0x....      BL       man_rpt_set_sequense
   1215          		man_error_setting(MAN_ERROR_MAN_RPT, 0, 0);
   \   00000750   0x....             LDR      R3,??DataTable11  ;; 0x4bf
   \   00000752   0x2200             MOVS     R2,#+0
   \   00000754   0x2100             MOVS     R1,#+0
   \   00000756   0x2017             MOVS     R0,#+23
   \   00000758   0x.... 0x....      BL       man_error_set
   1216          		break;
   \   0000075C   0xE012             B        ??man_rpt_main_85
   1217          
   1218          	case MAN_RPT_SEQ_ERROR:
   1219          		// 異常発生を上位に通知する
   1220          		if (man_rpt_work.noti_error.callback_error != NULL) {
   \                     ??man_rpt_main_83: (+1)
   \   0000075E   0x....             LDR      R0,??DataTable12
   \   00000760   0x6800             LDR      R0,[R0, #+0]
   \   00000762   0x2800             CMP      R0,#+0
   \   00000764   0xD005             BEQ      ??man_rpt_main_128
   1221          			man_rpt_work.noti_error.callback_error(man_rpt_work.noti_error.id, MAN_RPT_ERROR_REQ);
   \   00000766   0x2101             MOVS     R1,#+1
   \   00000768   0x....             LDR      R0,??DataTable12_1
   \   0000076A   0x6800             LDR      R0,[R0, #+0]
   \   0000076C   0x....             LDR      R2,??DataTable12
   \   0000076E   0x6812             LDR      R2,[R2, #+0]
   \   00000770   0x4790             BLX      R2
   1222          		}
   1223          		// 異常の解除を待つ
   1224          		man_rpt_set_sequense(MAN_RPT_SEQ_READY);
   \                     ??man_rpt_main_128: (+1)
   \   00000772   0x2000             MOVS     R0,#+0
   \   00000774   0x.... 0x....      BL       man_rpt_set_sequense
   1225          		break;
   \   00000778   0xE004             B        ??man_rpt_main_85
   \   0000077A   0xBF00             Nop      
   \                     ??man_rpt_main_104:
   \   0000077C   0x000003DF         DC32     0x3df
   \   00000780   0x000003F3         DC32     0x3f3
   1226          
   1227          	default:
   1228          		break;
   1229          	}
   1230          
   1231          
   1232          	// ***************************
   1233          	// NETWORK状態を通知処理
   1234          	// ***************************
   1235          	switch (man_rpt_work.req_state) {
   \                     ??man_rpt_main_84: (+1)
   \                     ??man_rpt_main_85: (+1)
   \   00000784   0x....             LDR      R0,??DataTable19
   \   00000786   0x6800             LDR      R0,[R0, #+0]
   \   00000788   0x2800             CMP      R0,#+0
   \   0000078A   0xD008             BEQ      ??man_rpt_main_129
   \   0000078C   0x2801             CMP      R0,#+1
   \   0000078E   0xD007             BEQ      ??man_rpt_main_130
   \   00000790   0x280B             CMP      R0,#+11
   \   00000792   0xD018             BEQ      ??man_rpt_main_131
   \   00000794   0x280C             CMP      R0,#+12
   \   00000796   0xD02B             BEQ      ??man_rpt_main_132
   \   00000798   0x280D             CMP      R0,#+13
   \   0000079A   0xD03F             BEQ      ??man_rpt_main_133
   \   0000079C   0xE053             B        ??man_rpt_main_134
   1236          	case MAN_RPT_STATE_NON:
   1237          		break;
   \                     ??man_rpt_main_129: (+1)
   \   0000079E   0xE052             B        ??man_rpt_main_134
   1238          
   1239          	// リセット発生
   1240          	case MAN_RPT_STATE_RESET:
   1241          		man_rpt_set_sequense(MAN_RPT_SEQ_READY);
   \                     ??man_rpt_main_130: (+1)
   \   000007A0   0x2000             MOVS     R0,#+0
   \   000007A2   0x.... 0x....      BL       man_rpt_set_sequense
   1242          		// レポート報告を停止する
   1243          		man_rpt_work.udp_sts = MAN_RPT_UDP_STS_CLOSE;
   \   000007A6   0x2000             MOVS     R0,#+0
   \   000007A8   0x....             LDR      R1,??DataTable9_7
   \   000007AA   0x7008             STRB     R0,[R1, #+0]
   1244          		// UDPのレポート管理を終了する
   1245          		man_rpt_work.udp_mode = MAN_RPT_MODE_STOP;
   \   000007AC   0x2000             MOVS     R0,#+0
   \   000007AE   0x....             LDR      R1,??DataTable17
   \   000007B0   0x7008             STRB     R0,[R1, #+0]
   1246          		// 送信終了
   1247          		man_rpt_work.trans_mode = 0;
   \   000007B2   0x2000             MOVS     R0,#+0
   \   000007B4   0x....             LDR      R1,??DataTable9_4
   \   000007B6   0x6708             STR      R0,[R1, #+112]
   1248          		man_rpt_work.req_state = MAN_RPT_STATE_NON;
   \   000007B8   0x2000             MOVS     R0,#+0
   \   000007BA   0x....             LDR      R1,??DataTable19
   \   000007BC   0x6008             STR      R0,[R1, #+0]
   1249          		man_rpt_work.cycle_req = MAN_RPT_CYCLE_REQ_READY;
   \   000007BE   0x2000             MOVS     R0,#+0
   \   000007C0   0x....             LDR      R1,??DataTable9_11
   \   000007C2   0x6008             STR      R0,[R1, #+0]
   1250          		break;
   \   000007C4   0xE03F             B        ??man_rpt_main_134
   1251          
   1252          	// NET CLOSE発生 -> NET OPENから再開
   1253          	case MAN_RPT_STATE_NET_CLOSE:
   1254          		man_rpt_set_sequense(MAN_RPT_SEQ_READY);
   \                     ??man_rpt_main_131: (+1)
   \   000007C6   0x2000             MOVS     R0,#+0
   \   000007C8   0x.... 0x....      BL       man_rpt_set_sequense
   1255          		// レポート報告を停止する
   1256          		man_rpt_work.udp_sts = MAN_RPT_UDP_STS_CLOSE;
   \   000007CC   0x2000             MOVS     R0,#+0
   \   000007CE   0x....             LDR      R1,??DataTable9_7
   \   000007D0   0x7008             STRB     R0,[R1, #+0]
   1257          		// UDPのレポート管理を終了する
   1258          		man_rpt_work.udp_mode = MAN_RPT_MODE_STOP;
   \   000007D2   0x2000             MOVS     R0,#+0
   \   000007D4   0x....             LDR      R1,??DataTable17
   \   000007D6   0x7008             STRB     R0,[R1, #+0]
   1259          		// 送信終了
   1260          		man_rpt_work.trans_mode = 0;
   \   000007D8   0x2000             MOVS     R0,#+0
   \   000007DA   0x....             LDR      R1,??DataTable9_4
   \   000007DC   0x6708             STR      R0,[R1, #+112]
   1261          		man_rpt_work.req_state = MAN_RPT_STATE_NON;
   \   000007DE   0x2000             MOVS     R0,#+0
   \   000007E0   0x....             LDR      R1,??DataTable19
   \   000007E2   0x6008             STR      R0,[R1, #+0]
   1262          		man_rpt_work.cycle_req = MAN_RPT_CYCLE_REQ_READY;
   \   000007E4   0x2000             MOVS     R0,#+0
   \   000007E6   0x....             LDR      R1,??DataTable9_11
   \   000007E8   0x6008             STR      R0,[R1, #+0]
   1263          		break;
   \   000007EA   0xE02C             B        ??man_rpt_main_134
   \                     ??man_rpt_main_108:
   \   000007EC   0x000003FB         DC32     0x3fb
   1264          
   1265          	// NOT_SUPPORT発生 -> SEND時は OPENから再開
   1266          	case MAN_RPT_STATE_DEV_NOT_SUPPORT:
   1267          		switch (man_rpt_work.sequense) {
   \                     ??man_rpt_main_132: (+1)
   \   000007F0   0x....             LDR      R0,??DataTable19_1
   \   000007F2   0x7800             LDRB     R0,[R0, #+0]
   \   000007F4   0x1E80             SUBS     R0,R0,#+2
   \   000007F6   0xD00C             BEQ      ??man_rpt_main_135
   \   000007F8   0x1E80             SUBS     R0,R0,#+2
   \   000007FA   0xD00A             BEQ      ??man_rpt_main_135
   \   000007FC   0x1E80             SUBS     R0,R0,#+2
   \   000007FE   0xD008             BEQ      ??man_rpt_main_135
   \   00000800   0x1E80             SUBS     R0,R0,#+2
   \   00000802   0xD006             BEQ      ??man_rpt_main_135
   \   00000804   0x1E80             SUBS     R0,R0,#+2
   \   00000806   0xD004             BEQ      ??man_rpt_main_135
   \   00000808   0x1E80             SUBS     R0,R0,#+2
   \   0000080A   0x2801             CMP      R0,#+1
   \   0000080C   0xD901             BLS      ??man_rpt_main_135
   \   0000080E   0x1EC0             SUBS     R0,R0,#+3
   \   00000810   0xD100             BNE      ??man_rpt_main_136
   1268          		case MAN_RPT_SEQ_OPEN_UDP:
   1269          		case MAN_RPT_SEQ_OPEN_UDP_NG:
   1270          		case MAN_RPT_SEQ_SEND1_UDP:
   1271          		case MAN_RPT_SEQ_SEND1_UDP_NG:
   1272          		case MAN_RPT_SEQ_SEND2_UDP:
   1273          		case MAN_RPT_SEQ_SEND2_UDP_NG:
   1274          		case MAN_RPT_SEQ_CLOSE_UDP:
   1275          		case MAN_RPT_SEQ_CLOSE_UDP_NG:
   1276          			break;
   \                     ??man_rpt_main_135: (+1)
   \   00000812   0xE002             B        ??man_rpt_main_137
   1277          		default:
   1278          			man_rpt_work.req_state = MAN_RPT_STATE_NON;
   \                     ??man_rpt_main_136: (+1)
   \   00000814   0x2000             MOVS     R0,#+0
   \   00000816   0x....             LDR      R1,??DataTable19
   \   00000818   0x6008             STR      R0,[R1, #+0]
   1279          			break;
   1280          		}
   1281          		break;
   \                     ??man_rpt_main_137: (+1)
   \   0000081A   0xE014             B        ??man_rpt_main_134
   1282          	
   1283          	// BUSY -> SEND時は CLOSEから再開
   1284          	case MAN_RPT_STATE_DEV_BUSY:
   1285          		switch (man_rpt_work.sequense) {
   \                     ??man_rpt_main_133: (+1)
   \   0000081C   0x....             LDR      R0,??DataTable19_1
   \   0000081E   0x7800             LDRB     R0,[R0, #+0]
   \   00000820   0x1E80             SUBS     R0,R0,#+2
   \   00000822   0xD00C             BEQ      ??man_rpt_main_138
   \   00000824   0x1E80             SUBS     R0,R0,#+2
   \   00000826   0xD00A             BEQ      ??man_rpt_main_138
   \   00000828   0x1E80             SUBS     R0,R0,#+2
   \   0000082A   0xD008             BEQ      ??man_rpt_main_138
   \   0000082C   0x1E80             SUBS     R0,R0,#+2
   \   0000082E   0xD006             BEQ      ??man_rpt_main_138
   \   00000830   0x1E80             SUBS     R0,R0,#+2
   \   00000832   0xD004             BEQ      ??man_rpt_main_138
   \   00000834   0x1E80             SUBS     R0,R0,#+2
   \   00000836   0x2801             CMP      R0,#+1
   \   00000838   0xD901             BLS      ??man_rpt_main_138
   \   0000083A   0x1EC0             SUBS     R0,R0,#+3
   \   0000083C   0xD100             BNE      ??man_rpt_main_139
   1286          		case MAN_RPT_SEQ_OPEN_UDP:
   1287          		case MAN_RPT_SEQ_OPEN_UDP_NG:
   1288          		case MAN_RPT_SEQ_SEND1_UDP:
   1289          		case MAN_RPT_SEQ_SEND1_UDP_NG:
   1290          		case MAN_RPT_SEQ_SEND2_UDP:
   1291          		case MAN_RPT_SEQ_SEND2_UDP_NG:
   1292          		case MAN_RPT_SEQ_CLOSE_UDP:
   1293          		case MAN_RPT_SEQ_CLOSE_UDP_NG:
   1294          			break;
   \                     ??man_rpt_main_138: (+1)
   \   0000083E   0xE002             B        ??man_rpt_main_140
   1295          		default:
   1296          			man_rpt_work.req_state = MAN_RPT_STATE_NON;
   \                     ??man_rpt_main_139: (+1)
   \   00000840   0x2000             MOVS     R0,#+0
   \   00000842   0x....             LDR      R1,??DataTable19
   \   00000844   0x6008             STR      R0,[R1, #+0]
   1297          			break;
   1298          		}
   1299          		break;
   1300          	}
   1301          
   1302          }
   \                     ??man_rpt_main_140: (+1)
   \                     ??man_rpt_main_134: (+1)
   \   00000846   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   \                     ??man_rpt_main_113:
   \   00000848   0x........         DC32     man_rpt_work+0x1650
   \   0000084C   0x........         DC32     man_rpt_work+0x1254
   1303          
   1304          
   1305          /********************************************************************/
   1306          /*!
   1307           * \name	man_rpt_1000ms_main
   1308           * \brief	1000ms毎に行う処理
   1309           * \param	なし
   1310           * \return  なし
   1311           * \note	1000ms毎に、呼ばれること
   1312           */
   1313          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1314          void man_rpt_1000ms_main( void )
   1315          {
   \                     man_rpt_1000ms_main: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   1316          	man_data_get_sensor_t	*sensor = man_data_get_sensor();
   \   00000002   0x.... 0x....      BL       man_data_get_sensor
   \   00000006   0x0005             MOVS     R5,R0
   1317          	man_rpt_cycle_info_t	*cycle_info = &man_rpt_work.cycle_info;
   \   00000008   0x....             LDR      R4,??DataTable22
   1318          	man_data_fixed_t		*fixed = man_data_get_fixed();
   \   0000000A   0x.... 0x....      BL       man_data_get_fixed
   \   0000000E   0x0006             MOVS     R6,R0
   1319          
   1320          	
   1321          	// GPS測位結果出力サイクル設定情報の変更を確認する
   1322          	man_rpt_check_setting();
   \   00000010   0x.... 0x....      BL       man_rpt_check_setting
   1323          
   1324          	// 出力先がUDPの場合
   1325          	if (man_rpt_work.select == MAN_RPT_SEL_UDP) {
   \   00000014   0x....             LDR      R0,??DataTable22_1
   \   00000016   0x7800             LDRB     R0,[R0, #+0]
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD175             BNE      ??man_rpt_1000ms_main_0
   1326          		// レポート報告開始
   1327          		if ( (man_rpt_work.udp_mode == MAN_RPT_MODE_START) 
   1328          			  && (man_rpt_work.send_mode == MAN_RPT_SEND_START)
   1329          			  && (man_rpt_work.rssi_sts != MAN_DATA_RSSI_STS_NG)
   1330          			  && (cycle_info->setting.run_interval != 0) ) {			// run_interval = 0の場合、レポート機能なし
   \   0000001C   0x....             LDR      R0,??DataTable17
   \   0000001E   0x7800             LDRB     R0,[R0, #+0]
   \   00000020   0x2801             CMP      R0,#+1
   \   00000022   0xD140             BNE      ??man_rpt_1000ms_main_1
   \   00000024   0x....             LDR      R0,??DataTable22_2
   \   00000026   0x7800             LDRB     R0,[R0, #+0]
   \   00000028   0x2800             CMP      R0,#+0
   \   0000002A   0xD13C             BNE      ??man_rpt_1000ms_main_1
   \   0000002C   0x....             LDR      R0,??DataTable22_3
   \   0000002E   0x7800             LDRB     R0,[R0, #+0]
   \   00000030   0x2800             CMP      R0,#+0
   \   00000032   0xD038             BEQ      ??man_rpt_1000ms_main_1
   \   00000034   0x6860             LDR      R0,[R4, #+4]
   \   00000036   0x2800             CMP      R0,#+0
   \   00000038   0xD035             BEQ      ??man_rpt_1000ms_main_1
   1331          
   1332          			// NMEAの取得を待つ
   1333          			if (sensor->nmea_len != 0) {
   \   0000003A   0x20BE             MOVS     R0,#+190
   \   0000003C   0x00C0             LSLS     R0,R0,#+3        ;; #+1520
   \   0000003E   0x5828             LDR      R0,[R5, R0]
   \   00000040   0x2800             CMP      R0,#+0
   \   00000042   0xD037             BEQ      ??man_rpt_1000ms_main_2
   1334          
   1335          				// 0Vモード(park_interval使用)の場合
   1336          				if (cycle_info->mode0v == MAN_RPT_0VMODE_ON) {
   \   00000044   0x2020             MOVS     R0,#+32
   \   00000046   0x5C20             LDRB     R0,[R4, R0]
   \   00000048   0x2801             CMP      R0,#+1
   \   0000004A   0xD118             BNE      ??man_rpt_1000ms_main_3
   1337          					if (cycle_info->park_counter == 0) {
   \   0000004C   0x69E0             LDR      R0,[R4, #+28]
   \   0000004E   0x2800             CMP      R0,#+0
   \   00000050   0xD102             BNE      ??man_rpt_1000ms_main_4
   1338          						man_rpt_work.cycle_req = MAN_RPT_CYCLE_REQ_SEND;
   \   00000052   0x2001             MOVS     R0,#+1
   \   00000054   0x....             LDR      R1,??DataTable22_4
   \   00000056   0x6008             STR      R0,[R1, #+0]
   1339          					}
   1340          					cycle_info->mode0v_timer++;
   \                     ??man_rpt_1000ms_main_4: (+1)
   \   00000058   0x6A60             LDR      R0,[R4, #+36]
   \   0000005A   0x1C40             ADDS     R0,R0,#+1
   \   0000005C   0x6260             STR      R0,[R4, #+36]
   1341          					// 5分経過後は中止する
   1342          					if (cycle_info->mode0v_timer >= fixed->park_max_time * 60) {
   \   0000005E   0x6A60             LDR      R0,[R4, #+36]
   \   00000060   0x6931             LDR      R1,[R6, #+16]
   \   00000062   0x223C             MOVS     R2,#+60
   \   00000064   0x4351             MULS     R1,R2,R1
   \   00000066   0x4288             CMP      R0,R1
   \   00000068   0xD324             BCC      ??man_rpt_1000ms_main_2
   1343          						cycle_info->mode0v = MAN_RPT_0VMODE_OFF;
   \   0000006A   0x2000             MOVS     R0,#+0
   \   0000006C   0x2120             MOVS     R1,#+32
   \   0000006E   0x5460             STRB     R0,[R4, R1]
   1344          						// デバックログに登録 
   1345          						man_dbglog_setting(MAN_ERROR_DBG_MAN_RPT, MAN_ERROR_DBG_TYPE_EVENT, cycle_info->mode0v);
   \   00000070   0x2020             MOVS     R0,#+32
   \   00000072   0x5C22             LDRB     R2,[R4, R0]
   \   00000074   0x2104             MOVS     R1,#+4
   \   00000076   0x2005             MOVS     R0,#+5
   \   00000078   0x.... 0x....      BL       man_dbglog_setting
   \   0000007C   0xE01A             B        ??man_rpt_1000ms_main_2
   1346          					}
   1347          				}
   1348          				
   1349          				// 通常モードの場合
   1350          				else {
   1351          					if (cycle_info->send_counter <  cycle_info->setting.duration_time_num) {
   \                     ??man_rpt_1000ms_main_3: (+1)
   \   0000007E   0x6960             LDR      R0,[R4, #+20]
   \   00000080   0x68E1             LDR      R1,[R4, #+12]
   \   00000082   0x4288             CMP      R0,R1
   \   00000084   0xD203             BCS      ??man_rpt_1000ms_main_5
   1352          						man_rpt_work.cycle_req = MAN_RPT_CYCLE_REQ_SEND;
   \   00000086   0x2001             MOVS     R0,#+1
   \   00000088   0x....             LDR      R1,??DataTable22_4
   \   0000008A   0x6008             STR      R0,[R1, #+0]
   \   0000008C   0xE012             B        ??man_rpt_1000ms_main_2
   1353          					}
   1354          					else {
   1355          						// 送信終了
   1356          						man_rpt_work.trans_mode = 0;
   \                     ??man_rpt_1000ms_main_5: (+1)
   \   0000008E   0x2000             MOVS     R0,#+0
   \   00000090   0x....             LDR      R1,??DataTable22_5
   \   00000092   0x6708             STR      R0,[R1, #+112]
   1357          						// run_interval - duration_time_num が5秒未満の場合はCLOSEを行わない
   1358          						if ( (cycle_info->setting.run_interval - cycle_info->setting.duration_time_num) >= MAN_RPT_CLOSE_DURATION ) {
   \   00000094   0x6860             LDR      R0,[R4, #+4]
   \   00000096   0x68E1             LDR      R1,[R4, #+12]
   \   00000098   0x1A40             SUBS     R0,R0,R1
   \   0000009A   0x2805             CMP      R0,#+5
   \   0000009C   0xD30A             BCC      ??man_rpt_1000ms_main_2
   1359          							man_rpt_work.cycle_req = MAN_RPT_CYCLE_REQ_CLOSE;
   \   0000009E   0x2002             MOVS     R0,#+2
   \   000000A0   0x....             LDR      R1,??DataTable22_4
   \   000000A2   0x6008             STR      R0,[R1, #+0]
   \   000000A4   0xE006             B        ??man_rpt_1000ms_main_2
   1360          						}
   1361          					}
   1362          				}
   1363          			}
   1364          		}
   1365          		// レポート報告停止
   1366          		else {
   1367          			if (man_rpt_work.udp_sts != MAN_RPT_UDP_STS_CLOSE) {
   \                     ??man_rpt_1000ms_main_1: (+1)
   \   000000A6   0x....             LDR      R0,??DataTable22_6
   \   000000A8   0x7800             LDRB     R0,[R0, #+0]
   \   000000AA   0x2800             CMP      R0,#+0
   \   000000AC   0xD002             BEQ      ??man_rpt_1000ms_main_2
   1368          				man_rpt_work.cycle_req = MAN_RPT_CYCLE_REQ_CLOSE;
   \   000000AE   0x2002             MOVS     R0,#+2
   \   000000B0   0x....             LDR      R1,??DataTable22_4
   \   000000B2   0x6008             STR      R0,[R1, #+0]
   1369          			}
   1370          		}
   1371          
   1372          		cycle_info->counter++;
   \                     ??man_rpt_1000ms_main_2: (+1)
   \   000000B4   0x69A0             LDR      R0,[R4, #+24]
   \   000000B6   0x1C40             ADDS     R0,R0,#+1
   \   000000B8   0x61A0             STR      R0,[R4, #+24]
   1373          		if (cycle_info->counter >= cycle_info->setting.run_interval) {
   \   000000BA   0x69A0             LDR      R0,[R4, #+24]
   \   000000BC   0x6861             LDR      R1,[R4, #+4]
   \   000000BE   0x4288             CMP      R0,R1
   \   000000C0   0xD303             BCC      ??man_rpt_1000ms_main_6
   1374          			cycle_info->counter = 0;
   \   000000C2   0x2000             MOVS     R0,#+0
   \   000000C4   0x61A0             STR      R0,[R4, #+24]
   1375          			cycle_info->send_counter = 0;		// 送信数の初期化
   \   000000C6   0x2000             MOVS     R0,#+0
   \   000000C8   0x6160             STR      R0,[R4, #+20]
   1376          		}
   1377          		if (cycle_info->mode0v == MAN_RPT_0VMODE_ON) {
   \                     ??man_rpt_1000ms_main_6: (+1)
   \   000000CA   0x2020             MOVS     R0,#+32
   \   000000CC   0x5C20             LDRB     R0,[R4, R0]
   \   000000CE   0x2801             CMP      R0,#+1
   \   000000D0   0xD108             BNE      ??man_rpt_1000ms_main_7
   1378          			cycle_info->park_counter++;
   \   000000D2   0x69E0             LDR      R0,[R4, #+28]
   \   000000D4   0x1C40             ADDS     R0,R0,#+1
   \   000000D6   0x61E0             STR      R0,[R4, #+28]
   1379          			if (cycle_info->park_counter >= cycle_info->setting.park_interval) {
   \   000000D8   0x69E0             LDR      R0,[R4, #+28]
   \   000000DA   0x6821             LDR      R1,[R4, #+0]
   \   000000DC   0x4288             CMP      R0,R1
   \   000000DE   0xD301             BCC      ??man_rpt_1000ms_main_7
   1380          				cycle_info->park_counter = 0;
   \   000000E0   0x2000             MOVS     R0,#+0
   \   000000E2   0x61E0             STR      R0,[R4, #+28]
   1381          			}
   1382          		}
   1383          
   1384          		// 0Vモード(park_interval使用)の場合
   1385          		if (cycle_info->mode0v == MAN_RPT_0VMODE_ON) {
   \                     ??man_rpt_1000ms_main_7: (+1)
   \   000000E4   0x2020             MOVS     R0,#+32
   \   000000E6   0x5C20             LDRB     R0,[R4, R0]
   \   000000E8   0x2801             CMP      R0,#+1
   \   000000EA   0xD118             BNE      ??man_rpt_1000ms_main_8
   1386          			// 有効位置状態の場合は解除する
   1387          			if (sensor->nmea_status == MAN_GPS_NMEA_STATUS_EFFECTIVE) {
   \   000000EC   0x....             LDR      R0,??DataTable22_7  ;; 0xbc8
   \   000000EE   0x5828             LDR      R0,[R5, R0]
   \   000000F0   0x2802             CMP      R0,#+2
   \   000000F2   0xD114             BNE      ??man_rpt_1000ms_main_8
   1388          				cycle_info->mode0v = MAN_RPT_0VMODE_OFF;
   \   000000F4   0x2000             MOVS     R0,#+0
   \   000000F6   0x2120             MOVS     R1,#+32
   \   000000F8   0x5460             STRB     R0,[R4, R1]
   1389          				// デバックログに登録 
   1390          				man_dbglog_setting(MAN_ERROR_DBG_MAN_RPT, MAN_ERROR_DBG_TYPE_EVENT, cycle_info->mode0v);
   \   000000FA   0x2020             MOVS     R0,#+32
   \   000000FC   0x5C22             LDRB     R2,[R4, R0]
   \   000000FE   0x2104             MOVS     R1,#+4
   \   00000100   0x2005             MOVS     R0,#+5
   \   00000102   0x.... 0x....      BL       man_dbglog_setting
   \   00000106   0xE00A             B        ??man_rpt_1000ms_main_8
   1391          			}
   1392          		}
   1393          	}
   1394          
   1395          
   1396          	// 出力先がUSBの場合
   1397          	else {
   1398          		// レポート報告開始
   1399          		if ( (man_rpt_work.usb_mode == MAN_RPT_MODE_START) && (man_rpt_work.send_mode == MAN_RPT_SEND_START) ) {
   \                     ??man_rpt_1000ms_main_0: (+1)
   \   00000108   0x....             LDR      R0,??DataTable22_8
   \   0000010A   0x7800             LDRB     R0,[R0, #+0]
   \   0000010C   0x2801             CMP      R0,#+1
   \   0000010E   0xD106             BNE      ??man_rpt_1000ms_main_8
   \   00000110   0x....             LDR      R0,??DataTable22_2
   \   00000112   0x7800             LDRB     R0,[R0, #+0]
   \   00000114   0x2800             CMP      R0,#+0
   \   00000116   0xD102             BNE      ??man_rpt_1000ms_main_8
   1400          			man_rpt_work.cycle_req = MAN_RPT_CYCLE_REQ_USB_SEND;
   \   00000118   0x2003             MOVS     R0,#+3
   \   0000011A   0x....             LDR      R1,??DataTable22_4
   \   0000011C   0x6008             STR      R0,[R1, #+0]
   1401          		}
   1402          	}
   1403          }
   \                     ??man_rpt_1000ms_main_8: (+1)
   \   0000011E   0xBD70             POP      {R4-R6,PC}       ;; return
   1404          
   1405          
   1406          /********************************************************************/
   1407          /*!
   1408           * \name	man_rpt_req_udp_start
   1409           * \brief	UDPのレポート管理を開始する処理
   1410           * \param	なし
   1411           * \return  なし
   1412           * \note	起動時に、呼ばれること
   1413           */
   1414          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1415          void man_rpt_req_udp_start( void )
   1416          {
   1417          
   1418          	man_rpt_work.udp_mode = MAN_RPT_MODE_START;
   \                     man_rpt_req_udp_start: (+1)
   \   00000000   0x2001             MOVS     R0,#+1
   \   00000002   0x....             LDR      R1,??DataTable17
   \   00000004   0x7008             STRB     R0,[R1, #+0]
   1419          	man_rpt_work.select = MAN_RPT_SEL_UDP;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x....             LDR      R1,??DataTable22_1
   \   0000000A   0x7008             STRB     R0,[R1, #+0]
   1420          
   1421          }
   \   0000000C   0x4770             BX       LR               ;; return
   1422          
   1423          
   1424          /********************************************************************/
   1425          /*!
   1426           * \name	man_rpt_req_usb_start
   1427           * \brief	USBのレポート管理を開始する処理
   1428           * \param	なし
   1429           * \return  なし
   1430           * \note	起動時に、呼ばれること
   1431           */
   1432          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1433          void man_rpt_req_usb_start( void )
   1434          {
   1435          
   1436          	man_rpt_work.usb_mode = MAN_RPT_MODE_START;
   \                     man_rpt_req_usb_start: (+1)
   \   00000000   0x2001             MOVS     R0,#+1
   \   00000002   0x....             LDR      R1,??DataTable22_8
   \   00000004   0x7008             STRB     R0,[R1, #+0]
   1437          	man_rpt_work.select = MAN_RPT_SEL_USB;
   \   00000006   0x2001             MOVS     R0,#+1
   \   00000008   0x....             LDR      R1,??DataTable22_1
   \   0000000A   0x7008             STRB     R0,[R1, #+0]
   1438          
   1439          }
   \   0000000C   0x4770             BX       LR               ;; return
   1440          
   1441          
   1442          /********************************************************************/
   1443          /*!
   1444           * \name	man_rpt_req_udp_stop
   1445           * \brief	UDPのレポート管理を終了する処理
   1446           * \param	なし
   1447           * \return   0: 成功
   1448           *          -1:失敗
   1449           * \note	起動時に、呼ばれること
   1450           */
   1451          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1452          int32_t man_rpt_req_udp_stop( int32_t id, func_man_rpt callback )
   1453          {
   \                     man_rpt_req_udp_stop: (+1)
   \   00000000   0xB410             PUSH     {R4}
   \   00000002   0x0002             MOVS     R2,R0
   1454          	int32_t	ret=0;
   \   00000004   0x2000             MOVS     R0,#+0
   1455          
   1456          	man_rpt_work.udp_mode = MAN_RPT_MODE_STOP;
   \   00000006   0x2300             MOVS     R3,#+0
   \   00000008   0x....             LDR      R4,??DataTable17
   \   0000000A   0x7023             STRB     R3,[R4, #+0]
   1457          	man_rpt_work.request.req_cmd = MAN_RPT_REQ_CMD_CLOSE;
   \   0000000C   0x2301             MOVS     R3,#+1
   \   0000000E   0x....             LDR      R4,??DataTable22_5
   \   00000010   0x67A3             STR      R3,[R4, #+120]
   1458          	man_rpt_work.request.id = id;
   \   00000012   0x....             LDR      R3,??DataTable22_5
   \   00000014   0x67DA             STR      R2,[R3, #+124]
   1459          	man_rpt_work.request.callback = callback;
   \   00000016   0x....             LDR      R2,??DataTable22_9
   \   00000018   0x6011             STR      R1,[R2, #+0]
   1460          
   1461          	return ret;
   \   0000001A   0xBC10             POP      {R4}
   \   0000001C   0x4770             BX       LR               ;; return
   1462          }
   1463          
   1464          
   1465          /********************************************************************/
   1466          /*!
   1467           * \name	man_rpt_req_usb_stop
   1468           * \brief	USBのレポート管理を終了する処理
   1469           * \param	なし
   1470           * \return   0: 成功
   1471           *          -1:失敗
   1472           * \note	起動時に、呼ばれること
   1473           */
   1474          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1475          void man_rpt_req_usb_stop( void )
   1476          {
   1477          	man_rpt_work.usb_mode = MAN_RPT_MODE_STOP;
   \                     man_rpt_req_usb_stop: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x....             LDR      R1,??DataTable22_8
   \   00000004   0x7008             STRB     R0,[R1, #+0]
   1478          }
   \   00000006   0x4770             BX       LR               ;; return
   1479          
   1480          
   1481          /********************************************************************/
   1482          /*!
   1483           * \name	man_rpt_req_send_start
   1484           * \brief	レポートの送信を開始する処理
   1485           * \param	なし
   1486           * \return  なし
   1487           * \note	udp, usb開始時に呼ばれると出力を再開する
   1488           *          外部電源ON時に復活させる
   1489           *          初期化後は開始状態
   1490           */
   1491          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1492          void man_rpt_req_send_start( void )
   1493          {
   1494          	man_rpt_work.send_mode = MAN_RPT_SEND_START;
   \                     man_rpt_req_send_start: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x....             LDR      R1,??DataTable22_2
   \   00000004   0x7008             STRB     R0,[R1, #+0]
   1495          }
   \   00000006   0x4770             BX       LR               ;; return
   1496          
   1497          
   1498          /********************************************************************/
   1499          /*!
   1500           * \name	man_rpt_req_send_stop
   1501           * \brief	レポートの送信を停止する処理
   1502           * \param	なし
   1503           * \return  なし
   1504           * \note	udp, usb開始時に呼ばれると出力を中止する
   1505           *          外部電源OFF時の定刻測位時は送信を停止する
   1506           */
   1507          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1508          void man_rpt_req_send_stop( void )
   1509          {
   1510          	man_rpt_work.send_mode = MAN_RPT_SEND_STOP;
   \                     man_rpt_req_send_stop: (+1)
   \   00000000   0x2001             MOVS     R0,#+1
   \   00000002   0x....             LDR      R1,??DataTable22_2
   \   00000004   0x7008             STRB     R0,[R1, #+0]
   1511          }
   \   00000006   0x4770             BX       LR               ;; return
   1512          
   1513          /********************************************************************/
   1514          /*!
   1515           * \name	man_rpt_req_state
   1516           * \brief	NETWORK状態を通知する
   1517           * \param	state         : MAN_RPT_STATE_RESET           : リセット発生
   1518           *                        : MAN_RPT_STATE_NET_CLOSE       : SM7500JE の自動 NET CLOSE
   1519           *                        : MAN_RPT_STATE_DEV_NOT_SUPPORT : SM7500JE のNOT_SUPPORT
   1520           *                        : MAN_RPT_STATE_DEV_BUSY        : SM7500JE のDEV BUSY
   1521           * \return  なし
   1522           * \note	必要時に、呼ばれること
   1523           */
   1524          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1525          void man_rpt_req_state(int32_t state)
   1526          {
   1527          	man_rpt_work.req_state = state;
   \                     man_rpt_req_state: (+1)
   \   00000000   0x....             LDR      R1,??DataTable19
   \   00000002   0x6008             STR      R0,[R1, #+0]
   1528          }
   \   00000004   0x4770             BX       LR               ;; return
   1529          
   1530          
   1531          /********************************************************************/
   1532          /*!
   1533           * \name	man_rpt_noti_error
   1534           * \brief	RPTの異常を通知する
   1535           * \param	id             : ユニーク番号
   1536           *          callback_error : 異常を通知するcallback関数
   1537           * \return   0: 成功
   1538           *          -1:失敗
   1539           * \note	必要時に、呼ばれること
   1540           */
   1541          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1542          int32_t man_rpt_noti_error(int32_t id, func_man_rpt callback_error)
   1543          {
   \                     man_rpt_noti_error: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0x0002             MOVS     R2,R0
   1544          	int32_t		ret = -1;
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x43C0             MVNS     R0,R0            ;; #-1
   1545          	
   1546          	if (callback_error != NULL) {
   \   00000008   0x000B             MOVS     R3,R1
   \   0000000A   0x2B00             CMP      R3,#+0
   \   0000000C   0xD004             BEQ      ??man_rpt_noti_error_0
   1547          		man_rpt_work.noti_error.id = id;
   \   0000000E   0x....             LDR      R0,??DataTable22_10
   \   00000010   0x6002             STR      R2,[R0, #+0]
   1548          		man_rpt_work.noti_error.callback_error = callback_error;
   \   00000012   0x....             LDR      R0,??DataTable22_11
   \   00000014   0x6001             STR      R1,[R0, #+0]
   1549          		ret = 0;
   \   00000016   0x2000             MOVS     R0,#+0
   1550          	}
   1551          	return ret;
   \                     ??man_rpt_noti_error_0: (+1)
   \   00000018   0xBD00             POP      {PC}             ;; return
   1552          }
   1553          
   1554          /********************************************************************/
   1555          /*!
   1556           * \name	man_rpt_get_data
   1557           * \brief	RPT状態を取得する
   1558           * \param	trans_mode     : 1 通信中
   1559           * \return  なし
   1560           * \note	必要時に、呼ばれること
   1561           */
   1562          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1563          void man_rpt_get_data(int32_t *trans_mode) 
   1564          {
   1565          	*trans_mode = man_rpt_work.trans_mode;
   \                     man_rpt_get_data: (+1)
   \   00000000   0x....             LDR      R1,??DataTable22_5
   \   00000002   0x6F09             LDR      R1,[R1, #+112]
   \   00000004   0x6001             STR      R1,[R0, #+0]
   1566          }
   \   00000006   0x4770             BX       LR               ;; return
   1567          
   1568          
   1569          /********************************************************************/
   1570          /*!
   1571           * \name	man_rpt_req_park_interval
   1572           * \brief	park_interval測位開始
   1573           * \param	なし
   1574           * \return  なし
   1575           * \note	必要時に、呼ばれること
   1576           */
   1577          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1578          void man_rpt_req_park_interval( void )
   1579          {
   \                     man_rpt_req_park_interval: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1580          	man_rpt_cycle_info_t	*cycle_info = &man_rpt_work.cycle_info;
   \   00000002   0x....             LDR      R0,??DataTable22
   1581          
   1582          	if (cycle_info->mode0v == MAN_RPT_0VMODE_OFF) {
   \   00000004   0x2120             MOVS     R1,#+32
   \   00000006   0x5C41             LDRB     R1,[R0, R1]
   \   00000008   0x2900             CMP      R1,#+0
   \   0000000A   0xD114             BNE      ??man_rpt_req_park_interval_0
   1583          		// park_intervalが0の場合は無効, run_intervalが0の場合は無効
   1584          		if ( (cycle_info->setting.park_interval != 0) && (cycle_info->setting.run_interval != 0) ) {
   \   0000000C   0x6801             LDR      R1,[R0, #+0]
   \   0000000E   0x2900             CMP      R1,#+0
   \   00000010   0xD00E             BEQ      ??man_rpt_req_park_interval_1
   \   00000012   0x6841             LDR      R1,[R0, #+4]
   \   00000014   0x2900             CMP      R1,#+0
   \   00000016   0xD00B             BEQ      ??man_rpt_req_park_interval_1
   1585          			cycle_info->mode0v = MAN_RPT_0VMODE_ON;
   \   00000018   0x2101             MOVS     R1,#+1
   \   0000001A   0x2220             MOVS     R2,#+32
   \   0000001C   0x5481             STRB     R1,[R0, R2]
   1586          			cycle_info->mode0v_timer = 0;
   \   0000001E   0x2100             MOVS     R1,#+0
   \   00000020   0x6241             STR      R1,[R0, #+36]
   1587          
   1588          			// デバックログに登録 
   1589          			man_dbglog_setting(MAN_ERROR_DBG_MAN_RPT, MAN_ERROR_DBG_TYPE_EVENT, cycle_info->mode0v);
   \   00000022   0x2120             MOVS     R1,#+32
   \   00000024   0x5C42             LDRB     R2,[R0, R1]
   \   00000026   0x2104             MOVS     R1,#+4
   \   00000028   0x2005             MOVS     R0,#+5
   \   0000002A   0x.... 0x....      BL       man_dbglog_setting
   \   0000002E   0xE002             B        ??man_rpt_req_park_interval_0
   1590          		}
   1591          		else {
   1592          			cycle_info->mode0v = MAN_RPT_0VMODE_OFF;
   \                     ??man_rpt_req_park_interval_1: (+1)
   \   00000030   0x2100             MOVS     R1,#+0
   \   00000032   0x2220             MOVS     R2,#+32
   \   00000034   0x5481             STRB     R1,[R0, R2]
   1593          		}
   1594          	}
   1595          }
   \                     ??man_rpt_req_park_interval_0: (+1)
   \   00000036   0xBD01             POP      {R0,PC}          ;; return
   1596          
   1597          
   1598          /********************************************************************/
   1599          /*!
   1600           * \name	man_rpt_init_cycle_counter
   1601           * \brief	cycle counterを初期化する処理
   1602           * \param	なし
   1603           * \return  なし
   1604           * \note	必要時に、呼ばれること
   1605           */
   1606          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1607          void man_rpt_init_cycle_counter( void )
   1608          {
   1609          	man_rpt_work.cycle_info.counter = 0;
   \                     man_rpt_init_cycle_counter: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x....             LDR      R1,??DataTable22_12
   \   00000004   0x6008             STR      R0,[R1, #+0]
   1610          	man_rpt_work.cycle_info.send_counter = 0;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x....             LDR      R1,??DataTable22_13
   \   0000000A   0x6008             STR      R0,[R1, #+0]
   1611          }
   \   0000000C   0x4770             BX       LR               ;; return
   1612          
   1613          
   1614          /********************************************************************/
   1615          /*!
   1616           * \name	man_rpt_check_send_state
   1617           * \brief	送信状態を確認する
   1618           * \param	なし
   1619           * \return  0 : 送信状態以外
   1620           *          1 : 送信状態
   1621           * \note	必要時に、呼ばれること
   1622           */
   1623          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1624          int32_t man_rpt_check_send_state( void )
   1625          {
   \                     man_rpt_check_send_state: (+1)
   \   00000000   0xB500             PUSH     {LR}
   1626          	int32_t		ret=0;
   \   00000002   0x2000             MOVS     R0,#+0
   1627          	
   1628          	switch (man_rpt_work.sequense) {
   \   00000004   0x....             LDR      R1,??DataTable22_14
   \   00000006   0x7809             LDRB     R1,[R1, #+0]
   \   00000008   0x2900             CMP      R1,#+0
   \   0000000A   0xD00C             BEQ      ??man_rpt_check_send_state_0
   \   0000000C   0x1E49             SUBS     R1,R1,#+1
   \   0000000E   0x2903             CMP      R1,#+3
   \   00000010   0xD90A             BLS      ??man_rpt_check_send_state_1
   \   00000012   0x1F09             SUBS     R1,R1,#+4
   \   00000014   0x2904             CMP      R1,#+4
   \   00000016   0xD908             BLS      ??man_rpt_check_send_state_2
   \   00000018   0x1F49             SUBS     R1,R1,#+5
   \   0000001A   0x2905             CMP      R1,#+5
   \   0000001C   0xD906             BLS      ??man_rpt_check_send_state_3
   \   0000001E   0x1F89             SUBS     R1,R1,#+6
   \   00000020   0x2908             CMP      R1,#+8
   \   00000022   0xD905             BLS      ??man_rpt_check_send_state_4
   \   00000024   0xE004             B        ??man_rpt_check_send_state_5
   1629          	case MAN_RPT_SEQ_READY:					// 00 : 要求待ち
   1630          		break;
   \                     ??man_rpt_check_send_state_0: (+1)
   \   00000026   0xE003             B        ??man_rpt_check_send_state_5
   1631          	case MAN_RPT_SEQ_OPEN_UDP_REQ:			// 01 : OPEN UDP開始
   1632          	case MAN_RPT_SEQ_OPEN_UDP:				// 02 : OPEN UDP中
   1633          	case MAN_RPT_SEQ_OPEN_UDP_OK:			// 03 : OPEN UDP完了
   1634          	case MAN_RPT_SEQ_OPEN_UDP_NG:			// 04 : OPEN UDP異常
   1635          		break;
   \                     ??man_rpt_check_send_state_1: (+1)
   \   00000028   0xE002             B        ??man_rpt_check_send_state_5
   1636          	case MAN_RPT_SEQ_CLOSE_UDP_REQ:			// 05 : CLOSE UDP要求
   1637          	case MAN_RPT_SEQ_CLOSE_UDP:				// 06 : CLOSE UDP中
   1638          	case MAN_RPT_SEQ_CLOSE_UDP_OK:			// 07 : CLOSE UDP完了
   1639          	case MAN_RPT_SEQ_CLOSE_UDP_NG:			// 08 : CLOSE UDP異常
   1640          	case MAN_RPT_SEQ_SEND1_UDP_REQ:			// 09 : SEND1 UDP要求
   1641          		break;
   \                     ??man_rpt_check_send_state_2: (+1)
   \   0000002A   0xE001             B        ??man_rpt_check_send_state_5
   1642          	case MAN_RPT_SEQ_SEND1_UDP:				// 10 : SEND1 UDP
   1643          	case MAN_RPT_SEQ_SEND1_UDP_OK:			// 11 : SEND1 UDP完了
   1644          	case MAN_RPT_SEQ_SEND1_UDP_NG:			// 12 : SEND1 UDP異常
   1645          	case MAN_RPT_SEQ_SEND2_UDP:				// 13 : SEND2 UDP
   1646          	case MAN_RPT_SEQ_SEND2_UDP_OK:			// 14 : SEND2 UDP完了
   1647          	case MAN_RPT_SEQ_SEND2_UDP_NG:			// 15 : SEND2 UDP異常
   1648          		ret=1;
   \                     ??man_rpt_check_send_state_3: (+1)
   \   0000002C   0x2001             MOVS     R0,#+1
   1649          		break;
   \   0000002E   0xE7FF             B        ??man_rpt_check_send_state_5
   1650          	case MAN_RPT_SEQ_SEND1_USB_REQ:			// 16 : SEND1 USB要求
   1651          	case MAN_RPT_SEQ_SEND1_USB:				// 17 : SEND1 USB
   1652          	case MAN_RPT_SEQ_SEND1_USB_OK:			// 18 : SEND1 USB完了
   1653          	case MAN_RPT_SEQ_SEND1_USB_NG:			// 19 : SEND1 USB異常
   1654          	case MAN_RPT_SEQ_SEND2_USB:				// 20 : SEND2 USB
   1655          	case MAN_RPT_SEQ_SEND2_USB_OK:			// 21 : SEND2 USB完了
   1656          	case MAN_RPT_SEQ_SEND2_USB_NG:			// 22 : SEND2 USB異常
   1657          	case MAN_RPT_SEQ_ERROR:					// 23 : 異常状態
   1658          	case MAN_RPT_SEQ_ERROR_WAIT:			// 24 : 異常解除待ち
   1659          		break;
   1660          	}
   1661          	
   1662          	return ret;
   \                     ??man_rpt_check_send_state_4: (+1)
   \                     ??man_rpt_check_send_state_5: (+1)
   \   00000030   0xBD00             POP      {PC}             ;; return
   1663          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \   00000000   0x........         DC32     man_rpt_work+0xC8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_1:
   \   00000000   0x........         DC32     man_rpt_work+0xCC

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_2:
   \   00000000   0x........         DC32     man_rpt_work+0xD0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_3:
   \   00000000   0x........         DC32     man_rpt_work+0x74

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_4:
   \   00000000   0x........         DC32     man_rpt_work

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_5:
   \   00000000   0x........         DC32     man_rpt_work+0x80

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_6:
   \   00000000   0x00000BDC         DC32     0xbdc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_7:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_8:
   \   00000000   0x........         DC32     man_rpt_work+0x68

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_9:
   \   00000000   0x000002BD         DC32     0x2bd

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5:
   \   00000000   0x00000579         DC32     0x579

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_1:
   \   00000000   0xFFFFFD44         DC32     0xfffffd44

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_2:
   \   00000000   0x........         DC32     man_rpt_work+0x1A0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7:
   \   00000000   0x........         DC32     ?_1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \   00000000   0x........         DC32     man_rpt_work+0xB98

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_1:
   \   00000000   0x........         DC32     man_rpt_work+0x1254

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_2:
   \   00000000   0x00000335         DC32     0x335

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_3:
   \   00000000   0x........         DC32     man_rpt_req_callback

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_4:
   \   00000000   0x0000020A         DC32     0x20a

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_5:
   \   00000000   0x0000020F         DC32     0x20f

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_6:
   \   00000000   0x........         DC32     man_rpt_work+0x26C

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_7:
   \   00000000   0x........         DC32     man_rpt_work+0x860

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_8:
   \   00000000   0x........         DC32     man_rpt_work+0x1A0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_9:
   \   00000000   0x000005F1         DC32     0x5f1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_10:
   \   00000000   0x........         DC32     man_rpt_work+0x9C

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_11:
   \   00000000   0x000016B8         DC32     0x16b8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_12:
   \   00000000   0x........         DC32     man_rpt_work

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \   00000000   0x........         DC32     man_rpt_work+0xB0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_1:
   \   00000000   0x........         DC32     man_rpt_work+0x88

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_2:
   \   00000000   0x00000446         DC32     0x446

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_3:
   \   00000000   0x00000453         DC32     0x453

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_4:
   \   00000000   0x........         DC32     man_rpt_work

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_5:
   \   00000000   0x0000045B         DC32     0x45b

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_6:
   \   00000000   0x00000475         DC32     0x475

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_7:
   \   00000000   0x........         DC32     man_rpt_work+0x6C

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_8:
   \   00000000   0x00000482         DC32     0x482

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_9:
   \   00000000   0x........         DC32     man_rpt_work+0x84

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_10:
   \   00000000   0x0000048A         DC32     0x48a

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_11:
   \   00000000   0x........         DC32     man_rpt_work+0xC4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_12:
   \   00000000   0x........         DC32     man_rpt_req_callback

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \   00000000   0x000004B2         DC32     0x4b2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11:
   \   00000000   0x000004BF         DC32     0x4bf

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12:
   \   00000000   0x........         DC32     man_rpt_work+0x98

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_1:
   \   00000000   0x........         DC32     man_rpt_work+0x94

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17:
   \   00000000   0x........         DC32     man_rpt_work+0x69

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19:
   \   00000000   0x........         DC32     man_rpt_work+0x8C

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_1:
   \   00000000   0x........         DC32     man_rpt_work+0x74

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22:
   \   00000000   0x........         DC32     man_rpt_work+0x9C

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_1:
   \   00000000   0x........         DC32     man_rpt_work+0x68

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_2:
   \   00000000   0x........         DC32     man_rpt_work+0x6B

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_3:
   \   00000000   0x........         DC32     man_rpt_work+0x90

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_4:
   \   00000000   0x........         DC32     man_rpt_work+0xC4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_5:
   \   00000000   0x........         DC32     man_rpt_work

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_6:
   \   00000000   0x........         DC32     man_rpt_work+0x6C

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_7:
   \   00000000   0x00000BC8         DC32     0xbc8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_8:
   \   00000000   0x........         DC32     man_rpt_work+0x6A

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_9:
   \   00000000   0x........         DC32     man_rpt_work+0x80

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_10:
   \   00000000   0x........         DC32     man_rpt_work+0x94

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_11:
   \   00000000   0x........         DC32     man_rpt_work+0x98

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_12:
   \   00000000   0x........         DC32     man_rpt_work+0xB4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_13:
   \   00000000   0x........         DC32     man_rpt_work+0xB0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_14:
   \   00000000   0x........         DC32     man_rpt_work+0x74

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x25 0x64          DC8 25H, 64H, 3BH, 25H, 64H, 3BH, 25H, 64H
   \              0x3B 0x25    
   \              0x64 0x3B    
   \              0x25 0x64    
   \   00000008   0x3B 0x25          DC8 3BH, 25H, 64H, 3BH, 25H, 64H, 3BH, 25H
   \              0x64 0x3B    
   \              0x25 0x64    
   \              0x3B 0x25    
   \   00000010   0x64 0x3B          DC8 64H, 3BH, 25H, 64H, 3BH, 25H, 64H, 3BH
   \              0x25 0x64    
   \              0x3B 0x25    
   \              0x64 0x3B    
   \   00000018   0x25 0x64          DC8 25H, 64H, 3BH, 25H, 64H, 3BH, 25H, 64H
   \              0x3B 0x25    
   \              0x64 0x3B    
   \              0x25 0x64    
   \   00000020   0x3B 0x25          DC8 3BH, 25H, 64H, 3BH, 25H, 64H, 2EH, 25H
   \              0x64 0x3B    
   \              0x25 0x64    
   \              0x2E 0x25    
   \   00000028   0x30 0x32          DC8 30H, 32H, 64H, 3BH, 25H, 64H, 3BH, 25H
   \              0x64 0x3B    
   \              0x25 0x64    
   \              0x3B 0x25    
   \   00000030   0x64 0x3B          DC8 64H, 3BH, 30H, 2EH, 30H, 30H, 3BH, 25H
   \              0x30 0x2E    
   \              0x30 0x30    
   \              0x3B 0x25    
   \   00000038   0x64 0x3B          DC8 64H, 3BH, 25H, 64H, 3BH, 0
   \              0x25 0x64    
   \              0x3B 0x00    
   \   0000003E   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_1:
   \   00000000   0x4C 0x54          DC8 4CH, 54H, 45H, 31H, 3BH, 25H, 64H, 3BH
   \              0x45 0x31    
   \              0x3B 0x25    
   \              0x64 0x3B    
   \   00000008   0x25 0x64          DC8 25H, 64H, 3BH, 25H, 73H, 3BH, 30H, 30H
   \              0x3B 0x25    
   \              0x73 0x3B    
   \              0x30 0x30    
   \   00000010   0x30 0x30          DC8 30H, 30H, 30H, 30H, 30H, 30H, 3BH, 25H
   \              0x30 0x30    
   \              0x30 0x30    
   \              0x3B 0x25    
   \   00000018   0x64 0x3B          DC8 64H, 3BH, 25H, 64H, 3BH, 25H, 64H, 25H
   \              0x25 0x64    
   \              0x3B 0x25    
   \              0x64 0x25    
   \   00000020   0x25 0x3B          DC8 25H, 3BH, 25H, 64H, 25H, 25H, 3BH, 25H
   \              0x25 0x64    
   \              0x25 0x25    
   \              0x3B 0x25    
   \   00000028   0x64 0x3B          DC8 64H, 3BH, 25H, 30H, 32H, 64H, 25H, 30H
   \              0x25 0x30    
   \              0x32 0x64    
   \              0x25 0x30    
   \   00000030   0x32 0x64          DC8 32H, 64H, 25H, 30H, 32H, 64H, 25H, 30H
   \              0x25 0x30    
   \              0x32 0x64    
   \              0x25 0x30    
   \   00000038   0x32 0x64          DC8 32H, 64H, 25H, 30H, 32H, 64H, 25H, 30H
   \              0x25 0x30    
   \              0x32 0x64    
   \              0x25 0x30    
   \   00000040   0x32 0x64          DC8 32H, 64H, 3BH, 25H, 64H, 3BH, 0
   \              0x3B 0x25    
   \              0x64 0x3B    
   \              0x00         
   \   00000047   0x00               DC8 0
   1664          
   1665          
   1666          
   1667          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   man_rpt_1000ms_main
        16   -> man_data_get_fixed
        16   -> man_data_get_sensor
        16   -> man_dbglog_setting
        16   -> man_rpt_check_setting
       4   man_rpt_check_send_state
       8   man_rpt_check_setting
         8   -> __aeabi_memcpy
         8   -> man_data_get_setting_gpssleeptime
         8   -> man_rpt_init_cycle_counter
         8   -> memcmp
       0   man_rpt_get_data
       8   man_rpt_init
         8   -> __aeabi_memset
         8   -> man_http_udp_state
         8   -> man_rpt_check_setting
       0   man_rpt_init_cycle_counter
      16   man_rpt_main
        16   -- Indirect call
        16   -> man_data_get_sensor
        16   -> man_error_set
        16   -> man_http_get_status
        16   -> man_http_udp_close
        16   -> man_http_udp_open
        16   -> man_http_udp_send
        16   -> man_msg_check_send_state
        16   -> man_rpt_make_body_sensor
        16   -> man_rpt_return_callback
        16   -> man_rpt_send_body_sensor
        16   -> man_rpt_set_sequense
        16   -> man_rpt_usb_send_body_sensor
        16   -> man_timer_get_1ms_count
        16   -> man_timer_get_elapsed_time
        16   -> man_usb_rpt_send
      96   man_rpt_make_body_sensor
        96   -> gm_time
        96   -> man_data_get_other
        96   -> man_data_get_sensor
        96   -> man_rpt_make_info_sensor
        96   -> man_rtc_get_clock
        96   -> sprintf
        96   -> strlen
      88   man_rpt_make_info_sensor
        88   -> __aeabi_memcpy
        88   -> __aeabi_memset
        88   -> man_data_get_sensor
        88   -> man_error_set
        88   -> sprintf
        88   -> strlen
        88 __aeabi_idiv
        88 __aeabi_idivmod
       4   man_rpt_noti_error
       0   man_rpt_req_callback
       8   man_rpt_req_park_interval
         8   -> man_dbglog_setting
       0   man_rpt_req_send_start
       0   man_rpt_req_send_stop
       0   man_rpt_req_state
       0   man_rpt_req_udp_start
       4   man_rpt_req_udp_stop
       0   man_rpt_req_usb_start
       0   man_rpt_req_usb_stop
       8   man_rpt_return_callback
         8   -- Indirect call
         8   -> man_rpt_set_sequense
      40   man_rpt_send_body_sensor
        40   -> __aeabi_memcpy
        40   -> man_error_set
        40   -> man_http_udp_send
        40   -> man_rpt_set_sequense
       8   man_rpt_set_sequense
         8   -> man_dbglog_setting
      40   man_rpt_usb_send_body_sensor
        40   -> __aeabi_memcpy
        40   -> man_rpt_set_sequense
        40   -> man_usb_rpt_send


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
       4  ??DataTable11
       4  ??DataTable12
       4  ??DataTable12_1
       4  ??DataTable17
       4  ??DataTable19
       4  ??DataTable19_1
       4  ??DataTable22
       4  ??DataTable22_1
       4  ??DataTable22_10
       4  ??DataTable22_11
       4  ??DataTable22_12
       4  ??DataTable22_13
       4  ??DataTable22_14
       4  ??DataTable22_2
       4  ??DataTable22_3
       4  ??DataTable22_4
       4  ??DataTable22_5
       4  ??DataTable22_6
       4  ??DataTable22_7
       4  ??DataTable22_8
       4  ??DataTable22_9
       4  ??DataTable4
       4  ??DataTable4_1
       4  ??DataTable4_2
       4  ??DataTable4_3
       4  ??DataTable4_4
       4  ??DataTable4_5
       4  ??DataTable4_6
       4  ??DataTable4_7
       4  ??DataTable4_8
       4  ??DataTable4_9
       4  ??DataTable5
       4  ??DataTable5_1
       4  ??DataTable5_2
       4  ??DataTable7
       4  ??DataTable8
       4  ??DataTable8_1
       4  ??DataTable8_10
       4  ??DataTable8_11
       4  ??DataTable8_12
       4  ??DataTable8_2
       4  ??DataTable8_3
       4  ??DataTable8_4
       4  ??DataTable8_5
       4  ??DataTable8_6
       4  ??DataTable8_7
       4  ??DataTable8_8
       4  ??DataTable8_9
       4  ??DataTable9
       4  ??DataTable9_1
       4  ??DataTable9_10
       4  ??DataTable9_11
       4  ??DataTable9_12
       4  ??DataTable9_2
       4  ??DataTable9_3
       4  ??DataTable9_4
       4  ??DataTable9_5
       4  ??DataTable9_6
       4  ??DataTable9_7
       4  ??DataTable9_8
       4  ??DataTable9_9
      64  ?_0
      72  ?_1
     288  man_rpt_1000ms_main
      50  man_rpt_check_send_state
      40  man_rpt_check_setting
       8  man_rpt_get_data
      30  man_rpt_init
      14  man_rpt_init_cycle_counter
    2128  man_rpt_main
     278  man_rpt_make_body_sensor
     416  man_rpt_make_info_sensor
      26  man_rpt_noti_error
      16  man_rpt_req_callback
      56  man_rpt_req_park_interval
       8  man_rpt_req_send_start
       8  man_rpt_req_send_stop
       6  man_rpt_req_state
      14  man_rpt_req_udp_start
      30  man_rpt_req_udp_stop
      14  man_rpt_req_usb_start
       8  man_rpt_req_usb_stop
      42  man_rpt_return_callback
     342  man_rpt_send_body_sensor
      64  man_rpt_set_sequense
     290  man_rpt_usb_send_body_sensor
    5816  man_rpt_work

 
 5 816 bytes in section .bss
   136 bytes in section .rodata
 4 424 bytes in section .text
 
 4 424 bytes of CODE  memory
   136 bytes of CONST memory
 5 816 bytes of DATA  memory

Errors: none
Warnings: none
